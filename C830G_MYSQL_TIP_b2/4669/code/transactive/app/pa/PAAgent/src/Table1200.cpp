/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/pa/PAAgent/src/Table1200.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  Table1200.cpp
//  Implementation of the Class Table1200
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290)
#endif // defined _MSC_VER

#include <time.h>
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "bus/scada/datapoint_library/src/DataPoint.h"
#include "bus/pa/cachedmaps/src/CachedMaps.h"
#include "app/pa/PAAgent/src/Table1200.h"
#include "app/pa/PAAgent/src/PasHelpers.h"
#include "app/pa/PAAgent/src/PasTableManager.h"
#include "app/pa/PAAgent/src/PASConnection.h"
#include "app/pa/PAAgent/src/CachedConfig.h"
#include "app/pa/PAAgent/src/Table202.h"
#include "app/pa/PAAgent/src/Table302.h"
#include "app/pa/PAAgent/src/Table1303.h"

using namespace TA_Base_Core;
using namespace TA_IRS_Bus;

namespace TA_IRS_App
{

// ExceptionChecked
Table1200::Table1200 (Table202* table202, Table302* table302, Table1303* table1303)
: AbstractPASTable(1200, 3200),
  m_pasHelpersInstance(NULL),
  m_readWait(),
  m_initialThread(true)// TD17013

{
    FUNCTION_ENTRY("Constructor");

    m_cachedMapsInstance = CachedMaps::getInstance();
    m_pasHelpersInstance = PasHelpers::getInstance();

    m_stationStatuses.resize(TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID);
    for (int stationId=0; stationId<TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID; ++stationId)
    {
        m_stationStatuses[stationId].resize(TA_Base_Bus::IPAAgentCorbaDef::PA_MAXZONEID);
    }

    m_table202 = table202;
    m_table302 = table302;
    m_table1303 = table1303;

	// jeffrey++ Bug457
	m_readIndex = 0;
	// ++jeffrey Bug457

	FUNCTION_EXIT;
}

// ExceptionChecked
Table1200::~Table1200()
{
    FUNCTION_ENTRY("Destructor");

    FUNCTION_EXIT;
}

// TD 17013
void Table1200::setInitalThreadValue(bool initialThreadValue)
{
	m_initialThread = initialThreadValue;
}
// TD 17013

// TD16749
void Table1200::processRead()
{
    ThreadGuard guard( m_lock );
	
    unsigned long absoluteZoneId = 1;
    for (int stationId=0; stationId<TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID; ++stationId)
    {
        for (int zoneId=0; zoneId < TA_Base_Bus::IPAAgentCorbaDef::PA_MAXZONEID; ++zoneId, ++absoluteZoneId)
        {
            // zone data is expected to be in the following format
            //
            // Bit: 15 14 13 12 11 10 09 08 07  06 05 04 03 02 01 00 
            //      |_____________________|  |  |__________________|
            //                |              |            |
            //           Source Id        Status       Priority
            //
            ta_uint16 zoneData = m_pasHelpersInstance->get16bit(m_buffer, (absoluteZoneId-1)*2);
			
			bool isNeedUpdateSourceId = false;
			bool isNeedUpdateStatus	  = false;
			bool isNeedUpdatePriority = false;
			
            CORBA::Octet sourceId = static_cast<CORBA::Octet>(zoneData>>8);
            bool status = ( zoneData & (0x0080) ) != 0;
            CORBA::Octet priority = static_cast<CORBA::Octet>(zoneData & (0x007f));
			
			if(m_stationStatuses[stationId][zoneId].m_sourceId != sourceId)
			{
				m_stationStatuses[stationId][zoneId].m_sourceId = sourceId;
				isNeedUpdateSourceId = true;
			}
			if(m_stationStatuses[stationId][zoneId].m_status != status)
			{
				m_stationStatuses[stationId][zoneId].m_status = status;
				isNeedUpdateStatus = true;
			}
			if(m_stationStatuses[stationId][zoneId].m_priority != priority)
			{
				m_stationStatuses[stationId][zoneId].m_priority = priority;
				isNeedUpdatePriority = true;
			}
			
            // The datapoints will only update if the DataPointState has changed
            // (with the exception of just a timestamp change).  Therefore to
            // simplify the code, we update the datapoint regardless.
			
			
			if(isNeedUpdateSourceId || m_initialThread)// TD17013
			{
				TA_Base_Bus::DataPoint* liveDp   = m_cachedMapsInstance->getLiveDataPointFromZoneId(absoluteZoneId);
				TA_Base_Bus::DataPoint* cyclicDp = m_cachedMapsInstance->getCyclicDataPointFromZoneId(absoluteZoneId);
				TA_Base_Bus::DataPoint* musicDp  = m_cachedMapsInstance->getMusicDataPointFromZoneId(absoluteZoneId);
				
				bool isLiveSource = false;
				
				if ( sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_STATION_SO ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_DEPOT_DCO ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_DEPOT_DPSCO ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_CS ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_TCO_1 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_TCO_2 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_TCO_3 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_SCO_1 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_SCO_2 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_MCO_1 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_MCO_2 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_MFT_OCR_PSCO ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_SPARE_1 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_SPARE_2 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_PCP_STATION_1 ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_PAGING_CONSOLE_PCP_STATION_2 )
				{
					isLiveSource = true;
					if (liveDp)
					{
						TA_Base_Bus::DpValue dpValue(liveDp->getDataPointDataType(),
							liveDp->getEnumLabelsMap(),
							liveDp->getBooleanLabels());
						dpValue.setBoolean ( true );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						liveDp->updateFieldState( newState );
					}
					if (musicDp)
					{
						TA_Base_Bus::DpValue dpValue(musicDp->getDataPointDataType(),
							musicDp->getEnumLabelsMap(),
							musicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						musicDp->updateFieldState( newState );
					}
					if (cyclicDp)
					{
						TA_Base_Bus::DpValue dpValue(cyclicDp->getDataPointDataType(),
							cyclicDp->getEnumLabelsMap(),
							cyclicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						cyclicDp->updateFieldState( newState );
					}
				}
				else if ( sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_OCR_MUSIC ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_STATION_MUSIC ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DEPOT_MUSIC )
				{
					if (liveDp)
					{
						TA_Base_Bus::DpValue dpValue(liveDp->getDataPointDataType(),
							liveDp->getEnumLabelsMap(),
							liveDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						liveDp->updateFieldState( newState );
					}
					if (musicDp)
					{
						TA_Base_Bus::DpValue dpValue(musicDp->getDataPointDataType(),
							musicDp->getEnumLabelsMap(),
							musicDp->getBooleanLabels());
						dpValue.setBoolean ( true );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						musicDp->updateFieldState( newState );
					}
					if (cyclicDp)
					{
						TA_Base_Bus::DpValue dpValue(cyclicDp->getDataPointDataType(),
							cyclicDp->getEnumLabelsMap(),
							cyclicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						cyclicDp->updateFieldState( newState );
					}
				}
				// jeffrey++ Bug457
				else if ( sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA1_SET_A ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA1_SET_B_D ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA2_SET_A ||
					sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA2_SET_B_D )
					//else if ( sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA_SET_A ||
					//          sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA_SET_B ||
					//          sourceId == TA_Base_Bus::IPAAgentCorbaDef::PA_SRC_DVA_SET_D )
					// ++jeffrey Bug457
				{
					if (cyclicDp)
					{
						// Cross reference tables to determine whether the
						// zone has a cyclic message sequence being played on it
						CORBA::Octet announcementId = m_table202->getAnnounceId(sourceId);
						unsigned int sequenceId = m_table302->getSequenceId(announcementId);
						bool isCyclic = m_table1303->isMessageSequenceCyclic(sequenceId);
						
						TA_Base_Bus::DpValue dpValue(cyclicDp->getDataPointDataType(),
							cyclicDp->getEnumLabelsMap(),
							cyclicDp->getBooleanLabels());
						dpValue.setBoolean ( isCyclic );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						cyclicDp->updateFieldState( newState );
					}
					
					
					// toan++
					// TD-10381
					// update live & music too!
					if (liveDp)
					{
						TA_Base_Bus::DpValue dpValue(liveDp->getDataPointDataType(),
							liveDp->getEnumLabelsMap(),
							liveDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						liveDp->updateFieldState( newState );
					}
					
					if (musicDp)
					{
						TA_Base_Bus::DpValue dpValue(musicDp->getDataPointDataType(),
							musicDp->getEnumLabelsMap(),
							musicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						musicDp->updateFieldState( newState );
					}
					// ++toan
				}
				else if ( sourceId == 0 ) // the zone has no source so set cyclic to false
				{
					if (liveDp)
					{
						TA_Base_Bus::DpValue dpValue(liveDp->getDataPointDataType(),
							liveDp->getEnumLabelsMap(),
							liveDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						liveDp->updateFieldState( newState );
					}
					if (musicDp)
					{
						TA_Base_Bus::DpValue dpValue(musicDp->getDataPointDataType(),
							musicDp->getEnumLabelsMap(),
							musicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						musicDp->updateFieldState( newState );
					}
					if (cyclicDp)
					{
						TA_Base_Bus::DpValue dpValue(cyclicDp->getDataPointDataType(),
							cyclicDp->getEnumLabelsMap(),
							cyclicDp->getBooleanLabels());
						dpValue.setBoolean ( false );
						TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
						cyclicDp->updateFieldState( newState );
					}
				}
			}
			
			if(isNeedUpdateStatus || m_initialThread) // TD17013
			{
				// update status datapoint
				TA_Base_Bus::DataPoint* statusDp = m_cachedMapsInstance->getStatusDataPointFromZoneId(absoluteZoneId);
				if (statusDp)
				{
					// PA Zone datapoint exists, so we can update it
					TA_Base_Bus::DpValue dpValue(statusDp->getDataPointDataType(),
						statusDp->getEnumLabelsMap(),
						statusDp->getBooleanLabels());
					
					dpValue.setBoolean ( status );
					
					// set up DataPointState with the default timestamp and quality
					TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
					
					statusDp->updateFieldState( newState );
				}
			}
			//	Maochun Sun++
			//	TD13410
			/*
			//	TD 10318.3 alanb: do not display priority number for "live" broadcasts
			if (isLiveSource)
			{
			continue;
			}
			*/
			//	++Maochun Sun
			//	TD13410
			
			if(isNeedUpdatePriority || m_initialThread)// TD17013
			{
				// update priority datapoint
				TA_Base_Bus::DataPoint* priorityDp = m_cachedMapsInstance->getPriorityDataPointFromZoneId(absoluteZoneId);
				if (priorityDp)
				{
					// PA Zone datapoint exists, so we can update it
					TA_Base_Bus::DpValue dpValue(priorityDp->getDataPointDataType(),
						priorityDp->getEnumLabelsMap(),
						priorityDp->getBooleanLabels());
					
					dpValue.setFloat ( priority, priorityDp->getPrecision() );
					
					// set up DataPointState with the default timestamp and quality
					TA_Base_Bus::DataPointState newState ( dpValue, time( NULL ), TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON );
					
					priorityDp->updateFieldState( newState );
				}
            }
			
        } // for zoneId
    } // for stationId
	
	// jeffrey++ Bug457
	
	// TD17013
	m_initialThread = false;
	// TD17013

	m_readIndex++;
	// ++jeffrey Bug457
	
    this->m_readWait.broadcast();
}
// TD16749

// ++ Bug456
void Table1200::readTimedWait()
{
	this->m_readWait.timedWait( CachedConfig::getInstance()->getFastPollRateInMSecs() );
}
// ++ Bug456

ZoneStatus Table1200::getZoneStatus(unsigned int zoneId, unsigned int stationId)
    //throw ( TA_Base_Core::PasConnectionException )
{
    TA_ASSERT( zoneId > 0 && zoneId <= TA_Base_Bus::IPAAgentCorbaDef::PA_MAXZONEID, "zoneId is out of range");
    TA_ASSERT( stationId > 0 && stationId <= TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID, "stationId is out of range");

	// ++ Bug456
    //this->m_readWait.timedWait( CachedConfig::getInstance()->getFastPollRateInMSecs() );
	// ++ Bug456

    ThreadGuard guard( m_lock );

    return m_stationStatuses[stationId-1][zoneId-1];
}
void invalidateDataPoint(TA_Base_Bus::DataPoint& datapoint);

void Table1200::invalidateAllDataPoints()
{
    unsigned long absoluteZoneId = 1;
    for (int stationId=0; stationId<TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID; ++stationId)
    {
        for (int zoneId=0; zoneId < TA_Base_Bus::IPAAgentCorbaDef::PA_MAXZONEID; ++zoneId, ++absoluteZoneId)
        {

            try
            {
                TA_Base_Bus::DataPoint* liveDp   = m_cachedMapsInstance->getLiveDataPointFromZoneId(absoluteZoneId);
                if (liveDp)
                {
                    invalidateDataPoint(*liveDp);
                }

                TA_Base_Bus::DataPoint* musicDp  = m_cachedMapsInstance->getMusicDataPointFromZoneId(absoluteZoneId);
                if (musicDp)
                {
                    invalidateDataPoint(*musicDp);
                }

                TA_Base_Bus::DataPoint* cyclicDp = m_cachedMapsInstance->getCyclicDataPointFromZoneId(absoluteZoneId);
                if (cyclicDp)
                {
                    invalidateDataPoint(*cyclicDp);
                }

                TA_Base_Bus::DataPoint* statusDp = m_cachedMapsInstance->getStatusDataPointFromZoneId(absoluteZoneId);
                if (statusDp)
                {
                    invalidateDataPoint(*statusDp);
                }

                TA_Base_Bus::DataPoint* priorityDp = m_cachedMapsInstance->getPriorityDataPointFromZoneId(absoluteZoneId);
                if (priorityDp)
                {
                    invalidateDataPoint(*priorityDp);
                }
            }
            catch(...)
            {
                // Carry on
            }
        }
    }
}


ReadTable1200::ReadTable1200( Table1200& table,
                              TA_IRS_Bus::Scheduler& socketScheduler,
                              TA_IRS_Bus::Scheduler& processScheduler,
                              IPasEventSource& eventSource )
    : PASReadEvent(socketScheduler, processScheduler, eventSource)
    , m_table( table )
{
}

ReadTable1200::ReadTable1200( ACE_Time_Value expiryTime,
                              Table1200& table,
                              TA_IRS_Bus::Scheduler& socketScheduler,
                              TA_IRS_Bus::Scheduler& processScheduler,
                              IPasEventSource& eventSource )
    : PASReadEvent(expiryTime, socketScheduler, processScheduler, eventSource)
    , m_table( table )
{
}

ReadTable1200::~ReadTable1200()
{
}

void ReadTable1200::readTable()
{
    ThreadGuard guard( this->m_table.m_lock );
    PASConnection::getInstance()->readTable( this->m_table.TABLE_NUMBER,
                                             this->m_table.m_buffer,
                                             this->m_table.BUFFER_SIZE);

    ACE_Time_Value nextReadTime(this->m_timeToExpire + ACE_Time_Value( 0, CachedConfig::getInstance()->getFastPollRateInMSecs() * 1000 ));
    if (nextReadTime < ACE_OS::gettimeofday())
    {
        nextReadTime = ACE_OS::gettimeofday();
    }

    this->m_socketScheduler.post( new ReadTable1200( nextReadTime,
                                                     this->m_table,
                                                     this->m_socketScheduler,
                                                     this->m_processScheduler ,
                                                     this->m_pasEventSource ) );
    this->m_processScheduler.post( new ProcessTable1200( this->m_table ) );
}

ProcessTable1200::ProcessTable1200( Table1200& table )
    : m_table( table )
{
}

ProcessTable1200::~ProcessTable1200()
{
}

void ProcessTable1200::consume()
{
    this->m_table.processRead();

    delete this;
}

void ProcessTable1200::cancel()
{
    delete this;
}

InvalidateTable1200::InvalidateTable1200( Table1200& table )
    : m_table( table )
{
}

InvalidateTable1200::~InvalidateTable1200()
{
}

void InvalidateTable1200::consume()
{
    this->m_table.invalidateAllDataPoints();

    delete this;
}

void InvalidateTable1200::cancel()
{
    delete this;
}


} // namespace TA_IRS_App

