/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/pa/PAAgent/src/PasTableManager.cpp $
  * @author:  Ripple
  * @version: $Revision: #2 $
  *
  * Last modification: $DateTime: 2011/05/12 17:46:29 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  PasTableManager.cpp
//  Implementation of the Class PasTableManager
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290)
#endif // defined _MSC_VER

#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "app/pa/PAAgent/src/PasTableManager.h"
#include "app/pa/PAAgent/src/PASConnection.h"
#include "app/pa/PAAgent/src/BroadcastManager.h"

using namespace TA_Base_Core;

namespace TA_IRS_App
{

	// ExceptionChecked
	PasTableManager::PasTableManager( unsigned long locationKey ) 
	    : m_socketScheduler()
	    , m_processScheduler()
	    , m_table100( new Table100() )
	    , m_table200( NULL )
	    , m_table1200( NULL )
	    , m_table201( NULL )
	    , m_table1201( NULL )
	    , m_table202( new Table202() )
	    , m_table204( NULL )
	    , m_table1204( NULL )
	    , m_table301( NULL )
	    , m_table302( new Table302() )
	    , m_table1301( NULL )
	    , m_table303( NULL )
	    , m_table1303( NULL )
	    , m_table350( new Table350( m_socketScheduler, m_processScheduler, *this ) )
	    , m_table550( new Table550() )
	    , m_table560( NULL )
	    , m_table570( new Table570( m_socketScheduler, m_processScheduler, *this ) )
	    , m_table590( new Table590() )
	    , m_table603( new Table603() )
	    , m_table604( new Table604( m_socketScheduler, m_processScheduler, locationKey, *this ) )
	    , m_table610( NULL )
	    , m_table1610( NULL )
	    , m_table630( new Table630( m_socketScheduler, m_processScheduler, *this ) )
		, m_isThreadsStart(false)

	{
	    FUNCTION_ENTRY("Constructor");

		/*
        try
        {			
	        this->m_processScheduler.start();
	        this->m_socketScheduler.start();		
        }
        catch (TA_Base_Core::TransactiveException &ex)
        {
            LOG_EXCEPTION_CATCH( SourceInfo, "TransactiveException", ex.what());
        }
        catch( std::exception & e )
	    {
		    LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, e.what() );       
	    }
        catch( ... )
	    {
		    LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, "Caught unknown exception" );
	    }
		*/

	    FUNCTION_EXIT;
	}

	Table100& PasTableManager::getTable100()
	{
	    return *(this->m_table100);
	}

	Table202& PasTableManager::getTable202()
	{
	    return *(this->m_table202);
	}

	Table302& PasTableManager::getTable302()
	{
	    return *(this->m_table302);
	}

	Table350& PasTableManager::getTable350()
	{
	    return *(this->m_table350);
	}

	Table550& PasTableManager::getTable550()
	{
	    return *(this->m_table550);
	}

	Table560& PasTableManager::getTable560()
	{
	    return *(this->m_table560);
	}

	Table570& PasTableManager::getTable570()
	{
	    return *(this->m_table570);
	}

	Table590& PasTableManager::getTable590()
	{
	    return *(this->m_table590);
	}

	Table603& PasTableManager::getTable603()
	{
	    return *(this->m_table603);
	}

	Table604& PasTableManager::getTable604()
	{
	    return *(this->m_table604);
	}

	Table630& PasTableManager::getTable630()
	{
	    return *(this->m_table630);
	}

	DisconnectFromPAFEPC* PasTableManager::getDisconnectEvent()
	{
	    LOG(SourceInfo, DebugUtil::GenericLog,  DebugUtil::DebugInfo, "Returning disconnect event.");
	    return new DisconnectFromPAFEPC( this->m_socketScheduler,
	                                     this->m_processScheduler,
	                                     *this,
	                                     *(PASConnection::getInstance()) );
	}

	// ExceptionChecked
	PasTableManager::~PasTableManager()
	{
	    FUNCTION_ENTRY("Destructor");

	    // liuyu++ #243 terminate error
	    //m_socketScheduler.terminate();
	    //m_processScheduler.terminate();
	    m_socketScheduler.terminateAndWait();
	    m_processScheduler.terminateAndWait();
		m_isThreadsStart = false;
	    // ++liuyu #243 terminate error

	    FUNCTION_EXIT;
	}

	void PasTableManager::setMonitor()
	{
	    m_socketScheduler.clear();
	    PASConnection::getInstance()->disable();
	}

	void PasTableManager::setControl()
	{
		if(false == m_isThreadsStart)
		{
			try
			{			
				this->m_processScheduler.start();
				this->m_socketScheduler.start();		
			}
			catch (TA_Base_Core::TransactiveException &ex)
			{
				LOG_EXCEPTION_CATCH( SourceInfo, "TransactiveException", ex.what());
			}
			catch( std::exception & e )
			{
				LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, e.what() );       
			}
			catch( ... )
			{
				LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, "Caught unknown exception" );
			}

		}	
		m_isThreadsStart = true;
	
	    PASConnection::getInstance()->enable();
	    m_socketScheduler.clear();

	    // Connect to the PA FEPC
	    m_socketScheduler.post( this->getConnectEvent() );
	}

} // namespace TA_IRS_App

