/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/pa/PAAgent/src/Table1201.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  Table1201.cpp
//  Implementation of the Class Table1201
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290)
#endif // defined _MSC_VER

#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "app/pa/PAAgent/src/Table1201.h"
#include "app/pa/PAAgent/src/PasHelpers.h"
#include "app/pa/PAAgent/src/PasTableManager.h"
#include "app/pa/PAAgent/src/PASConnection.h"

#include <ace/ACE.h>

using namespace TA_Base_Core;

const unsigned long TABLE_1201_SOURCE_ID_OFFSET = 0;
const unsigned long TABLE_1201_ANNOUNCE_ID_OFFSET = 1;
const unsigned long TABLE_1201_GLOBAL_COVERAGE_OFFSET = 2;

namespace TA_IRS_App
{

// ExceptionChecked
Table1201::Table1201( TA_IRS_Bus::Scheduler& socketScheduler,
                      TA_IRS_Bus::Scheduler& processScheduler,
                      IPasEventSource& eventSource )
    : AbstractWriteablePASTable(1201, 202)
    , m_socketScheduler( socketScheduler )
    , m_processScheduler( processScheduler )
    , m_pasEventSource( eventSource )
{
    FUNCTION_ENTRY("Constructor");

	FUNCTION_EXIT;
}

// ExceptionChecked
Table1201::~Table1201()
{
    FUNCTION_ENTRY("Destructor");

    FUNCTION_EXIT;
}

void Table1201::setTableDataAndWrite( CORBA::Octet sourceId, 
                                      CORBA::Octet announceId, 
                                      const TA_Base_Bus::IPAAgentCorbaDef::ZoneCoverage& zones)
    //throw ( TA_Base_Core::PasWriteErrorException, TA_Base_Core::PasConnectionException )
{
    ACE_Future<int> future;
    WriteTable1201* event = new WriteTable1201( *this,
                                                future,
                                                sourceId,
                                                announceId,
                                                zones,
                                                this->m_socketScheduler,
                                                this->m_processScheduler,
                                                this->m_pasEventSource );
    this->addWriteEvent(*event);
    this->m_socketScheduler.post( event );

    int retVal = -1;
    ACE_Time_Value tv( 20, 0 );
    tv += ACE_OS::gettimeofday();
    if( -1 == future.get( retVal, &tv ) )
    {
        char msg[100] = {0};
        sprintf(msg, "Timeout on write operation on table %d", TABLE_NUMBER);
        TA_THROW(TA_Base_Core::PasWriteErrorException(retVal, msg));
    }
    if (retVal)
    {
        char msg[100] = {0};
        sprintf(msg, "Write operation on table %d returned an error state %d", TABLE_NUMBER, retVal);
        TA_THROW(TA_Base_Core::PasWriteErrorException(retVal, msg));
    }
}

WriteTable1201::WriteTable1201( Table1201& table,
                              ACE_Future<int>& future,
                              CORBA::Octet sourceId,
                              CORBA::Octet announceId,
                              const TA_Base_Bus::IPAAgentCorbaDef::ZoneCoverage& zones,
                              TA_IRS_Bus::Scheduler& socketScheduler,
                              TA_IRS_Bus::Scheduler& processScheduler,
                              IPasEventSource& eventSource  )
    : PASWriteEvent(table, future, socketScheduler, processScheduler, eventSource)
    , m_table( table )
    , m_sourceId( sourceId )
    , m_announceId( announceId )
    , m_zones( zones )
{
}

WriteTable1201::WriteTable1201( ACE_Time_Value timeToExpire,
                                Table1201& table,
                                ACE_Future<int>& future,
                                CORBA::Octet sourceId,
                                CORBA::Octet announceId,
                                const TA_Base_Bus::IPAAgentCorbaDef::ZoneCoverage& zones,
                                TA_IRS_Bus::Scheduler& socketScheduler,
                                TA_IRS_Bus::Scheduler& processScheduler,
                                IPasEventSource& eventSource  )
    : PASWriteEvent(timeToExpire, table, future, socketScheduler, processScheduler, eventSource)
    , m_table( table )
    , m_sourceId( sourceId )
    , m_announceId( announceId )
    , m_zones( zones )
{
}

WriteTable1201::~WriteTable1201()
{
}

void WriteTable1201::writeTable()
{
    // Need a buffer for PA_MAXSTNID x 32bits
    ta_uint32* globalCoverageBitmaps = reinterpret_cast<ta_uint32*>(::calloc(TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID, 4));
    
    PasHelpers::getInstance()->coverageToGlobalCoverageBitmaps( this->m_zones, globalCoverageBitmaps);
    
    // ReEntrant as this will also be guarded in the write() call.
    ThreadGuard guard( this->m_table.m_lock ); 
    
    PasHelpers::getInstance()->set8bit (this->m_table.m_buffer, TABLE_1201_SOURCE_ID_OFFSET,      this->m_sourceId);
    PasHelpers::getInstance()->set8bit (this->m_table.m_buffer, TABLE_1201_ANNOUNCE_ID_OFFSET,    this->m_announceId);
    
    unsigned long offset = TABLE_1201_GLOBAL_COVERAGE_OFFSET;
    for (int stationId=1; stationId <= TA_Base_Bus::IPAAgentCorbaDef::PA_MAXSTNID; ++stationId)
    {
        PasHelpers::getInstance()->set32bit(this->m_table.m_buffer, offset, globalCoverageBitmaps[stationId-1]);
        offset+=4;
    }
    
    ::free(globalCoverageBitmaps);
    globalCoverageBitmaps = NULL;
    
    m_future.set( PASConnection::getInstance()->writeTable( this->m_table.TABLE_NUMBER,
                                                                             this->m_table.m_buffer,
                                                                             this->m_table.BUFFER_SIZE ) );
}

PASWriteEvent* WriteTable1201::recreateEvent(ACE_Time_Value timeToExpire)
{
    return new WriteTable1201(timeToExpire,
        this->m_table,
        this->m_future,
        this->m_sourceId,
        this->m_announceId,
        this->m_zones,
        this->m_socketScheduler,
        this->m_processScheduler,
        this->m_pasEventSource);
}

} // namespace TA_IRS_App

