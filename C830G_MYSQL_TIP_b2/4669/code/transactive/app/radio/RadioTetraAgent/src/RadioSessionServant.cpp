/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File$
  * @author:  Andy Parker
  * @version: $Revision$
  *
  * Last modification: $DateTime$
  * Last modified by:  $Author$
  *
  * This class provides a radio session servant (object)
  * available to apps and other agents via CORBA
  *
  */

///////////////////////////////////////////////////////////
//
//  RadioSessionServant.cpp
//  Implementation of the Class RadioSessionServant
//  Generated by Enterprise Architect
//  Created on:      30-Oct-2003 08:19:59
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#ifdef __WIN32__
#pragma warning(disable:4503)
#endif

#include <algorithm>
#include <locale>

#include "stdio.h"

#include "core/naming/src/Naming.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/message/src/CommsMessageSender.h"
#include "core/message/types/RadioComms_MessageTypes.h"
#include "core/message/types/ControlStationComms_MessageTypes.h"
#include "core/process_management/IDL/src/IManagedApplicationCorbaDef.h"
#include "core/message/src/MessagePublicationManager.h"
#include "core/exceptions/src/AuthenticationAgentException.h"
#include "core/exceptions/src/ObjectResolutionException.h"
#include "core/message/src/AuditMessageSender.h"
#include "core/message/types/RadioAudit_MessageTypes.h"
#include "core/data_access_interface/src/SessionAccessFactory.h"
#include "core/data_access_interface/src/SessionAccessFactory.h"
#include "core/data_access_interface/src/ISession.h"
#include "core/data_access_interface/src/ProfileAccessFactory.h"
#include "core/data_access_interface/src/IProfile.h"
#include "core/alarm/src/AlarmHelper.h"
#include "core/alarm/src/AlarmHelperManager.h"
#include "core/message/types/RadioAlarms_MessageTypes.h"
#include "core/utilities/src/RunParams.h"
#include "core/message/src/MessagePublicationManager.h"
#include "core/message/types/RadioComms_MessageTypes.h"
#include "core/data_access_interface/src/ILocation.h"
#include "core/data_access_interface/src/LocationAccessFactory.h"

#include "bus/radio/RadioAgentCorbaDef_4669/idl/src/IRadioCorbaDef.h"
#include "bus/security/rights_library/src/RightsLibrary.h"
#include "bus/security/access_control/actions/src/AccessControlledActions.h"
#include "bus/security/authentication_library/src/AuthenticationLibrary.h"
#include "bus/generic_agent/src/GenericAgent.h"
#include "bus/security/authentication_library/src/KeepSessionAliveThreadManager.h"

#include "app/radio/RadioTetraAgent/src/RadioSessionServant.h"
#include "app/radio/RadioTetraAgent/src/RadioSession.h"
#include "app/radio/RadioTetraAgent/src/Radio.h"
#include "app/radio/RadioTetraAgent/src/RadioTcpServer.h"
#include "app/radio/RadioTetraAgent/src/CallForwardingDetails.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionNotInitialisedException.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionException.h"
#include "app/radio/RadioTetraAgent/src/RadioCorbaTypeConverter.h"
#include "app/radio/RadioTetraAgent/src/RadioConfigurationException.h"
#include "app/radio/RadioTetraAgent/src/RadioTaskFactory.h"
#include "app/radio/RadioTetraAgent/src/RadioAgentConstants.h"

#include <iostream>

using namespace TA_IRS_App;
using TA_Base_Core::MessageSubscriptionManager;
using TA_Base_Core::RunParams;
using TA_Base_Core::DebugUtil;

namespace
{
    struct Uppercase : public std::unary_function< char,  char>
    {
        result_type operator()( argument_type c ) const { return static_cast<result_type>( std::toupper( static_cast<argument_type>(c), std::locale() ) ); }
    };
}


RadioSessionServant::RadioSessionServant( TA_IRS_App::Radio& radio,
										 TA_IRS_App::RadioTcpServer& radioTcpServer,
                                          TA_Base_Core::RadioSessionEntityDataPtr entityData,
                                          TA_Base_Core::RadioGlobalEntityData& globalEntityData
										  /*,TA_Base_Bus::ItaScada& itaScada */)
                    : m_radio(radio),
					  m_radioTcpServer(radioTcpServer),
                      m_radioSession(0),
                      m_sessionUpdateSubject(0),
                      m_eventSubscriber(0),
                      m_entityKey(0),
                      m_consoleID(0),
                      m_entityLocation(0),
                      m_entitySubsystem(0),
                      m_entityTypeKey(0),
                      m_active(false),
//                       m_lastAuditISession(0),
//                       m_lastAuditSession(""),
                      m_rightsLibrary(0),
                      m_auditMessageSender(0),
                      m_commsMessageSender(0),
					  m_transactiveSession("")
{
    FUNCTION_ENTRY("Constructor");

    m_entityName      = entityData->getName();
    m_entityKey       = entityData->getKey();
    m_entityLocation  = entityData->getLocation();
    m_entityLocationName = entityData->getLocationName();
    m_entitySubsystem = entityData->getSubsystem();
    m_entityTypeKey   = entityData->getTypeKey();
    m_consoleID       = entityData->getAssociatedConsoleKey();

    unsigned int audioLink = entityData->getAudioLinkId();
    unsigned int audioLinkServerId = entityData->getAudioLinkServerId();

	unsigned long switchUserWaitPeriod = entityData->getSwitchUserWaitPeriod();

    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
           "Constructing RadioSessionServant %s (%s), audioLink %u, audioLinkServer %u",
            m_entityName.c_str(), entityData->getDescription().c_str(), audioLink, audioLinkServerId); 

    bool isISCSSession = entityData->useForTrainCommunication();

    std::string autoLoginName("");

    // these are the auto login sessions
    if ( isISCSSession )
    {
        // for sessions that auto login, the name can be configured
        autoLoginName = entityData->getRadioUserName();

		if ( autoLoginName.empty() )
		{
			autoLoginName = TA_Base_Core::RunParams::getInstance().get( RadioAgentConstants::RADIOSESSION_ISCS_DEFAULT_NAME.c_str() );
		}

        // if it isnt, then use the default
        if ( autoLoginName.empty() )
        {
            // the iscs radio session
            if (isISCSSession)
            {
                // the login name is not configured - use the defaults
                if (m_entityLocation==1)
                {
                    // For occ (locationKey==1) is "OCCA".
                    autoLoginName = RadioAgentConstants::DEFAULT_OCC_LOGIN_NAME;
                }
                else
                {
                    // For stations, is <LOCATION>SMS ie. Location name (Uppercase)
                    // concatenated with "SMS"
                    autoLoginName = m_entityLocationName;
                    std::transform(autoLoginName.begin(), autoLoginName.end(), autoLoginName.begin(), Uppercase());
                    autoLoginName.append( RadioAgentConstants::DEFAULT_STATION_LOGIN_SUFFIX );
                }
            }
        }

        LOG_GENERIC( SourceInfo, DebugUtil::DebugDebug, 
            "Radio Session %s using login name '%s'",
            m_entityName.c_str(), autoLoginName.c_str() );
    }


    m_radioSession = new RadioSession( m_entityName,
                                       *this,
                                       m_radioTcpServer,
                                       audioLink,
                                       autoLoginName,
                                       m_consoleID,
									   switchUserWaitPeriod,
                                       globalEntityData,
                                       //itaScada,
									   isISCSSession);

    TA_ASSERT(m_radioSession!=NULL,"Radio session could not be created.");

    // set the ISCS radio session
    if (isISCSSession)
    {
        radio.setISCSRadioSession(*m_radioSession);
    }


    TA_Base_Bus::RightsLibraryFactory   rlf;
    m_rightsLibrary = rlf.buildRightsLibrary();
    TA_ASSERT(m_rightsLibrary!=NULL,"Rights library not created.");

    m_auditMessageSender = TA_Base_Core::MessagePublicationManager::getInstance().getAuditMessageSender(
        TA_Base_Core::RadioAudit::Context);
    TA_ASSERT(m_auditMessageSender!=NULL, "Cannot create audit message sender");

    // List for login/logout events
    if ( false == isISCSSession )
    {
    m_sessionUpdateSubject = new TA_Base_Bus::SessionUpdateSubject;
    m_eventSubscriber = new RadioEventSubscriber(*this, m_consoleID, m_entityLocation, *m_sessionUpdateSubject);  
    TA_ASSERT(m_eventSubscriber!=NULL,"Cannot create event subscriber - used for login/logout monitoring.");
    }


    // Add the radio session, but the initialisation will be done when the connection is established
    m_radioTcpServer.addSession(m_radioSession);

    m_commsMessageSender = TA_Base_Core::MessagePublicationManager::getInstance().getCommsMessageSender( TA_Base_Core::RadioComms::Context );
    TA_ASSERT(m_commsMessageSender != NULL, "Cannot create comms sender");


    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Successfully constructed RadioSessionServant %s", m_entityName.c_str());
    FUNCTION_EXIT;
}


RadioSessionServant::~RadioSessionServant()
{
    FUNCTION_ENTRY("Destructor");

    // Stop the session servant
    stop();

    delete m_eventSubscriber;
    m_eventSubscriber = NULL;
    delete m_sessionUpdateSubject;
    m_sessionUpdateSubject = NULL;
    delete m_radioSession;
    m_radioSession = NULL;
    delete m_rightsLibrary;
    m_rightsLibrary = NULL;
    delete m_auditMessageSender;
    m_auditMessageSender = NULL;
//     delete m_lastAuditISession;
//     m_lastAuditISession = NULL;

    delete m_commsMessageSender;
    m_commsMessageSender = NULL;

	TA_Base_Core::AlarmHelperManager::getInstance().cleanUp();
  
}


//
// receiveSpecialisedMessage
//
void RadioSessionServant::receiveSpecialisedMessage(const TA_Base_Core::CommsMessageCorbaDef& message)
{
	FUNCTION_ENTRY("receiveSpecialisedMessage");

	std::string mesgTypeKey = message.messageTypeKey.in();

	if (0 == mesgTypeKey.compare(TA_Base_Core::ControlStationComms::GXToTAMessageNotification.getTypeKey()))
	{
		TA_Base_Core::IManagedApplicationCorbaDef::GXToTAMessage* update = 0;

		if ( ( message.messageState >>= update ) != 0)
		{
			// Verify the message is intended for the Radio Agent
			if(update->entityType != TA_Base_Core::IManagedApplicationCorbaDef::RadioAgent)
			{
				return;
			}

			// Check the message content
			std::string msgtext = CORBA::string_dup(update->message);
			if(0 == msgtext.compare("Request Radio Call Fwd Status"))
			{
				receiveCallFwdRequest(message);
			}
		}
	}

	FUNCTION_EXIT;
}

void RadioSessionServant::receiveCallFwdRequest(const TA_Base_Core::CommsMessageCorbaDef& message)
{
    try
    {
        // Find the session this is intended for.

        // std::vector<TA_Base_Bus::SessionInfo> active_sessions = m_authenticationLibrary.getActiveSessions(""); // limin-- CL-21211
        std::vector<TA_Base_Bus::SessionInfo> active_sessions; // limin++ CL-21211
        m_authenticationLibrary.getActiveSessionsForOneLocation( "", TA_Base_Bus::KeepSessionAliveThreadManager::getInstance().getAuthCorbaNameObject( m_entityLocation ) ,active_sessions ); // limin++ CL-21211
        for ( std::vector<TA_Base_Bus::SessionInfo>::const_iterator iter = active_sessions.begin() ;
              iter != active_sessions.end();
              iter++
            )
        {
            const TA_Base_Bus::SessionInfo & sess_info = *iter;
            if ( sess_info.WorkstationId == m_consoleID )
            {
                CallForwardingDetails cfwdDetails;
                m_radioSession->getCallForwarding(cfwdDetails);
                m_radioSession->setCallForwarding(cfwdDetails, sess_info.SessionId);
            }
        }
    }
    catch (TA_Base_Core::ObjectResolutionException ore)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
             "receiveSpecialisedMessage failed (ObjectResolutionException) for %s",m_entityName.c_str());
    }
    catch (TA_Base_Core::AuthenticationAgentException aae)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
             "receiveSpecialisedMessage failed (AuthenticationAgentException) for %s",m_entityName.c_str());
    }
    catch (...)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
             "receiveSpecialisedMessage failed (unknown exception) for %s",m_entityName.c_str());
    }
}

void RadioSessionServant::detachSession()
{
    FUNCTION_ENTRY("detachSession");

    // Detach the session from the radio
    std::cout << "Detach session" << m_entityName << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Detach radio session %s",m_entityName.c_str());
    try
    {
        m_radioSession->detachSession();
    }
    catch (...)
    {
    }

    FUNCTION_EXIT;
}

void RadioSessionServant::sessionBegin(std::string sessionId)
{
    FUNCTION_ENTRY("sessionBegin");

	// create a task to process the session begin in a separate thread in order not to block the messaging thread
	m_radio.addBackgroundTask(
        RadioTaskFactory::createRadioSessionBeginTask( &m_radioTcpServer, *this, sessionId) );

    FUNCTION_EXIT;
}
    
void RadioSessionServant::sessionEnd(std::string sessionId)
{
    FUNCTION_ENTRY("sessionBegin");

	// create a task to process the session end in a separate thread in order not to block the messaging thread
	m_radio.addBackgroundTask(
        RadioTaskFactory::createRadioSessionEndTask( &m_radioTcpServer, *this, sessionId) );

    FUNCTION_EXIT;
}


void RadioSessionServant::sessionLogin(std::string sessionId)
{
    FUNCTION_ENTRY("sessionLogin(sessionId)");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    std::cout << "Login session" << m_entityName << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Login radio session %s (session id: %s)",m_entityName.c_str(),sessionId.c_str());

	m_radioSession->onSessionStatusChange( SessionNotLogin );

	m_transactiveSession = sessionId;
    // Get the profile associated with the session
    /*
    TA_Base_Core::ISession* session = TA_Base_Core::SessionAccessFactory::getInstance().getSession(sessionId);
    TA_ASSERT(session!=NULL,"No session found");
    unsigned long profileKey = session->getProfileKey();
    delete session;
    */

    // check the comment on AuthenticationLibrary::getSessionInfo
    // it says NOT to go directly to the database
    std::cout << "Getting Session Information" << std::endl;
	TA_Base_Bus::SessionInfo info = m_authenticationLibrary.getSessionInfo(sessionId, sessionId);
	
	std::cout << "Getting Operator" << std::endl;
	TA_Base_Core::IOperator * operatorIf = TA_Base_Core::OperatorAccessFactory::getInstance().getOperatorFromSession(info.SessionId, false);
	std::string strOperator ("");

	if (NULL !=operatorIf)
	{
		strOperator = operatorIf->getName();
		std::cout << "Operator : " << strOperator << std::endl;
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "OperatorName : %s", strOperator.c_str() );
		
	}
	
	TA_Base_Core::IProfile* profile = TA_Base_Core::ProfileAccessFactory::getInstance().getProfile(info.ProfileId[0]);

    TA_ASSERT(profile!=NULL,"No profile found");
    std::string loginName = profile->getItsiGroupName();
	std::string profileName = profile->getName();
    delete profile;

	if ( loginName == "" || strOperator.find("AgentOperator") != -1)
	{		
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, "%s does not belong to radio group.", profileName.c_str() );
		return;
	}
    
    // TODO - modify the SE_PROFILE_V and the associated DAI to retrieve password
    std::string password;

    sessionLogin(loginName, password, sessionId);

    FUNCTION_EXIT;
}

void RadioSessionServant::sessionLogin(const std::string& loginName, const std::string& password, const std::string& sessionId)
{
    FUNCTION_ENTRY("sessionLogin(loginName,password,sessionId)");

    // RvH 20050112 pre-iFAT addition
    // Session login name needs adjusting.  If location!=Occ, login should have
    // location name (uppercase) appended.
    std::string realLoginName = loginName;
	unsigned long unOccLocation = TA_Base_Core::LocationAccessFactory::getInstance().getOccLocationKey();
	unsigned long unDepotLocation = TA_Base_Core::LocationAccessFactory::getInstance().getDepotLocationKey();
    if ((m_entityLocation!=unOccLocation) && (m_entityLocation!=unDepotLocation))
    {
		//std::string locationName=m_entityLocationName;
		//use the logic location name instead of the physical one.
		std::string locationName;
		TA_Base_Core::ILocation* location;
		try
		{
			TA_Base_Bus::SessionInfo info = m_authenticationLibrary.getSessionInfo(sessionId, sessionId);

			location = TA_Base_Core::LocationAccessFactory::getInstance().getLocationByKey(info.LocationId) ;
			locationName = location->getName();
			delete location;
		}
		catch(...)
		{
			delete location;
		}
        std::transform(locationName.begin(), locationName.end(), locationName.begin(), Uppercase());
        realLoginName += locationName;
    }
    // std::cout << "Login session" << m_entityName << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Login radio session %s (session id: %s, login name: %s, password: %s)",m_entityName.c_str(),sessionId.c_str(),realLoginName.c_str(), password.c_str());

	try
	{
		m_radioSession->loginSession(realLoginName, password);

		// Now audit the event
		TA_Base_Core::DescriptionParameters parameters;
		TA_Base_Core::NameValuePair sessionPair("SessionName", m_entityName);
		TA_Base_Core::NameValuePair loginPair("ProfileName", loginName);
		parameters.push_back(&sessionPair);
		parameters.push_back(&loginPair);
		AuditOperation(TA_Base_Core::RadioAudit::RadioSessionLogin,parameters,sessionId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

    FUNCTION_EXIT;
}

	
void RadioSessionServant::sessionLogin(const char* loginName, const char* sessionId)
{
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
         "RadioSessionServant::sessionLogin");

	sessionLogin( std::string(sessionId) );
}

/**
* Perfoms radio session logout.
* 
* @param    sessionID
*/
void RadioSessionServant::sessionLogout(const char * sessionId)
{
	FUNCTION_ENTRY("sessionLogout");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	std::cout << "Logout session" << m_entityName << std::endl;
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Logout radio session %s (session id: %s)",m_entityName.c_str(),sessionId);

	m_radioSession->onSessionStatusChange( SessionNotLogin );

	try
	{
		m_radioSession->logoutSession();

		//xufeng++ TD15524
		// Now audit the event
		TA_Base_Core::DescriptionParameters parameters;
		TA_Base_Core::NameValuePair sessionPair1("SessionName", m_entityName);
		parameters.push_back(&sessionPair1);
		AuditOperation(TA_Base_Core::RadioAudit::RadioSessionLogout,parameters,sessionId);
		//++xufeng TD15524

	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

	//xufeng++ TD15524
	/*
	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair sessionPair1("SessionName", m_entityName);
	parameters.push_back(&sessionPair1);
	
	AuditOperation(TA_Base_Core::RadioAudit::RadioSessionLogout,parameters,sessionId);
	*/
	//++xufeng TD15524

	FUNCTION_EXIT;
}


//**********************************
// IRadioSession Interface Methods *
//**********************************

long RadioSessionServant::getSessionReference(const char * sessionId)
{
    FUNCTION_ENTRY("getSessionReference");

    long session;
    try
    {
        // Get the session reference
        session = m_radioSession->getValidSessionRef();
        std::cout << "Session reference:" << session << std::endl;
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
             "getSessionReference returned %ld",session);
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    FUNCTION_EXIT;
    return session;
}

void RadioSessionServant::answerCall(long callID,const char * sessionId)
{
    FUNCTION_ENTRY("answerCall");

    checkPermission(TA_Base_Bus::aca_RADIO_ANSWER_CALL,sessionId);

    std::cout << "Answering call:" << callID << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Answering call %ld",callID);
    try
    {
        m_radioSession->answerCall(callID,sessionId);
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    CallDetailsType    callDetails;
    try
    {
        m_radio.getCallDetails(callID,m_consoleID,callDetails);
    }
    catch(...)
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
             "Unable to get details for call %ld",callID);
        callDetails.callerTSI = "";
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    TA_Base_Core::NameValuePair  callDestPair("CallSource", callDetails.callerTSI);
    parameters.push_back(&callDestPair);
    AuditOperation(TA_Base_Core::RadioAudit::RadioAnswerCall,parameters,sessionId, callID);

    FUNCTION_EXIT;
}

long RadioSessionServant::makeCall(const char * destinationTSI, TA_Base_Bus::IRadioSessionCorbaDef::ECallType calltype, bool isFullDuplex,TA_Base_Bus::IRadioSessionCorbaDef::ECallPriority priority, bool hook, const char * sessionId, bool isInvisibleToGUIApps, long locationKey)// //TD19783
{
    FUNCTION_ENTRY("makeCall");

/*
    if (isEmergency)
    {
        checkPermission(TA_Base_Bus::aca_RADIO_MAKE_EMERGENCY_CALL,sessionId);
    }
    else
    {
        std::vector<TA_Base_Bus::AccessControlledAction>  actions;
        actions.push_back(TA_Base_Bus::aca_RADIO_MAKE_VOICE_CALL);
        actions.push_back(TA_Base_Bus::aca_RADIO_MAKE_TRAIN_CALL);
        checkPermission(actions,sessionId);
    }

*/
    std::cout << "Making call to:" << destinationTSI << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Making call to %s",destinationTSI);

    long callID = 0;
    try
    {
        //TD 10234
        //TD 14696
        //callID = m_radioSession->makeCall(destinationTSI,convertCallType(calltype),isFullDuplex,isEmergency,hook,sessionId,isInvisibleToGUIApps);
		ECallType eCallType; 
			
		RadioCorbaTypeConverter::convertECallTypeCorbaToNormal(static_cast<TA_Base_Bus::IRadioCorbaDef::ECallType>(calltype), eCallType);

        callID = m_radioSession->makeCall(destinationTSI, eCallType,
                                         isFullDuplex,RadioCorbaTypeConverter::convertECallPriorityCorbaToNormal(priority),hook,sessionId,isInvisibleToGUIApps, locationKey);//TD19783
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    
    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;


    AuditOperation(TA_Base_Core::RadioAudit::RadioVoiceCall,parameters,sessionId,callID);

    FUNCTION_EXIT;

    return callID;
}

void RadioSessionServant::releaseCall(long callID,const char * sessionId)
{
    FUNCTION_ENTRY("releaseCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    //checkPermission(TA_Base_Bus::aca_RADIO_TERMINATE_CALL,sessionId); //td16409

    std::cout << "Releasing call:" << callID << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Releasing call %ld",callID);


    CallDetailsType    callDetails;
    try
    {
        m_radio.getCallDetails(callID,m_consoleID,callDetails);
    }
    catch(...)
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
             "Unable to get details for call %ld",callID);
        callDetails.callerTSI = "";
    }

    
    try
    {
        m_radioSession->releaseCall(callID,sessionId);
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    // Now audit the event

    TA_Base_Core::DescriptionParameters parameters;
    
    if(callDetails.callCategory == TextMessage)
    {
        TA_Base_Core::NameValuePair  callTextPair("TextSource", callDetails.callerName);
        TA_Base_Core::NameValuePair  callMessagePair("TextMessage", callDetails.callText); 
        parameters.push_back(&callTextPair);
        parameters.push_back(&callMessagePair);
        AuditOperation(TA_Base_Core::RadioAudit::RadioReadTextMessage,parameters,sessionId);
    }
    else
    {
        TA_Base_Core::NameValuePair  callDestPair("CallSource", callDetails.callerTSI);
        parameters.push_back(&callDestPair);
        AuditOperation(TA_Base_Core::RadioAudit::RadioReleaseCall,parameters,sessionId,callID);
    }        
    FUNCTION_EXIT;
}

void RadioSessionServant::holdCall(long callId,const char * sessionId)
{
    FUNCTION_ENTRY("holdCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    checkPermission(TA_Base_Bus::aca_RADIO_HOLD_CALL,sessionId);
    
    std::cout << "Holding call:" << callId << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Holding call %ld",callId);

    try
    {
        m_radioSession->holdCall(callId,sessionId);
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    AuditOperation(TA_Base_Core::RadioAudit::RadioHoldCall,parameters,sessionId,callId);
    
    FUNCTION_EXIT;
}

void RadioSessionServant::resumeCall(long callId,const char * sessionId)
{
    FUNCTION_ENTRY("resumeCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    checkPermission(TA_Base_Bus::aca_RADIO_HOLD_CALL,sessionId);
    
    std::cout << "Resuming call:" << callId << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Resuming call %ld",callId);

    try
    {
        m_radioSession->resumeCall(callId,sessionId);
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    AuditOperation(TA_Base_Core::RadioAudit::RadioResumeCall,parameters,sessionId,callId);
    
    FUNCTION_EXIT;
}

long RadioSessionServant::startMonitoring(const char * tsi, const char * sessionID)
{
	FUNCTION_ENTRY("startMonitoring()");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_MONITOR_CALLS,sessionID);

	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "startMonitoring() - TSI=%s sessionID=%s", tsi, sessionID);

	try
	{
        m_radioSession->startMonitoring(tsi);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// TD14077
	TA_Base_Core::DescriptionParameters parameters;
	long callID = atol(tsi);
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorStartMonitoring,parameters,sessionID, callID);
	
    FUNCTION_EXIT;

    return -1;
}

void RadioSessionServant::stopMonitoring(const char * tsi, const char * sessionID)
{
	FUNCTION_ENTRY("stopMonitoring()");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    // Also needed for stopping monitoring ??
	// checkPermission(TA_Base_Bus::aca_RADIO_MONITOR_CALLS,sessionId);

	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "stopMonitoring() - tsi=%s sessionID=%s", tsi, sessionID);

	try
	{
        m_radioSession->stopMonitoring(tsi);
	}
	catch (RadioException& e)
	{
		// Error executing the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	//TD17054
	TA_Base_Core::DescriptionParameters parameters;
	long callID = atol(tsi);
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorStopMonitoring,parameters,sessionID, callID);

    FUNCTION_EXIT;
}

void RadioSessionServant::getActiveCalls(const char * tsi, const char * sessionID)
{
    //
    // Called by the RadioMonitor GUI for OneShot monitoring
	FUNCTION_ENTRY("getActiveCalls()");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "getActiveCalls() - tsi=%s sessionID=%s", tsi, sessionID);

	try
	{
        m_radioSession->oneShotMonitoring(tsi);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
	
	//TD17054
	TA_Base_Core::DescriptionParameters parameters;
	long callID = atol(tsi);
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorOneShot,parameters,sessionID, callID);

    FUNCTION_EXIT;
}

long RadioSessionServant::startListening(long callId,const char * sessionId)
{
	FUNCTION_ENTRY("startListening");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "startListening() - callId=%ld sessionId=%s", callId, sessionId);

	checkPermission(TA_Base_Bus::aca_RADIO_MONITOR_LISTEN,sessionId);

    long new_callId = 0;

	try
	{
        new_callId = m_radioSession->startListening(callId);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// TD13045
	TA_Base_Core::DescriptionParameters parameters;
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorStartListening,parameters,sessionId, callId);
	
	FUNCTION_EXIT;
    return new_callId;
}

void RadioSessionServant::stopListening(long callId, const char * sessionId)
{
	FUNCTION_ENTRY("stopListening()");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "stopListening() - callId=%ld sessionId=%s", callId, sessionId);

	try
	{
        m_radioSession->stopListening(callId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
	
	// TD13047
	TA_Base_Core::DescriptionParameters parameters;
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorStopListening,parameters,sessionId, callId);

    FUNCTION_EXIT;
}


long RadioSessionServant::joinCall(long callId, const char * sessionId)
{
	FUNCTION_ENTRY("joinCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_MONITOR_JOIN,sessionId);

	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "joinCall() - callId %ld (session %s)", callId, sessionId);

    long new_callId = 0;

    try
	{
        new_callId = m_radioSession->joinCall(callId);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// TD13046
	TA_Base_Core::DescriptionParameters parameters;
	AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorJoinCall,parameters,sessionId, callId);

	FUNCTION_EXIT;
    return new_callId;
}

void RadioSessionServant::selectCall(long callId,const char * sessionId)
{
    FUNCTION_ENTRY("selectCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Selecting call %ld",callId);

    try
    {
        m_radioSession->selectCall(callId,sessionId);
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    CallDetailsType    callDetails;
    try
    {
        m_radio.getCallDetails(callId,m_consoleID,callDetails);
    }
    catch(...)
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
             "Unable to get details for call %ld",callId);
        callDetails.callerTSI = "";
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    std::string callTypeString = getCallTypeString(callDetails.callType);
    TA_Base_Core::NameValuePair  callTypePair("CallType", callTypeString);
    TA_Base_Core::NameValuePair  callDestPair("CallSource", callDetails.callerTSI);
    parameters.push_back(&callTypePair);
    parameters.push_back(&callDestPair);

    AuditOperation(TA_Base_Core::RadioAudit::RadioSelectCall,parameters,sessionId,callId);
    
    FUNCTION_EXIT;
}

void RadioSessionServant::deselectCall(long callId,const char * sessionId)
{
    FUNCTION_ENTRY("deselectCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Deselecting call %ld",callId);

    try
    {
        m_radioSession->deselectCall(callId,sessionId);
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    
    CallDetailsType    callDetails;
    try
    {
        m_radio.getCallDetails(callId,m_consoleID,callDetails);
    }
    catch(...)
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
             "Unable to get details for call %ld",callId);
        callDetails.callerTSI = "";
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    std::string callTypeString = getCallTypeString(callDetails.callType);
    TA_Base_Core::NameValuePair  callTypePair("CallType", callTypeString);
    TA_Base_Core::NameValuePair   callSourcePair("CallSource", callDetails.callerTSI);
    parameters.push_back(&callTypePair);
    parameters.push_back(&callSourcePair);

    AuditOperation(TA_Base_Core::RadioAudit::RadioDeselectCall,parameters,sessionId,callId);

    FUNCTION_EXIT;
}

void RadioSessionServant::adjustCallVolume(long callId,bool increase,const char * sessionId)
{
    FUNCTION_ENTRY("adjustCallVolume");

	TA_Base_Bus::GenericAgent::ensureControlMode();
    try
    {
        m_radioSession->adjustCallVolume(callId,increase,sessionId);
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    TA_Base_Core::NameValuePair  volPair("VolumeDirection", increase ? "increase" : "decrease");
    parameters.push_back(&volPair);
    AuditOperation(TA_Base_Core::RadioAudit::RadioAdjustCallVolume,parameters,sessionId,callId);

    FUNCTION_EXIT;
}


/**
* Advise radio that user wishes to talk.  Used for half duplex calls.
* @param    priority    Priority 0..3 (0=low)
*/
void RadioSessionServant::demandTX(short priority,const char * sessionId,CORBA::ULong& queuedID)
{
	FUNCTION_ENTRY("demandTX");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	try
	{
		m_radioSession->demandTX(priority,sessionId,queuedID);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	char   text[50] = {0};
	sprintf(text,"%d",priority);
	TA_Base_Core::NameValuePair txPair("TXPriority", text);
    parameters.push_back(&txPair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioDemandTX,parameters,sessionId);

	FUNCTION_EXIT;
}


/**
* Used to advise radio that operator has finished talking.  
* Used for half duplex calls only.
*/
void RadioSessionServant::ceaseTX(const char * sessionId)
{
	FUNCTION_ENTRY("ceaseTX");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	try
	{
		m_radioSession->ceaseTX(sessionId);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	AuditOperation(TA_Base_Core::RadioAudit::RadioCeaseTX,parameters,sessionId);
	
	FUNCTION_EXIT;
}


char* RadioSessionServant::makeDynamicGroup(const TA_Base_Bus::IRadioSessionCorbaDef::DestinationTSIList& destTSIs, const char * sessionId)
{
    FUNCTION_ENTRY("makeDynamicGroup");

	TA_Base_Bus::GenericAgent::ensureControlMode();
//    checkPermission(TA_Base_Bus::aca_MAKE_DYNAMIC_GROUP,sessionId);

    std::string                   dgnaTSI;
    std::vector<std::string>   destlist;
    std::string                destinations;
    std::string                   SubscriberName;

    

    for (unsigned int iLoop=0;iLoop<destTSIs.length();iLoop++)
    {
        destlist.push_back(std::string(destTSIs[iLoop]));
        if (iLoop>0) destinations += ",";
        destinations += destTSIs[iLoop];
    }
    
    std::cout << "Create dynamic group containing "<< destinations << std::endl;
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
         "Creating dynamic group containing %s",destinations.c_str());

    try
    {
        dgnaTSI = m_radioSession->makeDynamicGroup(destlist,sessionId);
        SubscriberName = m_radioSession->getSubscriberName(m_radioSession->getSessionTSI());
    }
    catch (RadioSessionException& e)
    {
        // Error excuting the command
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }
    
    //
    // Now audit the event
    TA_Base_Core::DescriptionParameters parameters;
    TA_Base_Core::NameValuePair destPair("DynamicGroupName", SubscriberName);
    parameters.push_back(&destPair);
    AuditOperation(TA_Base_Core::RadioAudit::RadioDynamicGroupCreated,parameters,sessionId);
    
    FUNCTION_EXIT;
    return CORBA::string_dup(dgnaTSI.c_str());

}

/**
* Sends a text message to another subscriber.
* @param    destinationTSI
* @param    message
* @param    sessionId
*/
void RadioSessionServant::sendTextMessage(const char * destinationTSI,
										  const char * message,
										  const char * sessionId)
{
	FUNCTION_ENTRY("sendTextMessage");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_SEND_TEXT,sessionId);
	
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Sending text message '%s' to '%s'",message,destinationTSI);

	try
	{	
		m_radioSession->sendTextMessage(destinationTSI,message,sessionId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
   catch (RadioSessionNotInitialisedException&)
    {
        throw TA_Base_Bus::IRadioSessionCorbaDef::sessionNotInitialiseException();  
    }
    catch (RadioException& e)
    {
        // catch all radio exceptions
        throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
    }

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair destPair("TextDestination", destinationTSI);
	TA_Base_Core::NameValuePair messagePair("TextMessage", message);
    parameters.push_back(&destPair);
    parameters.push_back(&messagePair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioSendTextMessage,parameters,sessionId);
	
	FUNCTION_EXIT;
}

void RadioSessionServant::terminateCall(long callId, const char * sessionId, bool bIsMonitored)
{
	FUNCTION_ENTRY("terminateCall");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_MONITOR_TERMINATE,sessionId);

	std::cout << "Terminating call:" << callId << std::endl;
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
		 "terminateCall() - callId %ld (session %s)", callId, sessionId);


	CallDetailsType    callDetails;
	try
	{
        m_radio.getCallDetails(callId,m_consoleID,callDetails);
	}
	catch(...)
	{
		LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
			 "Unable to get details for call %ld",callId);
		callDetails.callerTSI = "";
	}

	try
	{
        m_radioSession->terminateCall(callId);
	}
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;

	if (bIsMonitored) // TD14247
	{
		AuditOperation(TA_Base_Core::RadioAudit::RadioMonitorEndCall,parameters,sessionId,callId);
	}
	else
	{
		TA_Base_Core::NameValuePair  callDestPair("CallDestination", callDetails.calledTSI);
		parameters.push_back(&callDestPair);
		TA_Base_Core::NameValuePair   callSourcePair("CallSource", callDetails.callerTSI);
		parameters.push_back(&callSourcePair);

		AuditOperation(TA_Base_Core::RadioAudit::RadioTerminateCall,parameters,sessionId,callId);
	}
	
	FUNCTION_EXIT;
}

void RadioSessionServant::setCallForwarding(const TA_Base_Bus::IRadioSessionCorbaDef::CallForwardDetails& callForwardDetails,const char * sessionId)
{
    FUNCTION_ENTRY("setCallForwarding");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_CONFIGURE_CALL_FORWARD,sessionId);
   
	CallForwardingDetails details;
	std::string  forwardMode;

    details.destinationTSI = callForwardDetails.destinationTSI;

    switch (callForwardDetails.forwardAction)
    {
		case TA_Base_Bus::IRadioSessionCorbaDef::NeverForward:
			details.forwardAction = CallForwardingDetails::NeverForward;
			forwardMode = "Never";
			break;
		case TA_Base_Bus::IRadioSessionCorbaDef::ForwardNotReachable:
			details.forwardAction = CallForwardingDetails::ForwardNotReachable;
			forwardMode = "Not Reachable";
			break;
		case TA_Base_Bus::IRadioSessionCorbaDef::ForwardAlways:
			details.forwardAction = CallForwardingDetails::ForwardAlways;
			forwardMode = "Always";
			break;
    }

	try
	{
		m_radioSession->setCallForwarding(details,sessionId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioFallbackException rfe)
    {
        // morph into Corba radioFallbackException
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioFallbackException();  
    }
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}

	
	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair forwardPair("ForwardMode", forwardMode);
	TA_Base_Core::NameValuePair destPair("CallDestination", details.destinationTSI);
    parameters.push_back(&forwardPair);
    parameters.push_back(&destPair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioSetCallForwarding,parameters,sessionId);

    FUNCTION_EXIT;
}

TA_Base_Bus::IRadioSessionCorbaDef::CallForwardDetails* RadioSessionServant::getCallForwarding()
{
    FUNCTION_ENTRY("getCallForwarding");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	CallForwardingDetails details;
	try
	{
		m_radioSession->getCallForwarding(details);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioFallbackException rfe)
    {
        // morph into Corba radioFallbackException
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioFallbackException();  
    }

    TA_Base_Bus::IRadioSessionCorbaDef::CallForwardDetails* corbaDetails = 
        new TA_Base_Bus::IRadioSessionCorbaDef::CallForwardDetails();

    switch (details.forwardAction)
    {
		case CallForwardingDetails::NeverForward:
			corbaDetails->forwardAction = TA_Base_Bus::IRadioSessionCorbaDef::NeverForward;
			break;
		case CallForwardingDetails::ForwardNotReachable:
			corbaDetails->forwardAction = TA_Base_Bus::IRadioSessionCorbaDef::ForwardNotReachable;
			break;
		case CallForwardingDetails::ForwardAlways:
			corbaDetails->forwardAction = TA_Base_Bus::IRadioSessionCorbaDef::ForwardAlways;
			break;
    }

    corbaDetails->destinationTSI = details.destinationTSI.c_str();

    FUNCTION_EXIT;
    return corbaDetails;
}

void RadioSessionServant::createPatch(const TA_Base_Bus::IRadioSessionCorbaDef::PatchList& list,const char* patchName,const char * sessionId)
{
	FUNCTION_ENTRY("createPatch");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_CONFIGURE_PATCH_GROUPS,sessionId);

	std::vector<std::string> patchList;
	for (unsigned int iLoop=0;iLoop<list.length();iLoop++)
	{
		patchList.push_back(std::string(list[iLoop]));
	}

	try
	{
		m_radioSession->createPatch(patchList,patchName,sessionId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioFallbackException rfe)
    {
        // morph into Corba radioFallbackException
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioFallbackException();  
    }
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}


	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair patchPair("PatchName", patchName);
    parameters.push_back(&patchPair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioCreatePatch,parameters,sessionId);
	
	FUNCTION_EXIT;
}


void RadioSessionServant::deletePatch(const char* patchName,const char * sessionId)
{
	FUNCTION_ENTRY("deletePatch");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_CONFIGURE_PATCH_GROUPS,sessionId);

	try
	{
		m_radioSession->deletePatch(patchName,sessionId);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioFallbackException rfe)
    {
        // morph into Corba radioFallbackException
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioFallbackException();  
    }
	catch (RadioException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
 

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair patchPair("PatchName", patchName);
    parameters.push_back(&patchPair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioDeletePatch,parameters,sessionId);

	FUNCTION_EXIT;

}

unsigned long RadioSessionServant::getEntityKey()
{
	return this->m_entityKey;
}

char * RadioSessionServant::getPatchOwnerITSI()
{
 	FUNCTION_ENTRY("getPatchOwnerITSI");
 
	TA_Base_Bus::GenericAgent::ensureControlMode();
 	std::string potsi;
 
 	try
 	{
 		potsi = m_radioSession->getPatchOwnerITSI();
 	}
 	catch (RadioSessionException& e)
 	{
 		// Error excuting the command
 		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
 	}
 
 	FUNCTION_EXIT;
 	return CORBA::string_dup(potsi.c_str());
 
}

void RadioSessionServant::checkPermission(TA_Base_Bus::AccessControlledAction action, std::string session)
{
	std::vector<TA_Base_Bus::AccessControlledAction> actions;
	actions.push_back(action);
	checkPermission(actions,session);
}

//TD10269 TD10271
// Checks if permission is available on any one of the action specified.
void RadioSessionServant::checkPermission(std::vector<TA_Base_Bus::AccessControlledAction> actions, std::string session)
{

	TA_ASSERT(actions.size()>0,"No actions specified to check");

    TA_Base_Bus::EDecisionModule decisionModule = TA_Base_Bus::UNDEFINED_DM;
    std::string reason;

    TA_Base_Core::IResource* resource = TA_Base_Core::ResourceAccessFactory::getInstance().getResourceFromEntity(m_entityKey);
    unsigned long resourceID = resource->getKey();
    delete resource;

	bool isPermitted = false;
	std::vector<TA_Base_Bus::AccessControlledAction>::const_iterator  it = actions.begin();
	while (it!=actions.end())
	{
        //TD10269 TD10271
		if (m_rightsLibrary->isActionPermittedOnResource(std::string(session), 
			                                              resourceID, 
														  *it, 
														  reason, 
														  decisionModule))
		{
			isPermitted = true;
			break;
		}
	  
		it++;
	};

	if (!isPermitted)
	{
		// Don't have permission so tell client
		TA_Base_Bus::IRadioSessionCorbaDef::accessDeniedException ade(reason.c_str());
        throw(ade);
        //TA_THROW(TA_Base_Bus::IRadioSessionCorbaDef::accessDeniedException(reason.c_str()));
	}
}

void RadioSessionServant::AuditOperation(const TA_Base_Core::MessageType& messageType,
										TA_Base_Core::DescriptionParameters parameters,
										std::string sessionId, long callID)
{
	FUNCTION_ENTRY("AuditOperation1");
	char   text[50] = {0};
	sprintf(text,"%ld",callID);
	TA_Base_Core::NameValuePair  callIDPair("CallId", text);
	parameters.push_back(&callIDPair);

    AuditOperation(messageType, parameters, sessionId);

	FUNCTION_EXIT;
}

void RadioSessionServant::AuditOperation(const TA_Base_Core::MessageType& messageType,
										TA_Base_Core::DescriptionParameters parameters,
										std::string sessionId)
{
	FUNCTION_ENTRY("AuditOperation2");
	//if ((sessionId != m_lastAuditSession)||(m_lastAuditISession==NULL))
	//{
	//	// Get new session data entity
	//	delete m_lastAuditISession;
	//	m_lastAuditISession = NULL;
	//	m_lastAuditISession = TA_Base_Core::SessionAccessFactory::getInstance().getSession(sessionId);
	//	TA_ASSERT(m_lastAuditISession!=NULL,"Session object not found");
	//	m_lastAuditSession = sessionId;
	//}

	// Always add operator name - this should be done by sender in the future
	//TA_Base_Core::NameValuePair operatorNameDescriptionPair("OperatorName", m_lastAuditISession->getOperatorName());
    //parameters.push_back(&operatorNameDescriptionPair);

	m_auditMessageSender->sendAuditMessage(messageType,
										    m_entityKey,
											parameters,
											"",				// No extra details
											sessionId,
											"",				// No associated alarm
											"",				// No associated incident
											"",				// No parent event
											NULL);			// No filterable data
	FUNCTION_EXIT;
}

//*********************************
// IRadioSessionServant interface *
//*********************************

void RadioSessionServant::onSessionInitialisationFailure()
{
	FUNCTION_ENTRY("onSessionInitialisationFailure");

	// Notify user of failure by raising an alarm
	TA_Base_Core::DescriptionParameters descriptionParameters;
	TA_Base_Core::NameValuePair pair1 ( "SessionName", m_entityName);
	descriptionParameters.push_back ( &pair1 );

	TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().submitAlarmWithAsset(TA_Base_Core::RadioAlarms::RadioSessionInitialisationFailureAlarm,
							m_entityKey,
							m_entityTypeKey,
							descriptionParameters,
							m_entityName, 
							m_entityLocation, 
							m_entitySubsystem,
							m_radio.getAgentAssetName(),
							TA_Base_Core::AlarmConstants::defaultTime );
	FUNCTION_EXIT;
}

void RadioSessionServant::onSessionInitialisationComplete()
{
    FUNCTION_ENTRY("onSessionInitialisationComplete");

    if ( ( m_radioSession->isInitialised() ) && (!m_radioSession->isLoggedIn()) )
    {
        // see if any mft sessions are logged in 
        try
        {
            bool sessionLoginFound=false;
            // std::vector<TA_Base_Bus::SessionInfo> active_sessions = m_authenticationLibrary.getActiveSessions(""); // limin-- CL-21211
            std::vector<TA_Base_Bus::SessionInfo> active_sessions; // limin++ CL-21211
            m_authenticationLibrary.getActiveSessionsForOneLocation( "", TA_Base_Bus::KeepSessionAliveThreadManager::getInstance().getAuthCorbaNameObject( m_entityLocation ) ,active_sessions ); // limin++ CL-21211
            for ( std::vector<TA_Base_Bus::SessionInfo>::const_iterator iter = active_sessions.begin() ;
                  (iter != active_sessions.end()) && !sessionLoginFound ;
                  iter++
                )
            {
                const TA_Base_Bus::SessionInfo & sess_info = *iter;
                if ( sess_info.WorkstationId == m_consoleID )
                {
                    // the radio console is logged in !
                    // log in to the radio system on its behalf
                    //
                    // code inline rather than calling sessionLogin(sessionId)
                    // to avoid unnecessarily constructing the AuthAgent named
                    // object
                    for ( unsigned long profileIdx = 0 ;
                          (profileIdx < sess_info.ProfileId.size()) && !sessionLoginFound ;
                          profileIdx++
                        )
                    {
                        TA_Base_Core::IProfile* profile = TA_Base_Core::ProfileAccessFactory::getInstance().getProfile(sess_info.ProfileId[profileIdx]);

                        if ( profile != 0 )
                        {
                            std::string loginName = profile->getItsiGroupName();
                            delete profile;
                            
                            // TODO - modify the SE_PROFILE_V and the associated DAI to retrieve password
                            std::string password;

                            if ( !loginName.empty() )
                            {
                                sessionLogin(loginName, password, sess_info.SessionId);

                                sessionLoginFound=true;
                                break;
                            }
                            else
                            {
                                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn,
                                        "Could not use empty ITSI group name for session %s profile id %lu",
                                        m_entityName.c_str(), sess_info.ProfileId[profileIdx]);
                            }
                        }
                        else
                        {
                            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
                                 "No profile found for session %s, profileId %lu",m_entityName.c_str(), sess_info.ProfileId[profileIdx]);

                        }
                    }
                }
                else
                {
                    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn,
                            "Operator on console %s not logged in with a valid radio profile", m_entityName.c_str() );

                }
            }

            if (!sessionLoginFound)
            {
                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn,
                        "No operator logged in on console %s (id %lu)", m_entityName.c_str(), m_consoleID);
            }
        }
        catch (TA_Base_Core::ObjectResolutionException ore)
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
                 "Session login failed (ObjectResolutionException) for %s",m_entityName.c_str());
        }
        catch (TA_Base_Core::AuthenticationAgentException aae)
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
                 "Session login failed (AuthenticationAgentException) for %s",m_entityName.c_str());
        }
        catch (...)
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
                 "Session login failed (unknown exception) for %s",m_entityName.c_str());
        }
    }

    // Remove any session initialisation alarms
    TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().closeAlarmAtLocation(TA_Base_Core::RadioAlarms::RadioSessionInitialisationFailureAlarm,
                                      m_entityKey,m_entityLocation);

    FUNCTION_EXIT;
}

void RadioSessionServant::onSessionLoginFailure(const std::string loginName)
{
	FUNCTION_ENTRY("onSessionLoginFailure");

	// Notify user of login failure
	TA_Base_Core::DescriptionParameters descriptionParameters;
	TA_Base_Core::NameValuePair pair1 ( "LoginName", loginName);
	descriptionParameters.push_back ( &pair1 );
	TA_Base_Core::NameValuePair pair2 ( "SessionName", m_entityName);
	descriptionParameters.push_back ( &pair2 );

	TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().submitAlarmWithAsset(TA_Base_Core::RadioAlarms::RadioSessionLoginFailureAlarm,
							m_entityKey,
							m_entityTypeKey,
							descriptionParameters,
							m_entityName, 
							m_entityLocation, 
							m_entitySubsystem,
							m_radio.getAgentAssetName(),
							TA_Base_Core::AlarmConstants::defaultTime );
	FUNCTION_EXIT;

}

void RadioSessionServant::onSessionLoginComplete()
{
	// Remove any session initialisation errors
	FUNCTION_ENTRY("onSessionLoginComplete");

	// Remove any session initialisation alarms
	TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().closeAlarmAtLocation(TA_Base_Core::RadioAlarms::RadioSessionLoginFailureAlarm,
		                              m_entityKey,m_entityLocation);

	onSessionUpdate();
	FUNCTION_EXIT;
}

void RadioSessionServant::onAuthorisationChange(const TA_IRS_App::EAction action,const TA_IRS_App::AuthorisationRequestType& details)
{
	FUNCTION_ENTRY("onAuthorisationChange");

	if (m_active)
	{
		TA_Base_Bus::IRadioSessionCorbaDef::CallAuthorisationNotification   event;
		CORBA::Any                                              data;

		switch (action)
		{
			case NEW_AUTHORISATION:         event.action = TA_Base_Bus::IRadioSessionCorbaDef::NEW_AUTHORISATION;
											break;
			case ACCEPTED_AUTHORISATION:    event.action = TA_Base_Bus::IRadioSessionCorbaDef::ACCEPTED_AUTHORISATION;
											break;
			case REJECTED_AUTHORISATION:    event.action = TA_Base_Bus::IRadioSessionCorbaDef::REJECTED_AUTHORISATION;
											break;
			case CANCELLED_AUTHORISATION:   event.action = TA_Base_Bus::IRadioSessionCorbaDef::CANCELLED_AUTHORISATION;
											break;
			default:
				TA_ASSERT(false,"Invalid action type.");
		}
		
		event.request.callID = details.callID;
		event.request.sessionRef = details.sessionRef;

		event.request.sourceType = TA_Base_Bus::IRadioSessionCorbaDef::PORTABLE;
		event.request.destinationType = TA_Base_Bus::IRadioSessionCorbaDef::PORTABLE;

		event.request.callerName      = CORBA::string_dup(details.callerName.c_str());
		event.request.calledName      = CORBA::string_dup(details.calledName.c_str());
		event.request.callerTSI      = CORBA::string_dup(details.callerTSI.c_str());
		event.request.calledTSI      = CORBA::string_dup(details.calledTSI.c_str());
		event.request.callerLocation  = CORBA::string_dup(details.callerLocation.c_str());
		event.request.calledLocation  = CORBA::string_dup(details.calledLocation.c_str());

		event.request.time			 = details.time; 
		data <<= event;
	    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
		     "m_commsMessageSender->sendCommsMessage(RadioAuthorisationNotification,m_entityKey=%d,m_entityLocation=%d)",m_entityKey,m_entityLocation);

		m_commsMessageSender->sendCommsMessage(TA_Base_Core::RadioComms::RadioAuthorisationNotification,
											 m_entityKey,
											 data,
											 0,                 // subsystem
											 m_entityLocation,  // region
											 NULL);             // filter

		// TD13048++ 
		// send audit event
		if (action == NEW_AUTHORISATION)
		{
			TA_Base_Core::DescriptionParameters parameters;
			std::ostringstream callStr;
			callStr << details.callID;
			TA_Base_Core::NameValuePair  callIDPair("CallId", callStr.str());
			parameters.push_back(&callIDPair);

			if (m_radioSession->getIsISCSSession())
			{
				m_auditMessageSender->sendAuditMessage(TA_Base_Core::RadioAudit::RadioAuthoriseCall,
					m_entityKey,
					parameters,
					"",				// No extra details
					"",
					"",				// No associated alarm
					"",				// No associated incident
					"",				// No parent event
					NULL);	
			} 
			else
			{
					m_auditMessageSender->sendAuditMessage(TA_Base_Core::RadioAudit::RadioAuthoriseCall,
					m_entityKey,
					parameters,
					"",				// No extra details
					m_transactiveSession,
					"",				// No associated alarm
					"",				// No associated incident
					"",				// No parent event
					NULL);	
			}
		}
		// TD13048++
	}

	FUNCTION_EXIT;
}

//****************************
// IEntity Interface Methods *
//****************************


bool RadioSessionServant::isValid()
{
    FUNCTION_ENTRY("isValid");
    FUNCTION_EXIT;
    return true;
}


void RadioSessionServant::start()
{
    FUNCTION_ENTRY("start");
    //this->activateServant();
    // std::cout << "Registering radio session:" << m_entityName << std::endl;
    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
                 "Activating radio session corba servant: %s", m_entityName.c_str() );
    activateServantWithName(m_entityName);
    FUNCTION_EXIT;
}


void RadioSessionServant::stop()
{
    FUNCTION_ENTRY("stop");
    m_radioSession->stop();
    MessageSubscriptionManager::getInstance().unsubscribeToMessages(this);
    if ( NULL != m_eventSubscriber )
    {
    m_eventSubscriber->stopSubscription();
    }
    deactivateServant();
    FUNCTION_EXIT;
}


void RadioSessionServant::update(const TA_Base_Core::ConfigUpdateDetails& details)
{
    FUNCTION_ENTRY("update");
    FUNCTION_EXIT;
}

void RadioSessionServant::remove()
{
}

void RadioSessionServant::setToControlMode()
{
    FUNCTION_ENTRY("setToControlMode");

    // Subscribe to comms messages
	std::string loc = (RunParams::getInstance().get(RPARAM_LOCATIONKEY));
    MessageSubscriptionManager::getInstance().subscribeToCommsMessage( 
            TA_Base_Core::ControlStationComms::GXToTAMessageNotification, 
            this, 
            0, 
            0, 
            atol(loc.c_str()), 
            NULL );

    if ( NULL != m_eventSubscriber )
    {
		m_eventSubscriber->startSubscription();
    }
    m_active = true;

    FUNCTION_EXIT;
}


void RadioSessionServant::setToMonitorMode()
{
    FUNCTION_ENTRY("setToMonitorMode");
    
    MessageSubscriptionManager::getInstance().unsubscribeToMessages(this);

    if ( NULL != m_eventSubscriber )
    {
		m_eventSubscriber->stopSubscription();
    }
    m_active = false;

    FUNCTION_EXIT;
}

void RadioSessionServant::onTerminate(bool peerAvailable)
{
    m_radio.onTerminate(peerAvailable);
}

void RadioSessionServant::updateRadioSession(const RadioSessionType& radioSessionData)
{
	this->m_radioSession->updateRadioSession(radioSessionData);
}


void RadioSessionServant::clearFullState()
{
	this->m_radioSession->clearFullState();
}

void RadioSessionServant::applyFullState(const RadioSessionServantType& state)
{
	this->m_radioSession->applyFullState(state.radioSession);
}

void RadioSessionServant::getFullState(RadioSessionServantType& state)
{
	state.entityKey = m_entityKey; // TD9016
	this->m_radioSession->getFullState(state.radioSession);
}

void RadioSessionServant::onSessionUpdate()
{
    // send the comms message
    TA_Base_Bus::IRadioCorbaDef::SessionUpdateNotification notification;
    notification.consoleKey = m_consoleID;
    notification.sessionRef = m_radioSession->getValidSessionRef();
	notification.inFallback = m_radioSession->getSwitchNotReachable();
    notification.reason = TA_Base_Bus::IRadioCorbaDef::SessionLoggedIn;

    CORBA::Any data;
    data <<= notification;

	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Send RadioSessionUpdateNofification (ObjectResolutionException) for %s",m_entityName.c_str());
	m_commsMessageSender->sendCommsMessage(TA_Base_Core::RadioComms::RadioSessionUpdateNofification,
										 m_entityKey,
										 data,
										 0,
										 m_entityLocation,
										 NULL);

}


TA_Base_Bus::IRadioSessionCorbaDef::CallAuthorisationList* RadioSessionServant::getCallAuthorisations()
{
	FUNCTION_ENTRY("getCallAuthorisations");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	// Get a list of calls
	TA_IRS_App::AuthorisationStack  authStack;
	m_radioSession->getAuthorisationList(authStack);

	// Get size of call stack
	CORBA::ULong iAuthCount  = authStack.size();
	CORBA::ULong iAuthNumber = 0;

	// CORBA will delete this object
    TA_Base_Bus::IRadioSessionCorbaDef::CallAuthorisationList* corbaAuthList = new TA_Base_Bus::IRadioSessionCorbaDef::CallAuthorisationList() ;
    corbaAuthList->length(iAuthCount);
 
	TA_IRS_App::AuthorisationStack::iterator it;
	for (it=authStack.begin();it!=authStack.end();it++)
	{
		(*corbaAuthList)[iAuthNumber].callID          = it->callID;
		(*corbaAuthList)[iAuthNumber].sessionRef      = it->sessionRef;
        RadioCorbaTypeConverter::convertERadioUserTypeNormalToCorba(it->sourceType, (*corbaAuthList)[iAuthNumber].sourceType);
        RadioCorbaTypeConverter::convertERadioUserTypeNormalToCorba(it->destinationType, (*corbaAuthList)[iAuthNumber].destinationType);
		(*corbaAuthList)[iAuthNumber].callerName      = CORBA::string_dup(it->callerName.c_str()); //TD19749++
		(*corbaAuthList)[iAuthNumber].calledName	  = CORBA::string_dup(it->calledName.c_str());
		(*corbaAuthList)[iAuthNumber].callerTSI		  = CORBA::string_dup(it->callerTSI.c_str());
		(*corbaAuthList)[iAuthNumber].callerLocation  = CORBA::string_dup(it->callerLocation.c_str());
		(*corbaAuthList)[iAuthNumber].calledTSI       = CORBA::string_dup(it->calledTSI.c_str());
		(*corbaAuthList)[iAuthNumber].calledLocation  = CORBA::string_dup(it->calledLocation.c_str());
		(*corbaAuthList)[iAuthNumber].time			  = it->time;  //++ TD19749
		iAuthNumber++;
	}

	FUNCTION_EXIT;			
    return corbaAuthList;
}

void RadioSessionServant::authoriseCall(long callID,bool accept,const char* sessionID)
{
    FUNCTION_ENTRY("authoriseCall");
    m_radioSession->authoriseCall(callID,accept,sessionID);
    FUNCTION_EXIT;            
}

std::string RadioSessionServant::getCallTypeString(TA_IRS_App::ECallType callType)
{
	
	FUNCTION_ENTRY("getCallTypeString");
	
	switch (callType)
	{
		case SingleCall:
			 return "Single";
			 break;
		case GroupUnacknowledgeCall: 
			 return "Unacknowledge";
			 break;
		case GroupAcknowledgeCall: 
			 return "Acknowledge";
			 break;
		case GroupBroadcastCall: 
			 return "Broadcast";
			 break;
		default:
			{				
				LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
					 "CallType %d  not found ",callType);		 
				return "[Unknown]";
			}
	
	};
}


long RadioSessionServant::includeSubscriber(long callId,const char * subscriber,const char * sessionId)
{
	FUNCTION_ENTRY("includeSubscriber");

	TA_Base_Bus::GenericAgent::ensureControlMode();
	checkPermission(TA_Base_Bus::aca_RADIO_INCLUDE_CALL,sessionId);

	std::cout << "Including subscriber " << subscriber << " in call:" << callId << std::endl;
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Including subscriber %s in call %ld",subscriber,callId);

    long new_callId = 0;

	try
	{
		m_radioSession->includeSubscriber(callId,subscriber);
	}
	catch (RadioSessionException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioAPIException(e.what());  
	}
    catch (RadioFallbackException rfe)
    {
        // morph into Corba radioFallbackException
		throw TA_Base_Bus::IRadioSessionCorbaDef::radioFallbackException();  
    }

	// Now audit the event
	TA_Base_Core::DescriptionParameters parameters;
	TA_Base_Core::NameValuePair destPair("CallDestination", subscriber);
    parameters.push_back(&destPair);
	AuditOperation(TA_Base_Core::RadioAudit::RadioIncludeCall,parameters,sessionId,callId);

	FUNCTION_EXIT;
    return new_callId;
}
