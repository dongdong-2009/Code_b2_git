/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioSession.h $
  * @author:  Ripple
  * @version: $Revision: #4 $
  *
  * Last modification: $DateTime: 2009/09/23 13:09:47 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioSession.h
//  Implementation of the Class RadioSession
//  Generated by Enterprise Architect
//  Created on:      30-Oct-2003 08:20:31
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(RadioSession_B832D217_3758_4203_AB7C_56A473240AAF__INCLUDED_)
#define RadioSession_B832D217_3758_4203_AB7C_56A473240AAF__INCLUDED_

#include <string>
#include <vector>

#include "core/synchronisation/src/Condition.h"
#include "bus/radio/RadioAgentCorbaDef_4669/idl/src/IRadioSessionCorbaDef.h"
#include "app/radio/RadioTetraAgent/src/RadioCircuitModeManager.h"
#include "app/radio/RadioTetraAgent/src/RadioTypes.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"
#include "app/radio/RadioTetraAgent/src/RadioFallbackException.h"
/**
* This class manages a single radio session.
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 30-Oct-2003 08:20:31
*/
namespace TA_Base_Core
{
    class RadioGlobalEntityData;
}
// namespace TA_Base_Bus
// {
//     class ItaScada;
// }

namespace TA_IRS_App
{
	class Radio;
	struct CallForwardingDetails;
	class RadioEvent;
	class RadioMethod;
    class RadioTcpServer;
    struct RadioSessionType;
	class IRadioSessionServant;
	class RadioMethodNewReference;
	class RadioSessionInitialisationThread;
	

	class RadioSession
	{

	public:
		//RadioSession(std::string entityName,IRadioSessionServant& radioSessionServant,Radio& radio,unsigned int audioLink,std::string autoLoginName); TD14696
        RadioSession(   std::string entityName,
                        IRadioSessionServant & radioSessionServant,
                        RadioTcpServer & radio,
                        unsigned int audioLink,
                        std::string autoLoginName,
                        TA_IRS_App::ConsoleID consoleID,
						unsigned long switchUserWaitPeriod,
                        TA_Base_Core::RadioGlobalEntityData& globalEntityData,
                        //TA_Base_Bus::ItaScada& itaScada,
						bool isISCS
                       );

		virtual ~RadioSession();

		/// enumeration representing the various states that a Session will
        /// transition through
		enum SessionState
        {
            SessionUnassigned,
			SessionAssigned,
			SessionInitialised,
			SessionLoggedIn
        };

	public:

        /* Starts and stops the radio session */
        void start();
        void stop();
        /**
         * Returns the identifier for this session
         */
        std::string getSessionEntityName();

        /**
         * Returns the key for this session
         */
        unsigned long getSessionEntityKey();

		/**
		* This will call the AttachSession and Initialise functions to setup the
        * session with the radio
		*/
		void initialiseSession();

        /**
         * Log in the user of the session
         * Sets the login name and triggers login
         * (done in a different thread)
         * 
         * @param loginName the new session login name
         * @param password optional. If blank one will be created.
         */
		void loginSession(const std::string& loginName, const std::string& password);

		/**
		* Logout the user
		*/
		void doLogoutSession();
		void logoutSession();
		SessionReference getValidSessionRef();
		void doDetachSession();
		void detachSession();

		void overwriteSessionStatus( SessionState state);

        bool isAttached() const;
        bool isInitialised() const;
        bool isLoggedIn() const;

		void answerCall(CallID callId, std::string sessionId);
		//TD 10234
        long makeCall(const std::string & destTSI, ECallType callType, bool isFullDuplex, ECallPriority priority, bool hook, std::string sessionId, bool isInvisibleToGUIApps,long locationKey); // TD14696
		void releaseCall(CallID callId, std::string sessionId);
		void sendTextMessage(const std::string &destTSI, std::string message, std::string sessionId);
		void sendTextDataMessage(const std::string &destTSI, std::vector<unsigned char> message);
		/**
		* Send the method to the radio and get the reply event.  This method simply calls the parent (m_radioTcpServer) sendMethod.
		* @param    method
		*/
		RadioEvent* sendMethod(RadioMethod& method);
		void holdCall(CallID callId, std::string sessionId);
		void resumeCall(CallID callId, std::string sessionId);
		void demandTX(short priority,std::string sessionId,unsigned long& queueID);
		void ceaseTX(std::string sessionId);
		void selectCall(CallID callId, std::string sessionId);
		void deselectCall(CallID callId, std::string sessionId);
		void adjustCallVolume(CallID callId, bool increaseVol, std::string sessionId);

		std::string makeDynamicGroup(std::vector<std::string> destTSIs, std::string sessionId);

		void createPatch(std::vector<std::string> list,std::string patchName,std::string sessionId);
		void deletePatch(std::string patchName,std::string sessionId);
		void setCallForwarding(const CallForwardingDetails& details, std::string sessionId);
		void getCallForwarding(CallForwardingDetails& details);
 		std::string getPatchOwnerITSI();


        /**
         * Sets up a circuit mode data call
         */
        NewReferenceEventReader::RadioReference setupDataCall(const std::string& destinationTsi);

        /**
         * Sends a packet in a circuit mode transfer
         */
        void sendCircuitDataFrame( NewReferenceEventReader::RadioReference callReference,
                                   const RadioCircuitTransfer::Data& frame );

        /**
         * Ends a circuit mode transfer call
         */
        void endDataCall( NewReferenceEventReader::RadioReference callReference );

        /**
         * Deletes a reference to an already ended call (ie disconnected)
         */
        void clearDataCallReference( NewReferenceEventReader::RadioReference callReference );

        // //////////////////////////////////////
        // Monitoring Functionality
        // //////////////////////////////////////

        /**
         **/
        void startMonitoring(const char * tsi);

        /**
         **/
        void stopMonitoring(const char * tsi);

        /**
         **/
        void oneShotMonitoring(const char * tsi);

        /**
         **/
        CallID startListening(CallID callId);

        /**
         **/
        void stopListening(CallID callId);

        /**
         **/
		CallID joinCall(CallID callId);

        /**
         **/
        CallID includeSubscriber(CallID callId, const std::string & tsi);

        /**
         **/
		void terminateCall(CallID callId);

		void getAuthorisationList(AuthorisationStack& authorisationList);
		void authoriseCall(unsigned long callID, bool accept, const char* sessionID);

        // //////////////////////////////////////
		/// Called by the background thread to perform the initialisation.
		bool doAttachSession(std::pair<SessionReference,SessionReference>&);
		bool doInitialiseSession();
		void doLoginSession(SessionReference previousSessionRef);

        /**
         * releaseSDSReference
         *
         * Performs a DeleteReference specifically for SDS references.
         *
         * @param sdsReference The reference to delete
         *
         * @exception 
         */
        void releaseSDSReference(const unsigned long sdsReference);


		/**
		* Called by the Radio object when we the connection to the TCPServer
        * is restored.
        *
        * @param 
		*/
        void onConnectionEstablish();

		void onConnectionLost();
		
		void onSwitchConnection();

        /**
         * Checks if the radio session should be logged in/should attempt to log in
         *
         * @return true if the connection is active, and the radio is also active
         */
        bool shouldLogIn();
		
		/**
         * Farnarcles around searching subscribers and querying to determine
         * the name of the subscriber with the given TSI.
         */
        std::string getSubscriberName(const std::string & tsi);


        /**
         * Accessor for the ITSI of this session. First usage for current
         * login performs QueryReference.
         * 
         * @return the TSI of this session
         */
		std::string getSessionTSI();

		void updateRadioSession(const RadioSessionType& radioSessionData);
		virtual void clearFullState();
		virtual void applyFullState(const RadioSessionType& state);
		virtual void getFullState(RadioSessionType& state);

        void setSwitchNotReachable(bool isNotReachable);
        bool getSwitchNotReachable() const;
        void setGwldLinkLost(bool isLinkLost);
        bool isGwldLinkLost() const;
        RadioTcpServer & getTcpServer();
		bool getIsISCSSession();

		unsigned long getRefID();
		
		std::string getSessionDGNAITSI();

		/**
		 * This function will return a search result reference for a specified search
		 *
		 * Remember to free the new search reference when you have finished with it!
		 */
        unsigned long performSubscriberSearch(std::string searchCriteria,
            RadioMethodSearchSubscribers::EView view = RadioMethodSearchSubscribers::NORMAL);        
        
        std::vector<std::string> queryResultsAsList(unsigned long resultRef, RadioMethodQueryReference::EKeys key);
		/**
		 * Query the details from a reference.
		 */
		std::string queryResults(unsigned long resultRef, RadioMethodQueryReference::EKeys key);

        /**
		 * Get a new reference for use with the radio commands
		 */
		RadioReference getNewReference(RadioMethodNewReference::ReferenceType referenceType);

        /**
         * deleteReference
         *
         * Deletes the reference passed to it. Cannot be used by subscriber references.
         *
         * @param reference The reference to delete
         * @param refType   The type of the reference
         */
        void deleteReference(RadioReference reference, RadioMethodDeleteReference::ReferenceType refType);

		/**
		 * This function will return a subscriber reference which can be used for direct
		 * manipulation of the associated record.
		 *
		 * Remember to free the new subscriber reference when you have finished with it!
		 */
		unsigned long convertTextToSubscriberReference(std::string textReference);

		void onSessionStatusChange( GxUpdateType state );

        void onAuthorisationChange(const TA_IRS_App::EAction action,const TA_IRS_App::AuthorisationRequestType& details);
		
		ConsoleID getConsoleID() { return m_consoleID;}
		
	private:
		/**
		* Parent radio - used to send out the radio messages
		*/
		RadioTcpServer & m_radioTcpServer;


		/**
		* Hardware audio link (0=none, 1..n link associated with session
		*/
		unsigned int m_audioLink;
		

		/**
		* Thread used for background initialisation
		*/
		RadioSessionInitialisationThread* m_radioSessionInitialisationThread;

		/**
		 * Radio API session reference for this session
		 */
		SessionReference m_sessionRef;			
		
		/**
		 * Entity name for radio session.
		 */
		std::string   m_sessionEntityName;

		
		/**
		* Reference to parent class interface, used to raise alarms.
		*/
		IRadioSessionServant& m_radioSessionServant;

		/**
		 * Name to be used for auto login -ISCS session
         * RvH  TD9386 PISF/TST/350 WP630027
         *      Also used for re-login.
		 */
		std::string m_loginName;
        std::string m_loginPassword;

		/**
		  * Needed for TD19666, while switch user, logout of the last user may 
		  * be performed after the new user tried to login.
		  **/
		unsigned long m_switchUserWaitPeriod;


		/**
		 * Subscriber text reference (for this session) persisted by getForwarding
		 * and used by setForwarding
		 */
        std::string m_subscriberTextRef;


		/*
		 * DGNA management
		 */
		std::string			m_sessionDGNAITSI;
		bool				m_sessionDGNAInUse;

        /*
         *TD 10234, is invisible to user.
         */
        bool m_isInvisibleToGUIApps;

		SessionState        m_sessionStatus;

        std::string         m_sessionITSI;

        bool                m_switchNotReachable;

        ///
        /// used by the RadioTcpServer class for managing GWLD_LINK_LOST errors
        bool                m_gwldLinkLost;

        ///Entity key of the Console this session
        ConsoleID           m_consoleID;

		bool				m_isISCS;

        void queryAllCallDetails(unsigned long callRef, QueryKeyValueMap & callValues);


        
        /**
         * Attaches to all groups that this session subscriber is in the group of.
         * Generally run during loginSession()
         * @return the number of successfully attached groups
         */
        int attachToGroups();

       
        /**
         * Requests the RCS to remove all the current members of the DGNA to
         * be removed.
         */
       
		void deassignDynamicGroup();

        /**
         * Resets data members and attempts initialiseSession. Does NOT perform
         * detach/logout first. This is for when a connection is reestablished.
         */
        void relogin();
		void reset();

        /**
         * Cute utility function to throw a RadioFallbackException
         * if m_radio.inFallback() returns true
         */
        void checkRadioFallback();

		void getRadioSessionData(RadioSessionType& radioSessionData);

		void sendStateUpdate();
        // Stores the global default emergency call priority
        TA_IRS_App::ECallPriority m_DefaultEmergencyCallPriority;

        // Stores the global default normal call priority
        TA_IRS_App::ECallPriority m_DefaultNormalCallPriority;
        // local flag for connection state
        volatile bool m_connectionEstablished;
        CallForwardingDetails* m_callForwardingDetails;

		TA_Base_Core::Condition m_condition;

		GxUpdateType m_currentGXType;

		time_t m_lastUpdateTime;
	};

    inline RadioTcpServer & RadioSession::getTcpServer()
    {
        return m_radioTcpServer;
    }

	inline bool RadioSession::getIsISCSSession()
	{
		return m_isISCS;
	}

	inline unsigned long RadioSession::getRefID()
	{
		return m_sessionRef;
	}
}

#endif // !defined(RadioSession_B832D217_3758_4203_AB7C_56A473240AAF__INCLUDED_)
