/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioResourceManager.h $
  * @author:  Andy Parker
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  * This class is used to manage radio resources.
  * We need to know what audio channels are available to use for calls and
  * which need releasing when voice calls complete.  The Radio class
  * and radio session will need to use this manager.
  *
  * Also SDS resources must be released.
  *
  * We need this to be a thread as we cannot use the incoming radio event (TCP thread)
  * to send synchronous messages to the train as it will block stopping further TCP
  * receipt, i.e. it will never get its reply!
  */

///////////////////////////////////////////////////////////
//
//  RadioConnectionManager.h
//  Implementation of the Class RadioConnectionManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(RadioResourceManager_INCLUDED_)
#define RadioResourceManager_INCLUDED_
#include <map>
#include <vector>

#include "core/synchronisation/src/Semaphore.h"
#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/threads/src/Thread.h"

#include "RadioSynchronisationTypes.h"
#include "core/data_access_interface/entity_access/src/IEntityData.h"

#ifdef __WIN32__
#pragma warning(push)
#pragma warning(disable: 4786)
#endif // #ifdef __WIN32__

/**
* This class will be used to manage the audio references
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:43:57
*/

namespace TA_IRS_App
{
	class RadioTcpServer;


	class RadioResourceManager : TA_Base_Core::Thread
	{
		typedef  unsigned long    CallReference; 
		typedef  unsigned long    SDSReference;

		public:

			/*
			* Constructor
			*
			* This function adds an audio reference to the list of managed audio connections.
			* @param   radio   Need to access the sendCommand method by the run method.
			*/
			RadioResourceManager(RadioTcpServer& radio);
			virtual ~RadioResourceManager();

		public:
			/**
			* This function adds the audio references associated with a session.
			* @param   SessionRef    indicates the owner session
			*/
			void addAudioReferences(SessionReference SessionRef);

			/**
			* This function removes all audio references for a session.
			* @param   SessionRef    indicates the owner session
			*/
			void deleteAudioReferences(SessionReference SessionRef);


			/**
			* This function wuill attach audio to the passed call.
			* @param   SessionRef    indicates the owner session
			* @param   CallRef       call reference to be assoicated with the audio reference
			*/
			void attachAudio(SessionReference SessionRef, CallReference CallRef);

			/**
			* This function releases the use of the audio reference.
			* It will not do it directly but place it onto a separate thread to be processed
			* 
			* @param   SessionRef   indicates the owner session
			* @param   CallRef      call reference to be assoicated with the audio reference
            * @param   direct       if this is to be done off the calling thread,
            *                       ie. if called due to an unsolicited event
            * @param   isMonitored  if DetachMonitorAudio should be used. Use
            *                       RadioMonitorManager::isListening to determine.
			*/
			void releaseAudioReference(SessionReference SessionRef, CallReference callRef,bool direct, bool isMonitored=false);


			/**
			* This function directs the audio to the specified speaker.
			* Generally, selected calls are heard on the right speaker, whilst deselected calls are 
			* heard on the left speaker.
			* 
			* @param   SessionRef    indicates the owner session
			* @param   CallRef       call reference to be assoicated with the audio reference
			* @param   rightSpeaker  indicates if right speaker should be used for call (false=left speaker)
			* @param   volumeDelta   the value by which to change the volume, if
            *                        required. The default of zero indicates no change in volume,
            *                        however it usually indicates that the call is changing speaker.
			*/
			void setAudioSpeaker(SessionReference SessionRef,CallReference callId,bool rightSpeaker, int volumeDelta=0);

			/**
			* This function adjusts the audio volume.  The new volume level will be used for subsequent calls.
			* 
			* @param   SessionRef    indicates the owner session
			* @param   CallRef       call reference to be assoicated with the audio reference
			* @param   increaseVolume  indicates if volume should increase (true) or decrease (false)
			*/
			void adjustAudioVolume(SessionReference sessionRef,CallReference callRef,bool increaseVolume);

			/**
			* This function releases the reference associated with a sds message.
			* It will not do it directly but place it onto a separate thread to be processed
			* 
			* @param   SessionRef    indicates the owner session
			* @param   CallRef       call reference to be assoicated with the audio reference
			*/
			void releaseSDSReference(SessionReference SessionRef, SDSReference sdsRef);

            /**
            * Attaches audio to the monitored call. Similar to attachAudio, but
            * first queries the radio system for the full/half duplex status to
            * determine whether to request one or two audio channels.
            *
            * @param    sessionRef  indicates the owner session
            * @param    callRef     call reference to be assoicated with the
            *                       audio reference
            * @param    full        if the call is full duplex
            */
            void attachMonitorAudio(SessionReference sessionRef, CallReference callRef, bool full);

            /**
            * This function detaches the monitored audio from the call. Differs
            * from detachAudio:
            * - sends the RadioMethodDetachMonitorAudio
            * - is always direct, since the unsolicited DisconnectEvent
            *   will handle both normal and monitored audio disconnection.
            *
            * @param   SessionRef    indicates the owner session
            * @param   CallRef       call reference to be assoicated with the audio reference
            * @param   direct        if this is being performed directly, and needs to
            *                        send the DetachMonitorAudio method, or is in response
            *                        to an unsolicited event and only needs the audio releasing
            */
            void detachMonitorAudio(SessionReference SessionRef, CallReference CallRef, bool direct=true);


			/**
             * Releases all audio resources for the given call reference in the
             * specified session. Used by detachAudio and detachMonitorAudio
             *
             * @param   sessRef the Radio Session Reference
             * @param   callRef the Radio Call Reference
             * @return  the number of audio resources freed
             */
            int releaseAudioResources(SessionReference sessRef, CallReference callRef);

			 // state synchronisation functions
			void applyFullState(const RadioResourceManagerType& state);
			void clearFullState();
			void getFullState(RadioResourceManagerType& state,
							  const std::map<SessionReference,ConsoleID>& sessions);
			void updateAudioEntryInSessionMap(SessionID sessionReference, 
											  AudioReference audioReference,
											  const TA_IRS_App::AudioEntryType& audioEntry);
			void updateCallVolume(SessionID sessionReference, 
												TA_IRS_App::CallReference callReference,
												int currentVolume);
			void removeSessionFromAudioMap(SessionID sessionReference);

		private:

			/*
			 * Method performing the background work
			 */
			void run();
			
			/*
			 * Stop backgroung processing
			 */
			void terminate();

			/*
			 * Make the audio refernece not used.
			 */
			void detachAudio(SessionReference sessionRef, CallReference callRef,bool direct);

			/*
			 * Release the SDS resource from the radio
			 */
			void deleteSDS(SessionReference sessionRef, SDSReference sdsRef);

			/**
			* This function adds an audio reference to the list of managed audio connections.
			* @param   SessionRef    indicates the owner session
			* @param   AudioRef      audio reference
			*/
			void addAudioReference(SessionReference SessionRef, AudioReference AudioRef);

			//*******************
			// Audio Management *
			//*******************

			TA_Base_Core::ReEntrantThreadLockable   m_audioMapLock;


			struct AudioEntry
			{
				CallReference callRef;
				bool           inUse;
                int            volume;
			};

			
			typedef std::map<AudioReference, AudioEntry >        AudioEntryMap;
			typedef std::map<SessionReference, AudioEntryMap* >  SessionAudioMap;

			SessionAudioMap			m_sessionAudioMap;


			int     m_currentAudioVolume;
			//TD10963 marc_bugfix the default volume 
			unsigned long     m_DefaultVolume;		


			//********************
			// Thread work queue *
			//********************

			TA_Base_Core::ReEntrantThreadLockable    m_workQueueLock;
			TA_Base_Core::Semaphore					m_workQueueSemaphore;

			enum EWorkRequestType { DELETE_SDS, DETACH_AUDIO, DETACH_MONITOR_AUDIO };
			struct WorkRequestEntry
			{
				EWorkRequestType   request;
				SessionReference   sessionRef;
				CallReference      callRef;
				SDSReference       sdsRef;
			};

			std::vector<WorkRequestEntry>   m_workQueue;
			bool                            m_terminate;

			//*************************
			// Access to parent class *
			//*************************
			RadioTcpServer&					m_radio;
			//*************************
			// Contol/Monitor Synchronisation Support
			//*************************
			void sendRemoveSessionFromAudioMap(SessionReference sessionRef);

			void sendUpdateAudioVolume(SessionReference sessionReference,
									   CallReference callReference, int currentVolume );
			void sendUpdateAudioEntry(SessionReference sessionReference, 
									  AudioReference audioReference, const AudioEntry& audioEntry);
	};
}

#ifdef __WIN32__
#pragma warning(pop)
#endif // #ifdef __WIN32__

#endif // !defined(RadioResourceManager_INCLUDED_)
