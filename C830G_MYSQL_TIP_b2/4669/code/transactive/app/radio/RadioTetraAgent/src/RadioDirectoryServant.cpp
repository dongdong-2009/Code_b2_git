/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioDirectoryServant.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioDirectoryServant.cpp
//  Implementation of the Class RadioDirectoryServant
//  Generated by Enterprise Architect
//  Created on:      30-Oct-2003 08:19:59
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#include "stdio.h"

#include "core/configuration_updates/src/ConfigUpdateDetails.h"
#include "core/data_access_interface/radio/src/IRASubscribers.h"
#include "core/data_access_interface/entity_access/src/EntityAccessFactory.h"
#include "core/naming/src/Naming.h"
#include "core/message/src/CommsMessageSender.h"
#include "core/message/types/RadioComms_MessageTypes.h"
#include "core/message/src/MessagePublicationManager.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/utilities/src/RunParams.h"

#include "bus/radio/RadioAgentCorbaDef_4669/idl/src/IRadioCorbaDef.h"

#include "app/radio/RadioTetraAgent/src/RadioDirectoryServant.h"
#include "app/radio/RadioTetraAgent/src/RadioDirectory.h"
#include "app/radio/RadioTetraAgent/src/RadioDirectorySynchronisation.h"

#include "app/radio/RadioTetraAgent/src/RadioSession.h"
#include "app/radio/RadioTetraAgent/src/Radio.h"
#include "app/radio/RadioTetraAgent/src/CallForwardingDetails.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionNotInitialisedException.h"

#include "bus/generic_agent/src/GenericAgent.h"
#include "core/exceptions/IDL/src/CommonExceptionsCorbaDef.h"

using namespace TA_IRS_App;

static char * UNKNOWN_EXCEPTION = "Unknown exception";

RadioDirectoryServant::RadioDirectoryServant(TA_IRS_App::Radio& radio, TA_Base_Core::RadioDirectoryEntityDataPtr entityData) 
:                     m_radioDirectory(0),
					  m_radioDirectorySynchronisation(0),
					  m_entityKey(0),
                      m_locationKey(0)
{
	FUNCTION_ENTRY("Constructor");
	m_directoryName  = entityData->getName();
	m_entityKey      = entityData->getKey();
    m_locationKey    = entityData->getLocation();

    m_radioDirectory = new RadioDirectory(radio);
	TA_ASSERT(m_radioDirectory!=NULL,"Radio directory could not be created.");

    m_radioDirectorySynchronisation = new RadioDirectorySynchronisation(entityData->getSynchronisationFrequency(),radio,entityData,*this);
	TA_ASSERT(m_radioDirectorySynchronisation!=NULL,"Radio directory synchronisation could not be created.");

	FUNCTION_EXIT;
}


RadioDirectoryServant::~RadioDirectoryServant()
{
	stop();
	delete m_radioDirectory;
	delete m_radioDirectorySynchronisation;
}



long RadioDirectoryServant::getLastDirectorySynchronisationTime()
{
	TA_Base_Bus::GenericAgent::ensureControlMode();
    long last_synch_time = 0;

	try
	{
        last_synch_time = m_radioDirectorySynchronisation->getLastSynchroniseTime();
	}
	catch (TA_Base_Core::TransactiveException& e)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioCorbaDef::radioDirectoryError(e.what());  
	}
	catch (...)
	{
		// Error excuting the command
		throw TA_Base_Bus::IRadioCorbaDef::radioDirectoryError(UNKNOWN_EXCEPTION);  
	}

    return last_synch_time;
}


//****************************
// IEntity Interface Methods *
//****************************


bool RadioDirectoryServant::isValid()
{
	FUNCTION_ENTRY("isValid");
	FUNCTION_EXIT;
	return true;
}


void RadioDirectoryServant::start()
{
	FUNCTION_ENTRY("start");
	this->activateServant();
    LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, "Registering radio session: %s",m_directoryName.c_str());
	activateServantWithName(m_directoryName);
	FUNCTION_EXIT;
}


void RadioDirectoryServant::stop()
{
	FUNCTION_ENTRY("stop");
	deactivateServant();
    m_radioDirectorySynchronisation->terminateAndWait();
	FUNCTION_EXIT;
}


void RadioDirectoryServant::update(const TA_Base_Core::ConfigUpdateDetails& details)
{
	FUNCTION_ENTRY("update");
    TA_Base_Core::RadioDirectoryEntityData* entityData = 
        dynamic_cast<TA_Base_Core::RadioDirectoryEntityData*>(
        TA_Base_Core::EntityAccessFactory::getInstance().getEntity(details.getKey()));

    if (entityData == NULL)
    {
        // The entity key is wrong, which is bad
    }
    else
    {
        entityData->getSynchronisationFrequency();
    }
	FUNCTION_EXIT;
}

void RadioDirectoryServant::remove()
{
    FUNCTION_ENTRY("remove");
    FUNCTION_EXIT;
}

void RadioDirectoryServant::setToControlMode()
{
	FUNCTION_ENTRY("setToControlMode");
    m_radioDirectorySynchronisation->start();
	FUNCTION_EXIT;
}


void RadioDirectoryServant::setToMonitorMode()
{
	FUNCTION_ENTRY("setToMonitorMode");
    m_radioDirectorySynchronisation->terminateAndWait();
	FUNCTION_EXIT;

}
		
//********************************************
// IRadioDirectoryCallback Interface Methods *
//********************************************
void RadioDirectoryServant::onSubscriberChange(TA_Base_Core::IRASubscribers * subscriber, SubscriberChangeType changeType)
{
	FUNCTION_ENTRY("onSubscriberChange()");
    std::cout << "Sending subscriber change notification" << std::endl;

    TA_Base_Bus::IRadioCorbaDef::SubscriberDetailsNotification event;
    CORBA::Any data;

    switch (changeType)
    {
        case NEW_SUBSCRIBER:
            event.notifyType = TA_Base_Bus::IRadioCorbaDef::NEW_SUBSCRIBER;
            break;
        case UPDATE_SUBSCRIBER:
            event.notifyType = TA_Base_Bus::IRadioCorbaDef::UPDATE_SUBSCRIBER;
            break;
        case DELETE_SUBSCRIBER:
            event.notifyType = TA_Base_Bus::IRadioCorbaDef::DELETE_SUBSCRIBER;
            break;
        case SCAN_SUBSCRIBERS:
            event.notifyType = TA_Base_Bus::IRadioCorbaDef::SCAN_SUBSCRIBERS;
            break;
        default:
            // omigosh can't handle this
            return;
            break;
    }

    if (subscriber != 0)
    {
        event.details.TSI               = CORBA::string_dup((subscriber->getTSI(false)).c_str());
        event.details.subscriberName    = CORBA::string_dup((subscriber->getSubscriberName()).c_str());
        event.details.locationName      = CORBA::string_dup((subscriber->getLocation()).c_str());
        event.details.locationKey       = subscriber->getLocationKey();
        event.details.ownerTSI          = CORBA::string_dup("");

        switch (subscriber->getSubscriberType())
        {
            case TA_Base_Core::IRASubscribers::DISPATCHER:
            case TA_Base_Core::IRASubscribers::MOBILE:
            case TA_Base_Core::IRASubscribers::INDIVIDUAL:
                event.details.type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                break;

            case TA_Base_Core::IRASubscribers::GROUP:
                event.details.type = TA_Base_Bus::IRadioCorbaDef::GROUP_SUBSCRIBER;
                break;

            case TA_Base_Core::IRASubscribers::PATCH_GROUP:
                event.details.type = TA_Base_Bus::IRadioCorbaDef::PATCH_SUBSCRIBER;
                break;

            case TA_Base_Core::IRASubscribers::INVALID:
            default:
                LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, "Invalid subscriber type, taking shortcut out of function");
                return;
                break;
        }
    }
    else if (changeType == SCAN_SUBSCRIBERS)
    {
        event.details.TSI               = CORBA::string_dup("");
        event.details.subscriberName    = CORBA::string_dup("");
        event.details.locationName      = CORBA::string_dup("");
        event.details.locationKey       = 0;
        event.details.ownerTSI          = CORBA::string_dup("");
        event.details.type              = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
    }
    else
    {
        LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, "Subscriber is null but change type is not SCAN_SUBSCRIBERS. Not sending comms message");
        return;
    }

    data <<= event;

    TA_Base_Core::CommsMessageSender* commsMessageSender =
        TA_Base_Core::MessagePublicationManager::getInstance().getCommsMessageSender( TA_Base_Core::RadioComms::RadioDirectoryNotification );

    LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, "Sending subscriber change broadcast notification");
    commsMessageSender->sendBroadcastCommsMessage(TA_Base_Core::RadioComms::RadioDirectoryNotification, data);

//    commsMessageSender->sendCommsMessage(TA_Base_Core::RadioComms::RadioDirectoryNotification,
//                                         m_entityKey,
//                                         data,
//                                         0,
//                                         m_locationKey,
//                                         NULL);
}

void RadioDirectoryServant::onConnectionLost()
{
	m_radioDirectorySynchronisation->preventSynchronisation();
}

void RadioDirectoryServant::onConnectionEstablish()
{
	m_radioDirectorySynchronisation->triggerSynchronisation();
}

void RadioDirectoryServant::onSwitchConnection()
{
	//do nothing, not interest in this action
}
