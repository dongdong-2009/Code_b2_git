///////////////////////////////////////////////////////////
//
//  RadioConnectionManager.h
//  Implementation of the Class RadioConnectionManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
// This class is used to manage the connection to a pair of redundant TcpServers
///////////////////////////////////////////////////////////


#if !defined(RadioConnectionManager_A9DBEF5A_6704_44df_8170_14939DD391BD__INCLUDED_)
#define RadioConnectionManager_A9DBEF5A_6704_44df_8170_14939DD391BD__INCLUDED_

#include <vector>

#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/data_access_interface/entity_access/src/IEntityData.h"
#include "app/radio/RadioTetraAgent/src/IRadioConnectionObserver.h"
#include "app/radio/RadioTetraAgent/src/RadioTCPConnection.h"
#include "app/radio/RadioTetraAgent/src/RadioSynchronisationTypes.h"
#include "app/radio/RadioTetraAgent/src/RadioTcpServer.h"


/**
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:43:57
*/

namespace TA_IRS_App
{
	class RadioConnectionManager : public IConnectionStatusObserver
	{ 

	public:

		RadioConnectionManager(RadioTcpServer& eventProcesser);
		virtual ~RadioConnectionManager();

	public:

		/**
		* This function enables the radio hardware IP address to be defined
        *
        * @param isPrimary flag to indicate if the primary or secondary
        *        connection's address is being set
        * @param hostAddress the host address, in format "12.34.56.78:4000"
		*/
        void setRadioHost(bool isPrimary,std::string hostAddress);

			void setEntity(TA_Base_Core::IEntityData& entityData);

        /**
         *
         */
        void start();

        /**
         *
         */
		void setToControlMode(void);

        /**
         *
         */
		void setToMonitorMode(void);

		/**
		* Sends the content of the radio method to the Radio server via TCP/IP
		* @param    Method
		*/
		void SendMethod(const ITcpMethod& Method);

		/**
		* Change connection from primary to secondary.
		*/
		void switchConnection(bool toPrimary);

        /**
         * Accessor for determining if either of the servers is currently
         * actively connected
         */
        int numConnected();

        /**
         * Clears the SendMethod() if it is stuck in the waiting-for-a-connection state
         */
	    void releaseSendMethod();

		/**
         * This function is only used in monitor mode to hold the connection status of control agent
         */
		void setControlConnection(EControlConnectionStatus controlConnectionStatus);
	
		void getControlConnectionStatus(EControlConnectionStatus& controlConnectionStatus);

		void registForConnectionStatus( IRadioConnectionStatusObserver* observer);

		void unregistForConnectionStatus( IRadioConnectionStatusObserver* observer);

		virtual void onConnectionFail(bool isPrimary);
	
		virtual void onConnectionResumed(bool isPrimary);

		virtual void onCloseSocket();

	private:

        ///
        /// why a private accessor for a data member you ask ?
        /// apparently using "volatile" on pointers to UDT's results in 
        /// unusable pointers. If a fix is found, then by all means use it
        RadioTCPConnection * getCurrentConnection();

        bool waitForConnection();

		void notifyConnectionSwitch();

        ///
        /// vector of primary servers
		RadioTCPConnection            * m_primaryConnection;

        ///
        /// vector of secondary servers
		RadioTCPConnection            * m_secondaryConnection;

        ///
        /// the callback for notifying of connection failure/resume and on
        /// receiving a radio event

        ///
        /// Indicator for if this agent is in control/monitor mode
		volatile bool					m_active;

        /// 
        /// locks the m_currentConnection so that it isn't switched while sending
        TA_Base_Core::ReEntrantThreadLockable m_serverGuard;

		RadioTcpServer				  & m_tcpServer;

        ///
        RadioTCPConnection            * m_currentConnection;
        ///
        ///
	    volatile bool                   m_waitForConnection;

		std::vector< IRadioConnectionStatusObserver* > m_observers;

		TA_Base_Core::ReEntrantThreadLockable m_observerGuard;

		TA_Base_Core::ReEntrantThreadLockable m_connectionSwitchGuard;

		std::string         m_objectName;
		unsigned long       m_entityKey;
		unsigned long   	m_entityLocation;
		unsigned long		m_entitySubsystem;
		unsigned long		m_entityTypeKey;
		std::string			m_assetName;

		//use for hot standby
		volatile EControlConnectionStatus m_controlConnectionStatus;		

		volatile bool m_isConnected;
	};
}

#endif // !defined(RadioConnectionManager_A9DBEF5A_6704_44df_8170_14939DD391BD__INCLUDED_)
