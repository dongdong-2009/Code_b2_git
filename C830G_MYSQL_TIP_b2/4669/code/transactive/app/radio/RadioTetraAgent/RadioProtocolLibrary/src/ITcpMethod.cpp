///////////////////////////////////////////////////////////
//
//  ITcpMethod.cpp
//  Implementation of the Class ITcpMethod
//  Generated by Enterprise Architect
//  Created on:      06-Nov-2003 08:32:16
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#include "ITcpMethod.h"
#include "core/utilities/src/TAAssert.h"


using namespace TA_IRS_App;

/*
* Constructor
*
* Creates a new radio method (message).
*
* @param    methodLength Length of parameter block for this message. 
* 
*/
ITcpMethod::ITcpMethod(unsigned long methodLength, unsigned long methodHeaderLength,
				unsigned long methodHeaderLengthStartPosition)
		    : m_messageBuffer(0),
			  m_messageSize(methodLength+methodHeaderLength)
{
	// Create and initialise the message buffer
	m_messageBuffer = new unsigned char[m_messageSize];
	TA_ASSERT(m_messageBuffer!=NULL,"ITcpMethod method message buffer cannot be created.");
	for (unsigned int index = 0; index<m_messageSize; index++)
	{
		m_messageBuffer[index] = 0;
	}

	// If the methodHeaderLength is 0, then don't set the header
	//if(methodHeaderLength > 0)
		setLong(methodHeaderLengthStartPosition,m_messageSize);
}


ITcpMethod::~ITcpMethod()
{
	delete[] m_messageBuffer;
}


unsigned long ITcpMethod::getMessageDataSize() const
{
   return m_messageSize;
}


const unsigned char * ITcpMethod::getMessageData() const
{
	return m_messageBuffer;
}


void ITcpMethod::getLogText(std::string& hexText, std::string& consoleText) const
{
    char textBuffer[8] = {0};
        
    for (unsigned int iLoop=0 ; iLoop<m_messageSize ; iLoop++)
    {
        if ((isprint(m_messageBuffer[iLoop])!=0)&&(iLoop>=20))
        {
            textBuffer[0] = (char)m_messageBuffer[iLoop];
            textBuffer[1] = '\0';
            consoleText += textBuffer;
        }
        else
        {
            consoleText += ".";
        }
        
        sprintf(textBuffer," %.2X",m_messageBuffer[iLoop]);
        hexText += textBuffer;
    }
}


//***********************************************
// Protected methods for use by derived classes *
//***********************************************

void ITcpMethod::setParameterLong(unsigned int position,unsigned long value)
{
	setLong(position+getMethodHeaderLength(),value);
}


void ITcpMethod::setParameterShort(unsigned int position,unsigned short value)
{
	setShort(position+getMethodHeaderLength(),value);
}


void ITcpMethod::setParameterByte(unsigned int position,unsigned char value)
{
	setByte(position+getMethodHeaderLength(),value);
}

void ITcpMethod::setParameterShortString(unsigned int position,std::string value)
{
	TA_ASSERT(value.size()<=getShortStringLength(),"Value exceeds message short string size.");

	for (unsigned int index = 0; index<getShortStringLength(); index++)
	{
		if (index<value.size())
		{
			setParameterByte(index+position,value[index]);
		}
		else
		{
			setParameterByte(index+position,0);
		}
	}

}

void ITcpMethod::setParameterLongString(unsigned int position,std::string value,bool includeEosNull)
{
    size_t value_size = value.size(); // synonymous with length()
    if ( includeEosNull )
    {
        value_size++;
    }

    setParameterLong(position,value_size);

    position += 4;  // Length of the long

	for (unsigned int index = 0; index<value_size; index++)
	{
        setParameterByte(index+position,value[index]);
	}
}


/**
* Used to adjust the message size for dynamically sized messages.
* It will copy the existing message.
*
* @param    newsize    New size for message
*/
void ITcpMethod::setMessageSize(unsigned int newsize)
{
	// Add header to buffer
	newsize = newsize + getMethodHeaderLength();

	unsigned char*  newBuffer = new unsigned char[newsize];
	TA_ASSERT(newBuffer!=NULL,"Radio method message buffer cannot be resized.");

	// Copy the current message
	for (unsigned int index = 0; index<newsize; index++)
	{
		if (index<m_messageSize)
		{
			newBuffer[index] = m_messageBuffer[index];
		}
		else
		{
			newBuffer[index] = 0;
		}
	}

	// Replace the member buffer
	delete[] m_messageBuffer;
	m_messageBuffer = newBuffer;
	m_messageSize   = newsize;
	setMethodHeaderLength(m_messageSize);
}



//******************
// Private Methods *
//******************

void ITcpMethod::setLong(unsigned int position,unsigned long value)
{
	setShort(position,(unsigned short)(value%0x00010000));
	setShort(position+2,(unsigned short)(value/0x00010000));
}

/**
* Set the short value into the buffer with endian conversion
* @param    position
* @param    value
*/
void ITcpMethod::setShort(unsigned int position,unsigned short value)
{
	setByte(position,(value%0x0100));
	setByte(position+1,(value/0x0100));
}

void ITcpMethod::setByte(unsigned int position,unsigned char value)
{
	TA_ASSERT(position<m_messageSize,"Attempt to write beyond buffer.");

	m_messageBuffer[position] = value;
}

void ITcpMethod::setShortString(unsigned int position,std::string value)
{
	TA_ASSERT(value.size()<=getShortStringLength(),"Value exceeds message short string size.");

	for (unsigned int index = 0; index<getShortStringLength(); index++)
	{
		if (index<value.size())
		{
			setByte(index+position,value[index]);
		}
		else
		{
			setByte(index+position,0);
		}
	}

}

void ITcpMethod::setLongString(unsigned int position,std::string value,bool includeEosNull)
{
    size_t value_size = value.size(); // synonymous with length()
    if ( includeEosNull )
    {
        value_size++;
    }

    setParameterLong(position,value_size);

    position += 4;  // Length of the long

	for (unsigned int index = 0; index<value_size; index++)
	{
        setByte(index+position,value[index]);
	}
}