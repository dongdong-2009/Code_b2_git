/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioEvent.cpp $
  * @author:  Ripple
  * @version: $Revision: #4 $
  *
  * Last modification: $DateTime: 2010/09/23 18:48:34 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioEvent.cpp
//  Implementation of the Class RadioEvent
//  Generated by Enterprise Architect
//  Created on:      04-Nov-2003 13:28:33
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#include <string>
#include <vector>

#include "RadioEvent.h"
#include "RadioProtocol.h"
#include "RadioProtocolLibrary.h"
#include "core/utilities/src/TAAssert.h"


using namespace TA_IRS_App;

#define EVENT_HEADER_LENGTH                          20
#define EVENT_HEADER_LENGTH_START_POSITION           0
#define EVENT_HEADER_SESSION_ID_START_POSITION       4
#define EVENT_HEADER_TRANSACTION_ID_START_POSITION   8
#define EVENT_HEADER_STATUS_START_POSITION           12
#define EVENT_HEADER_EVENT_START_POSITION            16



RadioEvent::RadioEvent() :
ITcpEvent(),
m_eventReader(NULL)
{

}


RadioEvent::RadioEvent(const RadioEvent& radioEvent) :
ITcpEvent(radioEvent),
m_eventReader(NULL)
{
    // Make a copy of the buffer
    m_buffer = radioEvent.m_buffer;
}




RadioEvent::~RadioEvent()
{
   delete m_eventReader;
}


/**
* Resets the command to be empty.
*/
void RadioEvent::clear()
{
   ITcpEvent::clear();
   delete m_eventReader;
   m_eventReader = NULL;
}


/**
* This method is used to determine if the message is complete.  It is used after appending incoming characters to the message.
*/
bool RadioEvent::isComplete() const
{
	// Check message size is complete
	if (m_buffer.size()<EVENT_HEADER_LENGTH_START_POSITION+4) return false;

	// Ensure the buffer size is as expected.
	return (getEventLength()==getCurrentLength());
}


/**
* Get the session this event is intended for
*/
RadioEvent::SessionRefType RadioEvent::getSessionRef() const
{
	return readBufferLong(EVENT_HEADER_SESSION_ID_START_POSITION);
}


/**
* Returns the transaction Id for the event which will correspond to the Transaction ID of the associated Method called.
*/
RadioEvent::TransactionIDType RadioEvent::getTransactionId() const
{
	// Treat all CallStatus events as unsolicited (should be anyway)
	if (getEventType()==EVENT_CALL_STATUS)
	{
		return 0;
	}

	return readBufferLong(EVENT_HEADER_TRANSACTION_ID_START_POSITION);
}


/**
* Returns the status code for the event
*/
RadioEvent::StatusType RadioEvent::getStatus() const
{
	unsigned long status = readBufferLong(EVENT_HEADER_STATUS_START_POSITION);

	// Force it back to a long. (Use long rather than type to ensure it will break if StatusType is changed)
	return static_cast<long>(status);
}


/**
* Returns boolean to show if status indicates more data to follow.
*/
bool RadioEvent::isStatusMoreData() const
{
	return getStatus()==STATUS_OK_MORE_DATA_AVAILABLE;
}


std::string RadioEvent::getTextStatus() const
{
    FUNCTION_ENTRY("getTextStatus");

	std::string  text;

	switch (getStatus())
	{
		case (STATUS_OK): text = "Successful status";
			break;
		case (STATUS_KO_SESSION_NOT_FOUND): text = "Session reference does not correspond to a know session";
			break;
		case (STATUS_KO_DEMAND_TX_FAILED): text = "A DemandTX operation failed";
			break;
		case (STATUS_KO_SWITCH_NOT_REACHABLE): text = "Switch not reachable,communications lost";
			break;
		case (STATUS_KO_INVALID_AUDIO_LINK): text = "Audio link id is invalid";
			break;
		case (STATUS_KO_NOT_INITITALISED): text = "Initialise method failed";
			break;
		case (STATUS_KO_BAD_USERNAME): text = "Bad username in login";
			break;
		case (STATUS_KO_BAD_PASSWORD): text = "Bad password in login or change password";
			break;
		case (STATUS_KO_NOT_LOGGED): text = "Operation not permitted when no user logged in";
			break;
		case (STATUS_KO_NOT_ALLOWED): text = "Operation not permitted for this user";
			break;
		case (STATUS_KO_INVALID_REFERENCE): text = "Passed reference is not known or of the incorrect type for this operation";
			break;
		case (STATUS_KO_INVALID_KEY): text = "Query reference key is unknown or unusable for this resource";
			break;
		case (STATUS_KO_CHANGE_REFERENCE): text = "Error processing ChangeReference command";
			break;
		case (STATUS_KO_NO_RESOURCE): text = "Insufficient resources available in system to complete request.";
			break;
		case (STATUS_KO_SETUP_CALL_FAILED): text = "The SetupCall failed";
			break;
		case (STATUS_KO_SUBSCRIBER_NOT_FOUND): text = "Subscriber not found for MonitorSubscriber request";
			break;
		case (STATUS_KO_DEST_NOT_VALID): text = "The destination reference in the Include request is invalid";
			break;
		case (STATUS_KO_SRC_NOT_VALID): text = "The source reference in the Include request is invalid";
			break;
		case (STATUS_KO_INCLUDE_FAILED): text = "The Include operation failed";
			break;
		case (STATUS_KO_SC_NOT_CREATED): text = "SC does not exist";
			break;
		case (STATUS_KO_GWLD_LINK_LOST): text = "Switch link broken";
			break;
		case (STATUS_KO_INVALID_REFERENCE_TYPE): text = "Invalid reference type";
			break;
		case (STATUS_KO_INVALID_FIELD): text = "Invalid key in GetGroupDetails";
			break;
		case (STATUS_KO_SUBSCRIBER_ALREADY_EXISTS): text = "Invalid attempt to create subscriber which already exists";
			break;
		case (STATUS_KO_INVALID_GROUP): text = "Operator cannot be attached to the specified group";
			break;
		case (STATUS_KO_OPERATOR_NOT_ATTACHED): text = "Invalid attempt to detach an unattached operator";
			break;
		case (STATUS_KO_ATTACH_FAILED): text = "An AttachToGroup failed";
			break;
		case (STATUS_KO_DETACH_FAILED): text = "A DetachFromGroup failed";
			break;
		case (STATUS_KO_QUEUE_FULL): text = "Can not send circuit data, queue full";
			break;
		case (STATUS_OK_PARTIAL_TRANSFER): text = "Can not send circuit data, partial transfer";
			break;
		case (STATUS_KO_INCOMPATIBLE_VERSION): text = "Client API incompatible with server version";
			break;
		case (STATUS_KO_MESSAGE_TOO_LONG): text = "Sent message exceeds maximum size of 48KB";
			break;
		case (STATUS_KO_DBMS_ERROR): text = "An error occured performing SQL statement";
			break;
		case (STATUS_KO_SEND_SDS_FAILED): text = "A SendSDS command failed";
			break;
		case (STATUS_KO_AUTHORISE_FAIL): text = "Attempt to accept/reject an Authorisation failed";
			break;
		case (STATUS_KO_REJECTED): text = "Monitor request rejected";
			break;
		case (STATUS_KO_RTT_SERVER_NOT_CONNECTED): text = "The RTT server is not connected or link is down";
			break;
		case (STATUS_KO_INVALID_NUMBER_OF_REF): text = "Two audio references provided for a half duplex call";
			break;
		/* TBA
		case (STATUS_KO_TOO_MANY_RECORDS_FOUND): text = "Search request returned too many records";
			break;
		*/
		case (STATUS_KO_HW_NOT_ALLOCATED): text = "StartTone request failed";
			break;
		case (STATUS_KO_BAD_CATEGORY): text = "SetSystemErrorThreshold contains bad category";
			break;
		case (STATUS_KO_NE_NACK): text = "Network not responding to query for active alarms";
			break;
		case (STATUS_KO_SERVER_NOT_FOUND): text = "Attach to alarm server failed";
			break;
		case (STATUS_KO_TOO_MANY_ATTACH_SESSIONS): text = "Number of attached sessions exceeded";
			break;



		default:
			text = "Unknown radio error";
	}

	FUNCTION_EXIT;

    return text;
}


/**
* Returns the radio event type for the event.
*/
RadioEvent::EventType RadioEvent::getEventType() const
{
    FUNCTION_ENTRY("getEventType");
    FUNCTION_EXIT;

	return readBufferLong(EVENT_HEADER_EVENT_START_POSITION);
}


/**
* Return the specified length of the message as defined in the first bytes.
*/
unsigned long RadioEvent::getEventLength() const
{
    FUNCTION_ENTRY("getEventLength");
    FUNCTION_EXIT;

	return readBufferLong(EVENT_HEADER_LENGTH_START_POSITION);
}

/**
* Return the specified length of the message as defined in the first bytes.
*/
unsigned long RadioEvent::getEventHeaderLength() const
{
    FUNCTION_ENTRY("getEventHeaderLength");
    FUNCTION_EXIT;
    return EVENT_HEADER_LENGTH;
}



/**
* Provides access to the appropriate RadioEventReader for the incoming message.  The reader will be automatically destroyed when the RadioEvent is destroyed.
*/
RadioEventReader* RadioEvent::getEventReader()
{
    FUNCTION_ENTRY("getEventReader");


	if (m_eventReader==NULL)
	{
		m_eventReader = createEventReader();
	}

    FUNCTION_EXIT;
	return m_eventReader;
}


/**
* Create an event reader that is correct for the type of message.
*/
RadioEventReader* RadioEvent::createEventReader()
{
	TA_ASSERT(isComplete(),"Attempted to create reader when message is not complete.");
	FUNCTION_ENTRY("createEventReader");

	RadioEventReader*  eventReader = NULL;

	switch (getEventType())
	{
		case EVENT_INCOMING_CALL: eventReader = new IncomingCallEventReader(*this);
			                      break;

		case EVENT_INCOMING_SDS:  fixIncomingSDSEventBuffer();
								  eventReader = new IncomingSDSEventReader(*this);
			                      break;

		case EVENT_NEW_REFERENCE: eventReader = new NewReferenceEventReader(*this);
			                      break;

		case EVENT_DELETE_REFERENCE: eventReader = new DeleteReferenceEventReader(*this);
			                         break;

		case EVENT_DEMAND_TX:	  eventReader = new DemandTXEventReader(*this);
			                      break;

		case EVENT_DISCONNECT:    eventReader = new DisconnectEventReader(*this);
			                      break;

		case EVENT_GET_GROUP_DETAILS: eventReader = new GetGroupDetailsEventReader(*this);
			                          break;

		case EVENT_QUERY_REFERENCE: eventReader = new QueryReferenceEventReader(*this);
			                        break;

		case EVENT_SEARCH_SUBSCRIBER: eventReader = new SearchSubscribersEventReader(*this);
			                          break;

		case EVENT_SELECT:        eventReader = new SelectEventReader(*this);
			                      break;

		case EVENT_TEXT_2SR:      eventReader = new Text2SubscriberReferenceEventReader(*this);
			                      break;

		case EVENT_TEXT_TO_REFERENCE: eventReader = new TextToReferenceEventReader(*this);
			                          break;

		case EVENT_REQUEST_AUTHORISE: eventReader = new RequestAuthoriseEventReader(*this);
			                          break;

		case EVENT_LOGIN:             eventReader = new LoginEventReader(*this);
			                          break;

        case EVENT_SUBSCRIBERACTIVITY:
                                      eventReader = new SubscriberActivityEventReader(*this);
			                          break;

        case EVENT_MONITORSUBSCRIBER: eventReader = new MonitorSubscriberEventReader(*this);
			                          break;

        case EVENT_MONITORCALL:       eventReader = new MonitorCallEventReader(*this);
			                          break;

        case EVENT_INCLUDE:           eventReader = new IncludeEventReader(*this);
			                          break;

        case EVENT_ATTACHTOGROUP:     eventReader = new AttachToGroupEventReader(*this);
			                          break;

		case EVENT_GROUPCALLACK:      eventReader = new GroupCallAckEventReader(*this);
			                          break;

		case EVENT_CALL_STATUS:       eventReader = new CallStatusEventReader(*this);
			                          break;

		case EVENT_INCOMINGCIRCUITDATA: 
									  eventReader = new IncomingCircuitDataEventReader(*this);
									  break;

		case EVENT_CIRCUITDATACAPACITY: 
									  eventReader = new CircuitDataCapacityEventReader(*this);
									  break;
		case EVENT_SENDCIRCUITDATA:   
									  eventReader = new SendCircuitDataEventReader(*this);
									  break;
		case EVENT_SYSTEM_ERROR:   
									  eventReader = new SystemErrorEventReader(*this);
									  break;
		case EVENT_DETACH_SESSION:
									  eventReader = new DetachSessionEventReader(*this);
									  break;
		case EVENT_CHECKCONNECTION:
									  eventReader = new CheckConnectionEventReader(*this);
									  break;
		case EVENT_KEEPALIVE:
									  eventReader = new KeepAliveEventReader(*this);
									  break;



		default: 
			//std::stringstream s;
			//s << "Event reader not defined for this message [" << getEventType() << "]." << std::ends;
			//TA_ASSERT(false,s.str().c_str());
			LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
		     "createEventReader() - Event reader not defined for transaction: %lu, event: %lu, session: %lu",
			 getTransactionId(), getEventType(), getSessionRef());

	}

	FUNCTION_EXIT;

	return eventReader;
}


// RvH 20050114 radio pre-iFAT fix
// Big hackarooni.  If the event length is less than 281 (the current overall length for an IncomingSDS event),
// pad it out with zeros.
#define INCOMINGSDS_TOTAL_EVENT_LENGTH 281
void RadioEvent::fixIncomingSDSEventBuffer()
{
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
		 "fixIncomingSDSEventBuffer() - getEventLength(): %lu, m_buffer.size(): %d",
		 getEventLength(), m_buffer.size() );
	if ( ( getEventLength() < INCOMINGSDS_TOTAL_EVENT_LENGTH ) || ( m_buffer.size() < INCOMINGSDS_TOTAL_EVENT_LENGTH ) )
	{
		int bytes_added = 0;
		while (m_buffer.size() < INCOMINGSDS_TOTAL_EVENT_LENGTH)
		{
			m_buffer.push_back(0);
			bytes_added++;
		}
		writeBufferLong(0, INCOMINGSDS_TOTAL_EVENT_LENGTH);
		LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
			 "fixIncomingSDSEventBuffer() - getEventLength(): %lu, m_buffer.size(): %d, bytes added: %d",
			 getEventLength(), m_buffer.size(), bytes_added );
	}

}
