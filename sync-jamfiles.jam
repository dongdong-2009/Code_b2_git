import sequence path option set print common ;

TOP = [ path.pwd ] ;
VERIFY = F:/Verify ;

BRANCHS	=
	PRIV_3001
	C830G_TIP
	FZL1_TIP
	GZL9_TIP
	3001_TIP_NEW
	T253_PSCADA_TIP
	TA_Common_V1_TIP
	;

SUFFIX = _b2 ;

IGNORE_FILE_PATTERN = config.jam project-dependency.jam ;

rule all-top-dirs ( )
{
	return [ path.glob $(TOP) : * : *.* ] ;
}

rule all-dirs ( exclude * )
{
	local suffixes = $(SUFFIX) ;

	if [ option.get "with-solaris" : : true ]
	{
		suffixes += _solaris ;
	}

	local tops = $(TOP) ;

	if [ option.get "with-verify" : : true ]
	{
		tops += $(VERIFY) ;
	}

	local result ;
	local branches = $(BRANCHS) $(BRANCHS)$(suffixes) ;

	for local dir in [ sequence.transform path.native : $(tops)/$(branches) $(tops)/$(branches)$(suffixes) ]
	{
		if [ path.exists $(dir) ]
		{
			result += $(dir) ;
		}
	}

	result = [ sequence.unique $(result) ] ;

	if $(exclude)
	{
		result = [ set.difference $(result) : [ sequence.transform path.native : $(exclude) ] ] ;
	}
	return $(result) ;
}

rule all-branches ( )
{
	local suffixes = $(SUFFIX) ;

	if [ option.get "with-solaris" : : true ]
	{
		suffixes += _solaris ;
	}

	return $(BRANCHS) $(BRANCHS)$(suffixes) ;
}

rule sync-jamfiles ( from )
{
	if ! $(from) in [ all-branches ]
	{
		echo "'$(from)' is not a branch." ;
		print.lines "\nBranchs:" $(BRANCHS) : "\t" ;
		return ;
	}

	local files = [ sequence.transform path.native : [ path.glob $(TOP)/$(from) : *.jam pch.hpp : $(IGNORE_FILE_PATTERN) ] ] ;

	if ! $(files)
	{
		echo "cannot find .jam in '$(from)'" ;
		return ;
	}

	print.lines "Sync files" $(files:BS) : "\t" ;
	print.lines "From" [ path.native $(from) ] : "\t" ;
	print.lines "To" ;

	for local dir in [ all-dirs $(TOP)/$(from) ]
	{
		print.lines $(dir) : "\t" "\t" ;

		for file in $(files)
		{
			# if [ path.exists [ path.native $(dir)/$(file:BS) ] ]
			{
				local copy-command = "COPY /Y $(file) $(dir)" ;
				# echo $(copy-command) ;
				SHELL "$(copy-command)" ;
			}
		}
	}
}

rule remove-jamfiles ( jamfiles + )
{
	local RM = [ common.rm-command ] ;

	for local dir in [ all-dirs ]
	{
		for file in $(jamfiles)
		{
			local to-delete = [ path.native $(dir)/$(file) ] ;
			if [ path.exists $(to-delete) ]
			{
				local rm-command = [ sequence.join $(RM) $(to-delete) : " " ] ;
				SHELL "$(rm-command)" ;
			}
		}
	}
}

IMPORT $(__name__) : [ RULENAMES $(__name__) ] : : [ RULENAMES $(__name__) ] ;
