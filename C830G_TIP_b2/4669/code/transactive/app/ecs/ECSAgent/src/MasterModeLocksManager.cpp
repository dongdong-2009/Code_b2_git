/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/ecs/ECSAgent/src/MasterModeLocksManager.cpp $
  * @author:  Ripple
  * @version: $Revision: #2 $
  *
  * Last modification: $DateTime: 2009/10/28 18:12:47 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  MasterModeLocksManager.cpp
//  Implementation of the Class MasterModeLocksManager
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author:
//
///////////////////////////////////////////////////////////
//  Modification history:
//
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290 4503)
#endif // defined _MSC_VER

#include "app/ecs/ECSAgent/src/ItaEcsDatapoints.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedMaps.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedConfig.h"
#include "app/ecs/ECSAgent/src/MasterModeLocksManager.h"

#include "core/exceptions/src/ECSAgentExceptions.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"




MasterModeLocksManager::MasterModeLocksManager(
    ItaEcsCachedConfig& theConfig,
    ItaEcsCachedMaps& theMaps, 
    ItaEcsDatapoints& theDatapoints)
: m_theMaps(theMaps),
  m_theDatapoints(theDatapoints),
  m_theConfig(theConfig),
  m_lastAppliedMasterMode(TA_IRS_Bus::ECS_NONE_OR_INVALID)
{
    FUNCTION_ENTRY("Constructor");

	m_theDatapoints.attachEmergencyObserver(this);

    FUNCTION_EXIT;
}


// ExceptionChecked
MasterModeLocksManager::~MasterModeLocksManager()
{
    FUNCTION_ENTRY("Destructor");

	m_theDatapoints.detachEmergencyObserver(this);

    FUNCTION_EXIT;
}


void MasterModeLocksManager::setControl(bool isOnStartup)
{
    AbstractFailoverable::setControl(isOnStartup);

    if (true == isOnStartup)
    {
        // We must be enabled first
        removeMasterModeLocks();
    }
}

void MasterModeLocksManager::processEmergencyUpdate(unsigned long zoneId, bool value)
{
	if (false == m_isEnabled)
	{
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping operation in operation mode");        
	}

	// Not interested when the value is true (still in emergency)
	if ( true == value)
	{		
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
            "MasterModeLocksManager::processEmergencyUpdate - Ignoring processing when entering an emergency state");        
		return;
	}

	// value is false, no longer in emergency 
    // if it is -1 or -3 ignore as master mode is not yet set.
    // -1 is the default value of the datapoint and -3 is set when the dialog box in EcsManager is opened

    /*unsigned*/ long currMasterMode = m_theDatapoints.getCurrentMasterMode();	//dahe++ for CL-21046
    if( currMasterMode != TA_IRS_Bus::ECS_NONE_OR_INVALID && 
		currMasterMode != TA_IRS_Bus::ECS_NONE_AND_EXPECTING)
    {
        try
        {
	        unsigned long currentAppliedEcsZoneId = m_theMaps.getZoneIdFromMasterMode(m_theDatapoints.getCurrentMasterMode());

            if (currentAppliedEcsZoneId == zoneId)
            {
                // Found a case where there was a fire and a Master Mode was applied - and now the fire is gone.
                removeMasterModeLocks();
            }
        }
        catch(TA_Base_Core::CachedMappingNotFoundException&)
        {
		    // Just ignore
        }  
    }
}

void MasterModeLocksManager::applyMasterModeLocks(unsigned long masterMode)
{
	if (false == m_isEnabled)
	{
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping operation in operation mode");        
	}

	// Do not set the Master Mode Locks for the Normal Master Mode
    if ( masterMode == m_theConfig.getNormalMasterMode())
    {
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
            "MasterModeLocksManager::applyMasterModeLocks - Ignoring processing for normal master mode");
        return;
    }


    try
    {

		TA_IRS_Bus::EcStationModeRecords stationModeRecords = 
			m_theMaps.getEcStationModeRecordsFromMasterMode(masterMode);

		for (int i=0; i<stationModeRecords.length(); ++i)
		{
			m_theDatapoints.setExternalMasterModeLock(stationModeRecords[i].locationKey, true);
		}  
		
	}
    catch(TA_Base_Core::CachedMappingNotFoundException&)
    {
		// Just ignore
    }  
}

void MasterModeLocksManager::removeMasterModeLocks()
{
	if (false == m_isEnabled)
	{
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping operation in operation mode");        
	}

	std::vector<unsigned long> locationKeys = m_theMaps.getAllStationEcsAgentLocationKeys();

	for (std::vector<unsigned long>::iterator it=locationKeys.begin(); it!=locationKeys.end(); ++it)
	{
		m_theDatapoints.setExternalMasterModeLock(*it, false);
	}
}
