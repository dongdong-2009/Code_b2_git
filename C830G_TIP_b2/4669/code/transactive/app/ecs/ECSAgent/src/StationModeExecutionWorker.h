/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/ecs/ECSAgent/src/StationModeExecutionWorker.h $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  StationModeExecutionWorker.h
//  Implementation of the Class StationModeExecutionWorker
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(StationModeExecutionWorker_B323CC80_49BA_4d42_98A5_8CE9884F7924__INCLUDED_)
#define StationModeExecutionWorker_B323CC80_49BA_4d42_98A5_8CE9884F7924__INCLUDED_

#include <string>

#include "app/ecs/ECSAgent/src/ItaEcsCachedConfig.h"
#include "app/ecs/ECSAgent/src/AbstractFailoverable.h"

#include "bus/scada/proxy_library/src/ScadaProxyFactory.h"
#include "bus/scada/proxy_library/src/DataPointProxySmartPtr.h"
#include "bus/scada/proxy_library/src/IEntityUpdateEventProcessor.h"

#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/threads/src/Thread.h"
#include "core/timers/src/ITimeoutCallback.h"
#include "core/timers/src/SingletonTimerUtil.h"

class ItaEcsAuditing;
class ItaEcsAgentCompleteState;
class ItaEcsDatapoints;

//TD4303, use timer driven thread rather than to sleep
class StationModeExecutionWorker : public TA_Base_Core::Thread,
                                   public ItaEcsCachedConfigObserver,
                                   public TA_Base_Bus::IEntityUpdateEventProcessor,
                                   public virtual AbstractFailoverable,
                                   public TA_Base_Core::ITimeoutCallback
{

public:
    StationModeExecutionWorker(
        ItaEcsCachedConfig& theConfig,
        ItaEcsAuditing& theAuditing,
        ItaEcsAgentCompleteState& theCompleteState,
        ItaEcsDatapoints& theDatapoints);

    virtual ~StationModeExecutionWorker();
  
    virtual void run();
    virtual void terminate();

    void execute
        (long fromStationMode,
         long toStationMode,
         long forMasterMode,
         const std::string& sessionId);

    void abortIfRequired();

    //Implement for ITimeoutCallback;
    void timerExpired(long timerId, void* userData);
    
private:

    void processReadyState(TA_IRS_Bus::IStationEcsAgentCorbaDef::EcsStationModeExecutionUpdateData& modeState);
    void processControlState(TA_IRS_Bus::IStationEcsAgentCorbaDef::EcsStationModeExecutionUpdateData& modeState);
    void processInProgressState(TA_IRS_Bus::IStationEcsAgentCorbaDef::EcsStationModeExecutionUpdateData& modeState);
    void processCompletedState(TA_IRS_Bus::IStationEcsAgentCorbaDef::EcsStationModeExecutionUpdateData& modeState);

    virtual void processItaEcsCachedConfigUpdate(ItaEcsCachedConfig::EItaEcsCachedConfigItemKey key);
    virtual void processEntityUpdateEvent(unsigned long entityKey, TA_Base_Bus::ScadaEntityUpdateType updateType);
    void processModeControlUpdate(TA_Base_Bus::ScadaEntityUpdateType updateType);
    void processModeInProgressUpdate(TA_Base_Bus::ScadaEntityUpdateType updateType);


    ItaEcsCachedConfig&                         m_theConfig;
    ItaEcsAuditing&                             m_theAuditing;
    ItaEcsAgentCompleteState&                   m_theCompleteState;
    ItaEcsDatapoints&                           m_theDatapoints;
    
    volatile bool                               m_isRunning;

    TA_Base_Bus::DataPointProxySmartPtr         m_modeControlProxy;
    TA_Base_Bus::DataPointProxySmartPtr         m_modeInProgressProxy;   

	// Tempted to move this lock to the CtaEcsAgentCompleteState class so that
	// multiple clients can acquire and release locks there.  Will do this 
	// if we need to access this data from an additional class.
    TA_Base_Core::ReEntrantThreadLockable    m_possibleModeStateModificationLock;
    TA_Base_Core::ReEntrantThreadLockable    m_lockForConfigUpdates;

    time_t                                      m_startTime;
    TA_Base_Core::SingletonTimerUtil&		    m_timerUtility;

	TA_Base_Bus::ScadaProxyFactory*				m_proxyFactory;
    
private:
    StationModeExecutionWorker( const StationModeExecutionWorker& theStationModeExecutionWorker);


};

#endif // !defined(StationModeExecutionWorker_B323CC80_49BA_4d42_98A5_8CE9884F7924__INCLUDED_)
