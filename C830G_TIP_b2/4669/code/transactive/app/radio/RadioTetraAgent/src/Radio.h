/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/Radio.h $
  * @author:  Ripple
  * @version: $Revision: #3 $
  *
  * Last modification: $DateTime: 2008/12/19 09:53:33 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  Radio.h
//  Implementation of the Class Radio
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 16:10:10
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if !defined(Radio_CC2C4427_A45B_4f2d_AA2B_8A8DC1714F3B__INCLUDED_)
#define Radio_CC2C4427_A45B_4f2d_AA2B_8A8DC1714F3B__INCLUDED_
#include <string>
#include <vector>
#include <list>
#include <set>


#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/data_access_interface/entity_access/src/IEntityData.h"

#include "bus/radio/RadioAgentCorbaDef_4669/idl/src/IRadioCorbaDef.h"

#include "app/radio/RadioTetraAgent/src/RadioCircuitModeManager.h"
#include "app/radio/RadioTetraAgent/src/RadioTypes.h"
#include "app/radio/RadioTetraAgent/src/RadioSynchronisationTypes.h"
#include "app/radio/RadioTetraAgent/src/RadioTask.h"
#include "app/radio/RadioTetraAgent/src/IRadioConnectionObserver.h"
#include "app/radio/RadioTetraAgent/src/RadioServerLinkStatusUpdateThread.h"

#include "core/data_access_interface/radio/src/RASpeedDialSet.h"
#include "core/data_access_interface/radio/src/IRASpeedDialButton.h"
#include "core/data_access_interface/radio/src/RASpeedDialButtonAccessFactory.h"
#include "core/data_access_interface/radio/src/RASpeedDialButton.h"
#include "core/data_access_interface/radio/src/RASpeedDialSetAccessFactory.h"
#include "core/data_access_interface/radio/src/RAGroupMembersAccessFactory.h"
#include "core/data_access_interface/radio/src/IRASubscribers.h"
#include "core/data_access_interface/radio/src/RAPatchMembersAccessFactory.h"
#include "core/data_access_interface/radio/src/RASubscribersAccessFactory.h"

#include "bus/security/authentication_library/src/AuthenticationLibrary.h"
#include "bus/security/authentication_library/src/SessionInfo.h"

#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioMethod.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/GroupCallAckEventReader.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/IncomingCircuitDataEventReader.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/CircuitDataCapacityEventReader.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/SubscriberActivityEventReader.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/MonitorSubscriberEventReader.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/SystemErrorEventReader.h"


namespace TA_Base_Bus
{
    class ItaScada;

}

/**
* This class manages all the radio sessions
* @generator Enterprise Architect
* @created 29-Oct-2003 16:10:09
* @author Andy Parker
* @version 1.0
* @updated 29-Oct-2003 16:22:17
* @updated 29-Oct-2003 16:30:06
* @updated 29-Oct-2003 17:05:27
* @updated 29-Oct-2003 17:39:20
*/

namespace TA_IRS_App
{
	class RadioSession;
	class IRadioCallback;
	class IRadioDirectoryCallback;
    class RadioDirectory;
    class RadioDirectorySynchronisation;
	class RadioEvent;
	class IncomingCallEventReader;
	class IncomingSDSEventReader;
    class RadioBackgroundProcessor;
    class RadioTcpServer;
	class RadioCircuitModeManager;
    struct References;

	class Radio
	{

	public:

        // TCPSERVER TRANSFER DONE
        Radio(RadioServerLinkStatusUpdateThread* linkStatusThread, IRadioCallback& callback/*, TA_Base_Bus::ItaScada& scada*/);
        // TCPSERVER TRANSFER DONE
		virtual ~Radio();

		void Radio::setEntity(TA_Base_Core::IEntityData& entityData);

        /**
         * Returns the callback instance.
         */
        IRadioCallback& getRadioCallback();

		/**
		* Used by the ISCS Radio session to advise Radio of the special session (used for trainborne comms)
		* @param    session
		*/

		void setISCSRadioSession(RadioSession& session);
		/**
		* This function enables the radio hardware IP addresses to be defined
        * as well as other necessary parameters.
        *
        * @param primaryAddresses the list of primary host addresses, in format
        *        "12.34.56.78:4000,21,43.65.87:4000,third.host.ip.address:port"
        * @param secondaryAddresses the list of secondary host addresses, same
        *        format as the primaries. There cannot be more secondary
        *        addresses than primary, so the list of secondary addresses is
        *        restricted to the number of primary. Each of the secondary 
        *        addresses is paired with the same TcpServer as the corresponding
        *        ipaddress in the primaryAddresses list, ie. the first secondary
        *        address will be paired with the first primary, etc.
		*/
		void setParameters( const std::string & primaryAddresses,
                            const std::string & secondaryAddresses,
							unsigned long defaultVolume,
                            unsigned char serialiseTransactionLevel,
                            unsigned long xonXoffTimeout,
                            unsigned long circuitDataFramesPerPacket );

        void start();
		
		void setToControlMode(void);
		void setToMonitorMode(void);
        
        void onTerminate(bool peerAvailable);
		
		/**
		* This method returns the m_active member value
		*/
		bool getIsActive(void);

		/*
		* This function returns the session reference for this session.  It is used to identify calls that belong to this session
		*/
		SessionReference getISCSRadioSessionRef();

        RadioSession * getISCSRadioSession();

		/**
		* This method sends a method request to the radio system and waits for a reply (event).  It will be used by the RadioSession to perform its operations.
		*
		* Releases SDS Reference - used when new incoming SDS received and processed by ISCS
		* DO NOT CALL DIRECTLY FROM TCP/IP THREAD - Must go through Resource Manager as it will 
		* block when waiting for reply from TCP/IP.
		*
		* @param    Method
		*/
		RadioEvent* sendMethod(RadioMethod& Method);

		/**
         * sendMethodMultipleResponse
         *
		 * This method sends a method request to the radio system and waits for as many replys as the radio system
         * sends. The only difference between this method and the standard sendMethod is that send method will
         * only ever return a single event.
         *
		 * @param    Method The method to send
         *
         * @return A vector of the events recieved in response to the original message. A vector of size 0 
         * means that no responses were sent.
		 */
        std::vector<RadioEvent*> sendMethodMultipleResponse(RadioMethod& Method);

		void getCallList(ConsoleID consoleId,CallList& callList);

        /** retrieves a list of calls that the given tsi is involved in. 
         * TD12462 In fallback, cannot send SDS to train if audio already established
         */
		void getTsiCallList(const std::string & tsi, bool audioOnly, CallList & callList);
		
		bool getCallDetails(CallID callId, ConsoleID consoleId, CallDetailsType& details);

		// RvH 20050115 Radio Pre-iFAT
		// Like getCallDetails, but doesn't copy across the CallParticpants
		// vector. Is a seperate function because different copying logic is used
		bool getCallDetailsPartial(CallID callId, ConsoleID consoleId, CallDetailsType& details);
		
		


		void addCallDriverRequest(unsigned char trainID,const char* trainTSI);
		void removeCallDriverRequest(unsigned char trainID);


		/**
		* sends an SDS message to the train identified in the message.  
		*/
		void sendTrainCommand(const char* trainITSI,std::vector<unsigned char> message);

        /**
         * Sets up a circuit mode data call
         */
		NewReferenceEventReader::RadioReference setupDataCall(const std::string& destinationTsi);

        /**
         * Sends a packet in a circuit mode transfer
         */
        void sendCircuitDataFrame( NewReferenceEventReader::RadioReference callReference,
                                   const RadioCircuitTransfer::Data& frame );

        /**
         * Ends a circuit mode transfer call
         */
        void endDataCall( NewReferenceEventReader::RadioReference callReference );

        /**
         * Deletes a reference to an already ended call (ie disconnected)
         */
        void clearDataCallReference( NewReferenceEventReader::RadioReference callReference );

			void Radio::updateControlConnectionState(EControlConnectionStatus controlConnectionStatus, unsigned long TcpServerIndex);


        /**
         * Adds a RadioTask to the BackgroundProcessor thread. Facade method.
         *
         * @param task a derived RadioTask as created by the RadioTaskFactory
         */
        void addBackgroundTask(RadioTaskPtr task);

        /** Mutator for m_directoryCallback data member
         *
         *  @param directoryCallback the reference to the callback interface
         */
        void setDirectoryCallback(IRadioDirectoryCallback * directoryCallback);
		RadioCircuitModeManager* getRadioCircuitModeManager();


        
        // state synchronisation functions
        void applyFullState(const RadioType& state);
        void clearFullState();
        void getFullState(RadioType& state);
        void updateCallInRadioCallStack(const CallDetailsType& callDetails);
        void removeCallFromRadioCallStack(CallID callID, unsigned long consoleID);
        /**
		  * @param 
		*/
		void updateRadioMonitoredCallProgression(unsigned long monitorReference);
		void removeMonitoredSubscriberDetails(unsigned long monitorReference, long serverIndex);
		void updateAudioEntryInSessionMap(SessionID sessionReference, 
										  AudioReference audioReference,
										  const AudioEntryType& audioEntry);
		void updateRadioResourceManagerVars(SessionID sessionReference, CallReference callReference,
											int currentVolume, long serverIndex);
		void updateAuthorisationRequest(const AuthorisationRequestType& authorisationRequest, long serverIndex);
		void removeAuthorisationRequest(CallID callID, long serverIndex);
		void removeSessionFromAudioMap(SessionID sessionReference, long serverIndex);

        // Fallback & Degraded IDL support
        virtual bool inFallback() const;
        virtual void resetConnection();
        std::string getFallbackReplacementString();

		void setDpServerFallback(bool isFallback);
		void setDpServerLostConnection(int serverIndex, bool isLost);

		void updateControlConnectionState(EControlConnectionStatus controlConnectionStatus);

        /**
		*
		*/
        void onConnectionFailed(ServerIndex svrIdx);
		
        /**
		*
		*/
        void onConnectionResumed(ServerIndex svrIdx);

		void onSwitchConnection(ServerIndex svrIdx);

       /**
		* IncomingCircuitData Event handler
		*/
		void onIncomingCircuitData(const TA_IRS_App::IncomingCircuitDataEventReader& eventReader);

		/**
        *
		*/
		void onCircuitDataCapacity(const TA_IRS_App::CircuitDataCapacityEventReader& eventReader);

		/**
		* This method will handle changes to radio fall back mode.  Some functions will become 
		* unavailable therefore applications must be notified.  An alarm should be raised/closed 
		* to alert the operator.
		*/
		void onRadioFallback(bool isFallback, EFallbackReason fallbackReason);

        /**
		* Returns the TcpServer instance with the given ID
		*
		* If the ID requested is out of range, NULL is returned.  The calling
		* client function is expected to deal with this
		*/
        RadioTcpServer * getAudioLinkServer(unsigned int audioLinkServerId);

		/**
		 * These are to get and set the agent's asset name for
		 * alarm submission
		 */
		std::string getAgentAssetName() { return m_agentAssetName; };
		void setAgentAssetName (std::string assetName) { m_agentAssetName = assetName; };

		/************************************************************************/
		/* Returns the default volume                                            */
		/************************************************************************/
		unsigned long getDefaultVolume() { return m_defaultVolume;};

        void addSessionServerConsole(SessionReference sessionRef, ServerIndex svrIdx, ConsoleID consoleID);
        //*************************************************
        // IRadioDirectory - Speed Dial Interface Methods *
        //*************************************************

        /**
         * This method will return the list of speed dial set entries based on setName. 
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SpeedDialList* getSpeedDialSet(const std::string& setName);

		/**
		 * This method will add (or update if existing) the speed dial set entry with
		 * the new details supplied.
		 */
        virtual void updateSpeedDialSet(const TA_Base_Bus::IRadioCorbaDef::SpeedDialSet& setDetails, const std::string& sessionID);

		/**
		 * This method will add (or update if existing) the speed dial button entry with
		 * the new details supplied.
		 */
		virtual void updateSpeedDial(const std::string& setName, const TA_Base_Bus::IRadioCorbaDef::SpeedDialEntry& newEntry, const std::string& sessionID);

		/**
		 * getUserSetName
		 *
		 * Returns the name of the speed dial set associated with the specified user and profile combination
		 *
		 * @param sessionID The Session ID of the user for which to retrieve the set details
		 */
        virtual std::string getUserSetName(const std::string& sessionID);
		     
        //************************************
		// IRadioDirectory Interface Methods *
		//************************************

        /**
         * getGroupSubscribers
         *
         * Retrieves the list of groups known to the radio system.
         *
         * @return A pointer to the list of groups.
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     getGroupSubscribers();

        /**
         * getPatchSubscribers
         *
         * Retrieves the list of patches known to the radio system.
         *
         * @return  A pointer to the list of patches.
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     getPatchSubscribers();

        /**
         * getIndividualSubscribers
         *
         * Retrieves the list of individual subscribers in the system.
         *
         * @return A pointer to subscribers in the system that are individuals.
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     getIndividualSubscribers();

        /**
         * getSubscriberDetails
         *
         * Retrieves the details for a specific subscriber based upon the ITSI number of the subscriber
         *
         * @param TSI the number of the subscriber for which to retrieve the details
         *
         * @return The details of the requested subscriber
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberDetails*  getSubscriberDetails(const std::string& TSI);

        /**
         * getGroupMembers
         *
         * Retrieves the members of a particular group.
         *
         * @param TSI the number of the group for which to retrieve the members
         *
         * @return The members of the specified group
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     getGroupMembers(const std::string& TSI);


        /**
         * getPatchMembers
         *
         * Retrieves the members of a particular patch group.
         *
         * @param TSI the number of the group that "leads" the patch
         *
         * @return The members of the specified patch
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     getPatchMembers(const std::string& TSI);

        /**
         * searchSubscriber
         *
         * Searches the subscriber database and retrieves any subscribers with the search text occuring in 
         * their name.
         *
         * @param searchText the text by which to search the subscriber database
         *
         * @return The list of subscribers matching the 
         */
        virtual TA_Base_Bus::IRadioCorbaDef::SubscriberList*     searchSubscriber(const std::string& searchText);


    private:

		/**
		* Notify subscribers of a change of status to a call in the call stack
		*/
		void sendCallStatusChange();


       /// shared threadlock for the two session server console maps
		TA_Base_Core::ReEntrantThreadLockable   m_sscMapLock;


		RadioCircuitModeManager*                m_radioCircuitModeManager;



		/**
		* Radio session to use for trainborne communication
		*/
		RadioSession*                           m_ISCSRadioSession;
		IRadioCallback&							m_callback;

        IRadioDirectoryCallback*                m_directoryCallback;

		/*
		 * Radio call stack
		 */
		std::vector<TA_IRS_App::CallDetailsType>	m_radioCallStack;
		TA_Base_Core::ReEntrantThreadLockable		m_callStackLock;

        ///
        /// The processor that deals with events that need to be processed off
        /// the main Radio thread
        RadioBackgroundProcessor *              m_backgroundProcessor;
        ///
        /// type definition for an array (a.k.a. vector) of RadioTcpServers
        // TCPSERVER TRANSFER DONE
        typedef std::vector< RadioTcpServer * > RadioTcpServerArray;
		
		
        ///
        /// The array of servers we are connected to. Currently only of
        /// consequence at Central location
        // TCPSERVER TRANSFER DONE
        RadioTcpServerArray                     m_radioTcpServers;


        ///
        /// for quickly determining which session on which server corresponds
        /// to a given console
        ConsoleToSessionServerMap               m_consoleSessionServers;
		
        ///
        ///
        bool                                    m_inFallback;
		bool									m_active; // Indicates if its in control/monitor mode

        ///
        ///
        std::string                             m_fallbackReplacementString;

        //TA_Base_Bus::ItaScada&                  m_scada;

		// Radio agent's asset name for alarm submission
		std::string								m_agentAssetName;

		unsigned long							m_defaultVolume;
		RadioServerLinkStatusUpdateThread*		m_serverLinkStatusThread;
	};

};

#endif // !defined(Radio_CC2C4427_A45B_4f2d_AA2B_8A8DC1714F3B__INCLUDED_)
