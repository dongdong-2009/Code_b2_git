/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioAuthorisationManager.h $
  * @author:  Andy Parker
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  * This class is used to manage radio authorisation requests.
  *
  * We need this to be a thread as we cannot use the incoming radio event (TCP thread)
  * to send synchronous messages to the radio as it will block stopping further TCP
  * receipt, i.e. it will never get its reply!
  */

///////////////////////////////////////////////////////////
//
//  RadioAuthorisationManager.h
//  Implementation of the Class RadioAuthorisationManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(RadioAuthorisationManager_INCLUDED_)
#define RadioAuthorisationManager_INCLUDED_

#include <vector>
#include "core/synchronisation/src/Semaphore.h"
#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/threads/src/Thread.h"
#include "RadioSynchronisationTypes.h"
#include "RadioTypes.h"

#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"


/**
* This class will be used to manage the audio references
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:43:57
*/

namespace TA_IRS_App
{
	class Radio;
    class RadioTcpServer;
	class IRadioCallback;

	class RadioAuthorisationManager : TA_Base_Core::Thread
	{


		public:

			/*
			* Constructor
			*
			* This function adds an audio reference to the list of managed audio connections.
			* @param   radio   Need to access the sendCommand method by the run method.
			*/
			RadioAuthorisationManager(RadioTcpServer & tcpServer);

			virtual ~RadioAuthorisationManager();

		public:

			/**
			* This function adds an incoming CAD request to the stack.
			* @param   SessionRef    indicates the owner session
			* @param   cadRef        reference to the CAD call
			*/
			void addAuthorisationRequest(SessionReference SessionRef,CADReference cadRef);

			/**
			* This function get the current list of authorisation requests.
			* @param   AuthorisationStack    Reference to list to contain details
			*/
			void getAuthorisationList(AuthorisationStack& authorisationList, SessionReference SessionRef);

			/**
			* This function will authorise the specified call.
			* This is performed directly as it will come from a client thread.
			* @param   AuthorisationStack    Reference to list to contain details
			*/
			void authoriseCall(CADReference callID,bool accept,const char* sessionID);

			/**
			* This function will cancel the authorisation request.
			* Proably due to call being hung up before authrisation
			* @param   AuthorisationStack    Reference to list to contain details
			*/
			void cancelRequest(CADReference callID);

			// state synchronisation functions
			void applyFullState(const RadioAuthorisationManagerType& state);
			void clearFullState();
			void getFullState(RadioAuthorisationManagerType& state);
			void updateAuthorisationRequest(const AuthorisationRequestType& request);
			void removeAuthorisationRequest(CADReference callID);

            void sessionLoggedOut(SessionReference sessionRef);

		private:

			/*
			 * Method performing the background work
			 */
			void run();
			
			/*
			 * Stop backgroung processing
			 */
			void terminate();

			/*
			 * Get the CAD details from the radio and update the authorisation stack
			 * notifying any listening clients.
			 */
			void getCADDetails(SessionReference sessionRef, CADReference cadRef);

			/*
			 * Query the radio for information
			 */
			std::string queryResults(unsigned long sessionRef,unsigned long resultRef, 
													RadioMethodQueryReference::EKeys key);
			void sendRemoveAuthorisationRequest(CallID callID);
			void sendUpdateAuthorisationRequest(const AuthorisationRequestType& request);

			//*********************
			// Authorisation list *
			//*********************

			/*
			 * Radio authorisation stack
			 */
			std::vector<TA_IRS_App::AuthorisationRequestType> m_radioAuthorisationStack;
			TA_Base_Core::ReEntrantThreadLockable		m_authorisationStackLock;


			//********************
			// Thread work queue *
			//********************

			TA_Base_Core::ReEntrantThreadLockable    m_workQueueLock;
			TA_Base_Core::Semaphore					m_workQueueSemaphore;

			enum EWorkRequestType { ADD_AUTHORIATION_REQUEST };
			struct WorkRequestEntry
			{
				EWorkRequestType   request;
				SessionReference   sessionRef;
				CADReference       CADRef;
			};

			std::vector<WorkRequestEntry>   m_workQueue;
			bool                            m_terminate;

			//*************************
			// Access to parent class *
			//*************************
            RadioTcpServer                & m_tcpServer;

	};
}


#endif // !defined(RadioAuthorisationManager_INCLUDED_)
