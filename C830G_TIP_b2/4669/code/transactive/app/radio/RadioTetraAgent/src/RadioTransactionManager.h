/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File$
  * @author:  Ripple
  * @version: $Revision$
  *
  * Last modification: $DateTime$
  * Last modified by:  $Author$
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioTransactionManager.h
//  Implementation of the Class RadioTransactionManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:45:42
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(RadioTransactionManager_6AFBAC62_0686_4786_8502_FC252901F286__INCLUDED_)
#define RadioTransactionManager_6AFBAC62_0686_4786_8502_FC252901F286__INCLUDED_

/**
* This classes manages the method calls that are waiting for a reply (event) from
* the radio system.
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:45:42
*/

#include <vector>
#include "core/threads/src/Thread.h"
#include "core/synchronisation/src/ReEntrantThreadLockable.h"

namespace TA_Base_Core
{
	class TimedWaitSemaphore;
}

namespace TA_IRS_App
{
	class RadioEvent;

	class RadioTransactionManager : public virtual TA_Base_Core::Thread
	{

	public:
		RadioTransactionManager();
		virtual ~RadioTransactionManager();

	public:

		/**
		* This method returns a new transaction ID that will be used for a radio method call.  
		* Using a unique transaction ID enables methods to be associated with their resulting events.
		*/
		unsigned long getNewTransactionID();

		
		unsigned long getNewTransactionIdNoWait ();

		/**
		* This method will cause the thread to block until the specified transaction event is received
		*/
		RadioEvent* waitForEvent(unsigned long TransactionID);

		/*
		* waitListDeleteTransaction
		*
		* Delete a transaction from the list
		*/
		void waitListDeleteTransaction(unsigned long transactionID);

		
		/**
		* This method will enable the timeout to be specified for waiting
		* 0 is indefinite wait!
		*/	
		void setWaitTimeout(unsigned long milliSecs);


		/**
		* This will be used by the Radio class to notify the manager of an incoming event.
		* @param    event
		* @returns  bool - True if event was processed.
		*/
		bool receivedEvent(const RadioEvent& event);

		//***************************
		// Thread Interface Methods *
		//***************************

		/*
		* run
		*
		* This method is called by the thread start method to perform the actual monitoring
		* of the waiting transactions.  Do not call directly!
		*/
		void run();

		// The terminate() method should cause run() to return. eg:
		// CorbaUtil::GetInstance().Shutdown() or EndDialog(m_dialog)
		//
		// NOTE: probably not a good idea to call this method directly - call
		//       terminateAndWait() instead
		void terminate();

        /**
         * When a connection ends, no more solicited events can be expected,
         * so release threads waiting on them
         */
        void releaseAllTransactions();

	private:

		//***********************************
		// Wait list manipulation functions *
		//***********************************

		/*
		* waitListCheck
		*
		* Check the wait list for any transactions that should be timed out
		*/
		void waitListCheck();

		/*
		* waitListNewTransaction
		*
		* Add a new transaction to the wait list
		*/
		void waitListNewTransaction(unsigned long transactionID);

		/*
		* waitListSignalTransaction
		*
		* Signal a transaction in the list
		*/
		bool waitListSignalTransaction(unsigned long transactionID,RadioEvent* event);

		/*
		* waitListDeleteTransaction
		*
		* Delete a transaction from the list
		*/
	//	void waitListDeleteTransaction(unsigned long transactionID); bihui 28/06/2011 change to public

		/*
		* waitListGetSemaphore
		*
		* Get a semaphore associated with a transaction from the list
		*/
		TA_Base_Core::TimedWaitSemaphore* waitListGetSemaphore(unsigned long transactionID);

		unsigned long waitListGetElapsedTime(unsigned long transactionID);

		/*
		* waitListGetEvent
		*
		* Get a event associated with a transaction from the list
		*/
		RadioEvent* waitListGetEvent(unsigned long transactionID);

	private:

		typedef struct
		{
			unsigned long						transactionID;
			TA_Base_Core::TimedWaitSemaphore*	waitSemaphore;
			RadioEvent*							incomingEvent;
			unsigned long						elapseMilliSecs;
			bool								sessionWaiting;
		} TransactionEntry;

		/**
		* The long is the transactionID and the semaphore is used to signal the waiting process.
		*/
		std::vector<TransactionEntry> m_waitList;
		TA_Base_Core::ReEntrantThreadLockable   m_waitListGuard;

		unsigned long		      m_nextTransactionID;
		TA_Base_Core::ReEntrantThreadLockable   m_transactionCounterGuard;

		unsigned long             m_waitTimeout;

		/**
		* This indicates if timeout monitoring should be stopped
		*/
		bool m_monitorTimeout;
		
	};
};

#endif // !defined(RadioTransactionManager_6AFBAC62_0686_4786_8502_FC252901F286__INCLUDED_)
