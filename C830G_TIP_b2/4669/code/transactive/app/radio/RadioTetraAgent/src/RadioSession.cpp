///////////////////////////////////////////////////////////
//
//  RadioSession.cpp
//  Implementation of the Class RadioSession
//  Generated by Enterprise Architect
//  Created on:      30-Oct-2003 08:20:31
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#ifdef __WIN32__
#pragma warning(disable:4786)
#endif
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/utilities/src/RunParams.h"
#include "core/exceptions/src/DatabaseException.h"
#include "core/exceptions/src/DataException.h"
#include "core/data_access_interface/entity_access/src/RadioGlobalEntityData.h"
#include "core/data_access_interface/src/LocationAccessFactory.h"//TD19783
#include "bus/security/authentication_library/src/AuthenticationLibrary.h"
#include "bus/security/authentication_library/src/SessionInfo.h"
#include "app/radio/RadioTetraAgent/src/Radio.h"
#include "app/radio/RadioTetraAgent/src/RadioHelper.h"
#include "app/radio/RadioTetraAgent/src/RadioSession.h"
#include "app/radio/RadioTetraAgent/src/RadioTcpServer.h"
#include "app/radio/RadioTetraAgent/src/IRadioCallback.h"
#include "app/radio/RadioTetraAgent/src/RadioTaskFactory.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionHelper.h"
#include "app/radio/RadioTetraAgent/src/IRadioSessionServant.h"
#include "app/radio/RadioTetraAgent/src/CallForwardingDetails.h"
#include "app/radio/RadioTetraAgent/src/RadioSubscriberMonitor.h"
#include "app/radio/RadioTetraAgent/src/RadioResourceManager.h"
#include "app/radio/RadioTetraAgent/src/RadioAuthorisationManager.h"
#include "app/radio/RadioTetraAgent/src/RadioStateUpdateBroadcaster.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionInitialisationThread.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionNotInitialisedException.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionException.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocol.h"
#include "app/radio/RadioTetraAgent/src/RadioHelper.h"


bool isPresent(std::string text, std::vector<std::string> textList);
using namespace TA_IRS_App;


using TA_Base_Core::DebugUtil;

RadioSession::RadioSession(std::string entityName,
                           IRadioSessionServant& radioSessionServant,
						   RadioTcpServer& radio,
						   unsigned int audioLink,
						   std::string autoLoginName,
                           TA_IRS_App::ConsoleID consoleID,
						   unsigned long switchUserWaitPeriod,
                           TA_Base_Core::RadioGlobalEntityData& globalEntityData,
                           //TA_Base_Bus::ItaScada& itaScada,
						   bool isISCS)
             : m_radioTcpServer(radio), 
			   m_audioLink(audioLink),
			   m_radioSessionInitialisationThread(0),
			   m_sessionRef(InternalUnassignedReference),
			   m_sessionEntityName(entityName),
			   m_radioSessionServant(radioSessionServant),
			   m_loginName(autoLoginName),
               m_loginPassword(""),
               m_subscriberTextRef(""),
			   m_sessionDGNAITSI(""),
			   m_sessionDGNAInUse(false),
			   m_sessionStatus(SessionUnassigned),
               m_sessionITSI(""),
               m_switchNotReachable(false),
               m_gwldLinkLost(false),
               m_consoleID(consoleID),
			   m_switchUserWaitPeriod(switchUserWaitPeriod),
               m_DefaultEmergencyCallPriority(Priority15),
               m_DefaultNormalCallPriority(Priority1),
               m_connectionEstablished(false),
               m_callForwardingDetails(0),
			   m_isISCS(isISCS),
			   m_currentGXType(SessionStatusOK),
			   m_lastUpdateTime(0)
{
	FUNCTION_ENTRY("Constructor");
                   
    m_loginPassword = m_loginName;

	onSessionStatusChange(SessionNotLogin);

    // password must be 6 characters
    while (m_loginName.size() > 0 && m_loginPassword.size() < 6)
    {
        m_loginPassword += m_loginName;//TD19664
    }

    try
    {    
        m_DefaultEmergencyCallPriority = static_cast<TA_IRS_App::ECallPriority>(globalEntityData.getEmergencyCallPriority());
        m_DefaultNormalCallPriority = static_cast<TA_IRS_App::ECallPriority>(globalEntityData.getNormalCallPriority());            
    }
    catch ( const TA_Base_Core::DatabaseException& e )
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::ExceptionCatch, "TA_Base_Core::DatabaseException", e.what() );
    }
    catch ( const TA_Base_Core::DataException& e )
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::ExceptionCatch, "TA_Base_Core::DataException", e.what() );
    }


    // Start the initialisation thread
	m_radioSessionInitialisationThread = new RadioSessionInitialisationThread(*this);
    
    start();

	FUNCTION_EXIT;
}
RadioSession::~RadioSession()
{
	FUNCTION_ENTRY("Destructor");

    stop();
    
    delete m_radioSessionInitialisationThread;



	FUNCTION_EXIT;
}

std::string RadioSession::getSessionEntityName()
{
    return m_sessionEntityName;
}

unsigned long RadioSession::getSessionEntityKey()
{
	return m_radioSessionServant.getEntityKey();
}


bool RadioSession::doAttachSession(std::pair<SessionReference,SessionReference>& sessionreferences)
{
	FUNCTION_ENTRY("doAttachSession");

	bool result = false;
    SessionReference previousSessionRef = m_sessionRef;

	// Step 1. Attach session
	if (m_sessionStatus == SessionUnassigned)
	{
		try
		{
			RadioMethodAttachSession   attachSession;

			RadioEvent * reply = sendMethod(attachSession);

			// Check the event is an attach session reply - it should be as the transaction id is set

			// Get the session id.
			m_sessionRef = reply->getSessionRef();

			delete reply;

			m_sessionStatus = SessionAssigned;

			onSessionStatusChange(SessionNotLogin);

			result = true;

		}
		catch (...)
		{
			// Advise parent class of this problem
			m_radioSessionServant.onSessionInitialisationFailure();
		}
	}
	else if ( m_sessionStatus == SessionAssigned )
	{
		result = true;
	}

	sendStateUpdate();

    sessionreferences.first = previousSessionRef;
	sessionreferences.second = m_sessionRef;

	FUNCTION_EXIT;
    return result;
}

bool RadioSession::shouldLogIn()
{
	bool isRadioActive = m_radioTcpServer.getRadio().getIsActive();
	LOG_GENERIC (SourceInfo, TA_Base_Core::DebugUtil::DebugTrace, 
		"[shouldAttemptLogin] m_connectionEstablished = %d, isRadioActive = %d, m_sessionStatus = %d.", m_connectionEstablished, isRadioActive, m_sessionStatus);
    return (m_connectionEstablished && isRadioActive);
}


void RadioSession::start()
{
    m_radioSessionInitialisationThread->start();
}

void RadioSession::stop()
{
    m_radioSessionInitialisationThread->terminateAndWait();
}



std::string RadioSession::getSubscriberName(const std::string & tsi)
{
    FUNCTION_ENTRY("getSubscriberName()");

    checkRadioFallback();

    std::string subscriberName = "";
    std::string searchCriteria = "TSI='" + tsi + "'";
    unsigned long searchResultRef = performSubscriberSearch("TSI='" + tsi + "'", RadioMethodSearchSubscribers::NORMAL);
    // Need to get our subscriber textual reference
    std::string subscriberTextRef = queryResults(searchResultRef, RadioMethodQueryReference::K_MEMBERS);
    if (subscriberTextRef.empty())
    {
        TA_THROW(RadioSessionException("Subscriber text reference not defined.", STATUS_KO_SUBSCRIBER_NOT_FOUND));
    }
    // WAS:
    // TA_ASSERT(subscriberTextRef.size()>0,"Subscriber text reference not defined.");

    // Before using this text reference need to delete the previous search reference (don't need it any more)
    deleteReference(searchResultRef,RadioMethodDeleteReference::SEARCH_REFERENCE);

    // 
    unsigned long subscriberRef = convertTextToSubscriberReference(subscriberTextRef);

    //
    subscriberName = queryResults(subscriberRef, RadioMethodQueryReference::K_NAME);

    FUNCTION_EXIT;
    return subscriberName;
}

std::string RadioSession::getSessionTSI()
{
    FUNCTION_ENTRY("getSessionTSI");
    if (m_sessionITSI.empty())
    {
        m_sessionITSI = queryResults(getValidSessionRef(), RadioMethodQueryReference::K_TSI);
        LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"First time session TSI requested. RCS queried, ITSI=\"%s\"", m_sessionITSI.c_str());
    }
	FUNCTION_EXIT;
    return m_sessionITSI;
}

void RadioSession::updateRadioSession(const RadioSessionType& radioSessionData)
{
    FUNCTION_ENTRY("updateRadioSession");
	this->m_audioLink = radioSessionData.audioLink;
	this->m_loginName = radioSessionData.loginName;
    this->m_loginPassword = radioSessionData.loginPassword;
	this->m_sessionDGNAInUse = radioSessionData.sessionDGNAInUse;
	this->m_sessionDGNAITSI = radioSessionData.sessionDGNAITSI;
	this->m_sessionEntityName = radioSessionData.sessionEntityName;
	this->m_sessionITSI = radioSessionData.sessionITSI;
	this->m_sessionRef = radioSessionData.sessionRef;

	// TD9016 - add more log info
	std::ostringstream data;
	data << "[UPDATE] SessionEntityName = " << this->m_sessionEntityName
	     << " Old SessionRef = " << this->m_sessionRef
	     << " New SessionRef = " << radioSessionData.sessionRef;

	switch (radioSessionData.sessionStatus)
	{
	case TA_IRS_App::SessionUnassigned:
		this->m_sessionStatus = SessionUnassigned;
		data << " Status = SessionUnassigned";
		break;
	case TA_IRS_App::SessionAssigned:
		this->m_sessionStatus = SessionAssigned;
		data << " Status = SessionAssigned";
		break;
	case TA_IRS_App::SessionInitialised:
		this->m_sessionStatus = SessionInitialised;
		data << " Status = SessionInitialised";
		break;
	case TA_IRS_App::SessionLoggedIn:
		this->m_sessionStatus = SessionLoggedIn;
		data << " Status = SessionLoggedIn";
		break;
	}

	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, data.str().c_str());

	this->m_subscriberTextRef = radioSessionData.subscriberTextRef;
	FUNCTION_EXIT;
}

void RadioSession::clearFullState()
{
    FUNCTION_ENTRY("clearFullState");
	// m_audioLink no need to clear
	m_sessionRef = 0;
    // m_sessionEntityName no need to clear
    m_loginName = "";
    m_loginPassword = "";
    m_subscriberTextRef = "";
	m_sessionDGNAITSI = "";
	m_sessionDGNAInUse = false;
    m_sessionStatus = SessionUnassigned;

	onSessionStatusChange(SessionNotLogin);

    m_sessionITSI = "";
   
    
	FUNCTION_EXIT;
}

void RadioSession::applyFullState(const RadioSessionType& state)
{
    FUNCTION_ENTRY("applyFullState");
	updateRadioSession(state);
	FUNCTION_EXIT;
}

void RadioSession::getFullState(RadioSessionType& state)
{
    FUNCTION_ENTRY("getFullState");
	getRadioSessionData(state);
	FUNCTION_EXIT;
}

void RadioSession::setSwitchNotReachable(bool isNotReachable)
{
    FUNCTION_ENTRY("setSwitchNotReachable");
    m_switchNotReachable = isNotReachable;
	FUNCTION_EXIT;
}

bool RadioSession::getSwitchNotReachable() const
{
    FUNCTION_ENTRY("getSwitchNotReachable");
    return m_switchNotReachable;
	FUNCTION_EXIT;
}


/*
 * This function will return a search result reference for a specified search
 *
 * Remember to free the new search reference when you have finished with it!
 */
unsigned long RadioSession::performSubscriberSearch(std::string searchCriteria,
													RadioMethodSearchSubscribers::EView view /* =NORMAL*/)
{
	FUNCTION_ENTRY("performSubscriberSearch");

    checkRadioFallback();

	// Search for the groups to be patched
    RadioMethodSearchSubscribers searchSubscriberMethod(getValidSessionRef());
    searchSubscriberMethod.setSearchType(view);
    searchSubscriberMethod.setCriteria(searchCriteria);
    RadioEvent* reply = sendMethod(searchSubscriberMethod);

    // The reply will be a reference to a result set (i.e. not the actual results we want)
    SearchSubscribersEventReader searchSubscriberReader(*reply);
    unsigned long searchResultSet = searchSubscriberReader.getSubscriberReferenceResultSet();

    // Delete the reply event
    delete reply;
    reply = NULL;

	FUNCTION_EXIT;
	return searchResultSet;
}

/*
 * Query the details from a reference.
 */
std::vector<std::string> RadioSession::queryResultsAsList(unsigned long resultRef, RadioMethodQueryReference::EKeys key)
{
	FUNCTION_ENTRY("queryResults");

	// Need to perform a query reference on the operator's session reference.
	RadioMethodQueryReference queryReferenceMethod(getValidSessionRef());
    queryReferenceMethod.setQueryType(key);
	queryReferenceMethod.setQueryReference(resultRef);
	RadioEvent* reply = sendMethod(queryReferenceMethod);

    // The reply should have the ITSI for the current session
    QueryReferenceEventReader queryReferencereader(*reply);
    std::vector<std::string> resultList = queryReferencereader.getDetailsList('\n');

    // Delete the reply
    delete reply;
    reply = NULL;

	FUNCTION_EXIT;
	return resultList;
}

/*
 * Query the details from a reference.
 */
std::string RadioSession::queryResults(unsigned long resultRef, RadioMethodQueryReference::EKeys key)
{
	FUNCTION_ENTRY("queryResults");

	// Need to perform a query reference on the operator's session reference.
	RadioMethodQueryReference queryReferenceMethod(getValidSessionRef());
    queryReferenceMethod.setQueryType(key);
	queryReferenceMethod.setQueryReference(resultRef);
	RadioEvent* reply = sendMethod(queryReferenceMethod);

    // The reply should have the ITSI for the current session
    QueryReferenceEventReader queryReferencereader(*reply);
    std::string resultText = queryReferencereader.getDetails();

    // Delete the reply
    delete reply;
    reply = NULL;

	FUNCTION_EXIT;
	return resultText;
}

RadioReference RadioSession::getNewReference(RadioMethodNewReference::ReferenceType referenceType)
{
	FUNCTION_ENTRY("getNewReference");

	if (!isLoggedIn())
    {
        TA_THROW( RadioSessionException("Session not initialised and logged in", STATUS_KO_NOT_LOGGED) );
    }

	RadioMethodNewReference						method(m_sessionRef,referenceType);
	RadioEvent*									replyEvent;
	RadioReference		reference;

	replyEvent = m_radioTcpServer.sendMethod(method);
	NewReferenceEventReader* reader = dynamic_cast<NewReferenceEventReader*>(replyEvent->getEventReader());
	TA_ASSERT(reader!=NULL,"Incorrect reply type for New Reference Method.");
	reference = reader->getReference();
	delete replyEvent;

	FUNCTION_EXIT;
	return reference;
}

// Release a reference when it is no longer required
void RadioSession::deleteReference(RadioReference reference,RadioMethodDeleteReference::ReferenceType refType)
{
    FUNCTION_ENTRY("deleteReference");

    RadioMethodDeleteReference deleteReferenceMethod(getValidSessionRef());
    deleteReferenceMethod.setReference(refType,reference);
    RadioEvent* reply = sendMethod(deleteReferenceMethod);
    
    // The reply is for error checking only.
    //DeleteReferenceEventReader deleteReferenceReader(*reply);
    //if (deleteReferenceReader.getReference() != reference)
    //{
    //    LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,"Reply to delete reference was incorrect. Expected %lu, got %lu",
    //        reference,deleteReferenceReader.getReference());
    //}

	delete reply;

    FUNCTION_EXIT;
}


void RadioSession::queryAllCallDetails(unsigned long callRef, QueryKeyValueMap & callValues)
{
    FUNCTION_ENTRY("getAllCallDetails()");

    // Need to perform a query reference on the operator's session reference.
    RadioMethodQueryReference queryReferenceMethod(getValidSessionRef());
    queryReferenceMethod.setQueryType(RadioMethodQueryReference::K_KEY_ALL_DATACALL);
    queryReferenceMethod.setQueryReference(callRef);
    RadioEvent * reply = sendMethod(queryReferenceMethod);

    // The reply should have the ITSI for the current session
    QueryReferenceEventReader queryReferencereader(*reply);
    /* int numValues = */ queryReferencereader.getDetailsKeyValueMap(callValues);

    // Delete the reply
    delete reply;

    FUNCTION_EXIT;
}

int RadioSession::attachToGroups()
{
    FUNCTION_ENTRY("attachToGroups()");

    // don't checkInFallback(), we don't handle the exception thrown either here or above
    if (m_radioTcpServer.inFallback())
    {
        return 0;
    }

    // Demonstration of standard vectorial query techniques
    // fetch our TSI
    std::string sessionITSI = getSessionTSI();
    // use it to query for all groups we are a member of
    std::string queryStr = "MEMBER='" + sessionITSI + "'";
    // returns a search result...
    unsigned long groupResultSet = performSubscriberSearch(queryStr, RadioMethodSearchSubscribers::K_PARENTS);
    // ...which is used to return a list of Group TextReferences
    std::vector<std::string> groupTextRefs = queryResultsAsList(groupResultSet, RadioMethodQueryReference::K_MEMBERS);
    // (delete the search result reference)
    deleteReference(groupResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

    int groupsAttached=0;
    // Now, with those groups, perform an AttachToGroup for each
    for ( std::vector<std::string>::iterator giter = groupTextRefs.begin() ;
            giter != groupTextRefs.end() ;
            giter++ )
    {
        // convert each group text ref into a group proprietary/binary subscriber reference
        const std::string & groupTextRef = *giter;
        long int groupRef = convertTextToSubscriberReference(groupTextRef);
        // and get that group's TSI for use in the AttachToGroup method
        std::string groupTSI = queryResults(groupRef, RadioMethodQueryReference::K_TSI);

        try
        {
            RadioMethodAttachToGroup a2gMethod(m_sessionRef, groupTSI.c_str());
            RadioEvent * a2gEvent = sendMethod(a2gMethod);
            delete a2gEvent;
            groupsAttached++;
        }
        catch (RadioException rse)
        {
            // not really worried enough about failing to attach that we'd
            // really want to die here, so we just complain
            LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn,
                 "Failed to AttachToGroup \"%s\": %s", groupTSI.c_str(), rse.what());
        }
    } // for each groupTextRef

    FUNCTION_EXIT;
    return groupsAttached;
} // RadioSession::attachToGroups()


void RadioSession::relogin()
{
    FUNCTION_ENTRY("relogin");

	if (!m_radioTcpServer.getRadio().getIsActive())
	{
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,"Agent in monitor mode. No need to relogin. %s",m_sessionEntityName.c_str() );
		FUNCTION_EXIT;
		return;
	}

    reset();

	initialiseSession();

	sendStateUpdate();

	FUNCTION_EXIT;
}

void RadioSession::reset()
{
    FUNCTION_ENTRY("reset");

	if (!m_radioTcpServer.getRadio().getIsActive())
	{
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,"Agent in monitor mode. No need to reset." );
		FUNCTION_EXIT;
		return;
	}

    if (m_sessionStatus==SessionLoggedIn)
    {
        m_radioTcpServer.sessionLoggedOut(m_sessionRef);
    }

    // m_radioTcpServer = UNCHANGED
    // m_audioLink = UNCHANGED
    // m_sessionRef = KEEP FOR NOTIFICATION, obsolete
    // m_sessionEntityName = UNCHANGED
    // m_radioSessionServant = UNCHANGED
    // m_loginName = UNCHANGED, required for re-login

    m_subscriberTextRef = "";
    m_sessionDGNAITSI = "";
    m_sessionDGNAInUse = false;
    m_sessionStatus = SessionUnassigned;
    m_sessionITSI = "";
    m_switchNotReachable = false;
    m_gwldLinkLost = false;
    
	onSessionStatusChange( SessionNotLogin );

	sendStateUpdate();

	FUNCTION_EXIT;
}

void RadioSession::getRadioSessionData(RadioSessionType& radioSessionData)
{
    FUNCTION_ENTRY("getRadioSessionData");
	radioSessionData.audioLink = this->m_audioLink;
	radioSessionData.loginName = this->m_loginName;
    radioSessionData.loginPassword = this->m_loginPassword;
	radioSessionData.sessionDGNAInUse = this->m_sessionDGNAInUse;
	radioSessionData.sessionDGNAITSI = this->m_sessionDGNAITSI;
	radioSessionData.sessionEntityName = this->m_sessionEntityName;
	radioSessionData.sessionITSI = this->m_sessionITSI;
	radioSessionData.sessionRef = this->m_sessionRef;

	switch (this->m_sessionStatus)
	{
	case TA_IRS_App::RadioSession::SessionUnassigned:
		radioSessionData.sessionStatus = TA_IRS_App::SessionUnassigned;
		break;
	case TA_IRS_App::RadioSession::SessionAssigned:
		radioSessionData.sessionStatus = TA_IRS_App::SessionAssigned;
		break;
	case TA_IRS_App::RadioSession::SessionInitialised:
		radioSessionData.sessionStatus = TA_IRS_App::SessionInitialised;
		break;
	case TA_IRS_App::RadioSession::SessionLoggedIn:
		radioSessionData.sessionStatus = TA_IRS_App::SessionLoggedIn;
		break;
	}

	radioSessionData.subscriberTextRef = this->m_subscriberTextRef;
	FUNCTION_EXIT;
}

void RadioSession::sendStateUpdate()
{
    FUNCTION_ENTRY("sendStateUpdate");
	RadioUpdateRadioSession message;
	
	getRadioSessionData(message.radioSession);
	message.servantEntityKey = this->m_radioSessionServant.getEntityKey();
	
	RadioStateUpdateBroadcaster::getInstance()->sendRadioUpdateRadioSession(message);
	FUNCTION_EXIT;
}


void RadioSession::loginSession(const std::string& loginName, const std::string& password)
{
    FUNCTION_ENTRY("loginSession");
    
    // Warn if the new login name doesn't match the original
    // (supposing there WAS an original)
    if ((!m_loginName.empty()) && (m_loginName != loginName))
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugWarn, 
             "new login name (%s) does not match previous (%s)",loginName.c_str(),m_loginName.c_str());

		unsigned long waitPeriod = 5000;
		if (m_switchUserWaitPeriod > 0)
		{
			waitPeriod = m_switchUserWaitPeriod;
		}

		if ( isLoggedIn() )
		{
			m_radioSessionInitialisationThread->processSessionInit( RadioSessionInitialisationThread::LogoutSession );
		}

		m_condition.timedWait(waitPeriod);
    }
    
    m_loginName = loginName;
    
    if (password.empty())
    {
        m_loginPassword = loginName;
    }
    else
    {
        m_loginPassword = password;
    }
    
    // password must be 6 characters
    while (m_loginName.size() > 0 && m_loginPassword.size() < 6)
    {
        m_loginPassword += m_loginName;//TD19664
    }
    
    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
         "login() - loginName:%s loginPasswd:%s",m_loginName.c_str(),m_loginPassword.c_str());
	
    // trigger login in the initialisation thread
    m_radioSessionInitialisationThread->processSessionInit(RadioSessionInitialisationThread::InitialiseSession);
    
	FUNCTION_EXIT;
}

//TD 10234
long RadioSession::makeCall(const std::string & destTSI,ECallType callType,bool isFullDuplex, TA_IRS_App::ECallPriority priority,bool hook,std::string sessionId, bool isInvisibleToGUIApps, long locationKey)// //TD19783
{
	FUNCTION_ENTRY("makeCall");

	RadioMethodSetupCall::ECallType type;
	ECallCategory  category;
	switch (callType)
	{
		case SingleCall:
			 type = RadioMethodSetupCall::SINGLE_CALL;
			 category = isFullDuplex?FullDuplex:HalfDuplex;
			 break;
		case GroupUnacknowledgeCall: 
			 type = RadioMethodSetupCall::GROUP_UNACKNOWLEDGE;
			 category = HalfDuplex;
			 break;
		case GroupAcknowledgeCall: 
			 type = RadioMethodSetupCall::GROUP_ACKNOWLEDGE;
			 category = HalfDuplex;
			 break;
		case GroupBroadcastCall: 
			 type = RadioMethodSetupCall::BROADCAST;
			 category = HalfDuplex;
			 break;

		default:
			TA_ASSERT(false,"Invalid call type.");
	};

	// Get a new call reference (to be deleted when the call disconnects)
	RadioReference callReference;
	callReference = getNewReference(RadioMethodNewReference::CALL_REFERENCE);

	// Setup the call (note we might get an unsolicited CallStatus event in addition to the Setup call event)
	RadioMethodSetupCall   setupMethod(getValidSessionRef(),callReference);
	setupMethod.setCallDestination(destTSI);
	setupMethod.setCallType(type);
	setupMethod.setFullDuplex(isFullDuplex);

    //TD14696
    //setupMethod.setCallPriority(isEmergency?RadioMethodSetupCall::EmergencyPriority:RadioMethodSetupCall::LowPriority);              
    if  (priority == DefaultNormalPriority) 
    {
        setupMethod.setCallPriority(m_DefaultNormalCallPriority);
    }
    else if (priority == DefaultEmergencyPriority) 
    {
        setupMethod.setCallPriority(m_DefaultEmergencyCallPriority);
    }
    else
    {
        setupMethod.setCallPriority(priority); 
    }    
    //

    setupMethod.setHookBit( hook );
    if ( (callType==SingleCall) && (!isFullDuplex) )
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "SingleCall HalfDuplex request detected - activating REQUEST_TX" );
        setupMethod.setRequestTx(RadioMethodSetupCall::REQUEST_TX);
    }
    
	RadioEvent* reply = sendMethod(setupMethod);
	delete reply;

    // Attach some audio to the call
    // VoiceRecorder data submitted further down
    m_radioTcpServer.getRadioResourceManager().attachAudio(getValidSessionRef(),callReference);

	// Add a new call to the stack
	CallDetailsType details;
	// CallDetailsType  details;

	details.callStatus   = Connected;
	details.callSource   = OutgoingCall;
	details.callCategory = category;  
    details.callType     = callType;
	// details.callTime     = getCurrentTime();  // set by radio

	// Get the call details from the event
	details.callID     = callReference;
	details.sessionRef = getValidSessionRef();
	details.calledTSI  = destTSI;
	details.callerTSI  = getSessionTSI();

	details.isEmergency= false;
	if (priority == DefaultEmergencyPriority)
    {
		details.isEmergency= true;
    }

	//TD 10234
    details.isInvisibleToGUIApps = isInvisibleToGUIApps;
	if (locationKey != 0)//TD19783
	{
		details.callerLocation =  TA_Base_Core::LocationAccessFactory::getInstance().getLocationByKey( locationKey )->getName() ;
	}
    // add call to call stack before doing any more queries
    if (callType != GroupAcknowledgeCall)
    {
        // This both looks up the caller/called details and adds to the callstack
        m_radioTcpServer.addBackgroundTask(RadioTaskFactory::createCallStackUpdateTask(&m_radioTcpServer, details, m_DefaultEmergencyCallPriority));
    }
    else
    {
        // must wait for a suitable GroupCallAck event before proceeding...
        m_radioTcpServer.addPendingGroupCallAck(details);
    }


	return callReference;

	FUNCTION_EXIT;
}


void RadioSession::sendTextMessage(const std::string & destTSI,std::string message,std::string sessionId)
{
	FUNCTION_ENTRY("sendTextMessage");

	std::vector<unsigned char>   messageVect;
	for (unsigned int iLoop=0;iLoop<message.size();iLoop++)
	{
		messageVect.push_back(message.at(iLoop));
	}

	sendTextDataMessage(destTSI,messageVect);

	FUNCTION_EXIT;
}

/** 
  * RadioSession::sendTextDataMessage
  *
  * This method is used to send a data SDS (Typically a train message)
  *
  * @param destTSI    - Destination for message
  * @param message    - Message data
  * @param sessionId  - session sending the message
  *
  */
void RadioSession::sendTextDataMessage(const std::string &destTSI,std::vector<unsigned char> message)
{
	FUNCTION_ENTRY("sendTextDataMessage");

	// Get a new call reference (to be deleted when the call disconnects)
	NewReferenceEventReader::RadioReference   reference;
	reference = getNewReference(RadioMethodNewReference::SDS_REFERENCE);

	// Send the message
	RadioMethodSendSDS   sendSDSMethod(getValidSessionRef(),reference);
	sendSDSMethod.setDestination(destTSI);
	sendSDSMethod.setMessage(message);
	RadioEvent* reply = sendMethod(sendSDSMethod);
	delete reply;

	// Release the SDS Reference
	deleteReference(reference,RadioMethodDeleteReference::SDS_REFERENCE);

	FUNCTION_EXIT;
}

std::string RadioSession::makeDynamicGroup(std::vector<std::string> destTSIs, std::string sessionId)
{
	FUNCTION_ENTRY("makeDynamicGroup");

    checkRadioFallback();

	unsigned int iLoop;

	// Get the textual references for the destTSI's
	std::string destSearchText = "";
	for (iLoop=0;iLoop<destTSIs.size();iLoop++)
	{
		if (iLoop!=0) destSearchText += " OR ";
		destSearchText += "TSI='" + destTSIs.at(iLoop) + "'";
	}
	unsigned long referenceResultSet = performSubscriberSearch(destSearchText);
	std::vector<std::string> destinationTextReferences = queryResultsAsList(referenceResultSet,RadioMethodQueryReference::K_MEMBERS);
	deleteReference(referenceResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

	// Get the DGNA reference
	referenceResultSet = performSubscriberSearch("TSI='" + m_sessionDGNAITSI + "'");
    std::string dgnaTextRef = queryResults(referenceResultSet,RadioMethodQueryReference::K_MEMBERS);
	deleteReference(referenceResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);
	unsigned long dgnaRef = convertTextToSubscriberReference(dgnaTextRef);

	// Query current subscribers in dgna
	unsigned long groupResultSet = performSubscriberSearch("PARENT='" + m_sessionDGNAITSI + "'"
		                                                   ,RadioMethodSearchSubscribers::K_MEMBERS);
	std::vector<std::string> dgnaSubscribersTextRef = queryResultsAsList(groupResultSet,RadioMethodQueryReference::K_MEMBERS);
	deleteReference(groupResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

	bool isSubcsribersChanged = false;


	// Determine the subscribers to remove
	std::string changeText = "";
	for (iLoop=0;iLoop<dgnaSubscribersTextRef.size();iLoop++)
	{
		// Check if this subscriber is in the new dest TSI list
		if (dgnaSubscribersTextRef.at(iLoop).empty()) continue;
		if (!isPresent(dgnaSubscribersTextRef.at(iLoop),destinationTextReferences))
		{
			// No, so make sure we delete it
			if (changeText.size()>0) changeText += ",";
			changeText += "-" + dgnaSubscribersTextRef.at(iLoop);
		}
	}

	// Add any additional subscribers
	for (iLoop=0;iLoop<destinationTextReferences.size();iLoop++)
	{
		// Check if this subscriber is not in the existing dest TSI list
		if (destinationTextReferences.at(iLoop).empty()) continue;		
		if (!isPresent(destinationTextReferences.at(iLoop),dgnaSubscribersTextRef))
		{
			// No, so make sure we add it
			if (changeText.size()>0) changeText += ",";
			changeText += "+" + destinationTextReferences.at(iLoop);
			isSubcsribersChanged = true;
		}
	}

	// We have to check if there are changes in subscribers because
	// it will give us an error (-12) if we do a changereference and no changes in the subcribers.
	if (isSubcsribersChanged)
	{
		// Update the subscriber record
		RadioMethodChangeReference changeReferenceMethod(getValidSessionRef(),dgnaRef);
		changeReferenceMethod.setGroupMembers(changeText);
		RadioEvent* reply = sendMethod(changeReferenceMethod);
		delete reply;
		reply = NULL;
	}

	// release the reference
	//deleteReference(dgnaRef,RadioMethodDeleteReference::SUBSCRIBER_REFERENCE);

	FUNCTION_EXIT;
	return m_sessionDGNAITSI;
}

bool isPresent(std::string text, std::vector<std::string> textList)
{
    FUNCTION_ENTRY("isPresent");
	for (unsigned int iLoop=0;iLoop<textList.size();iLoop++)
	{
		if (text==textList.at(iLoop)) return true;
	}

	FUNCTION_EXIT;
	return false;
}

void RadioSession::deassignDynamicGroup()
{
	FUNCTION_ENTRY("deassignDynamicGroup()");

    checkRadioFallback();

	// Get the DGNA reference
	unsigned long referenceResultSet = performSubscriberSearch("TSI='" + m_sessionDGNAITSI + "'");
    std::string dgnaTextRef = queryResults(referenceResultSet,RadioMethodQueryReference::K_MEMBERS);
	deleteReference(referenceResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);
	unsigned long dgnaRef = convertTextToSubscriberReference(dgnaTextRef);

	// Query current subscribers in dgna
	unsigned long groupResultSet = performSubscriberSearch("PARENT='" + m_sessionDGNAITSI + "'"
		                                                   ,RadioMethodSearchSubscribers::K_MEMBERS);
	std::vector<std::string> dgnaSubscribersTextRef = queryResultsAsList(groupResultSet,RadioMethodQueryReference::K_MEMBERS);
	deleteReference(groupResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

	unsigned int iLoop;
	// Determine the subscribers to remove
	std::string changeText = "";
	for (iLoop=0;iLoop<dgnaSubscribersTextRef.size();iLoop++)
	{
		// Check if this subscriber is in the new dest TSI list
		if (changeText.size()>0) changeText += ",";
		changeText += "-" + dgnaSubscribersTextRef.at(iLoop);
	}

	// Update the subscriber record
	// Update the subscriber record
	// If the changeText is empty then there is nothing to change. Don't do a changeReference because it will fail
	if(!changeText.empty())
	{
		RadioMethodChangeReference changeReferenceMethod(getValidSessionRef(),dgnaRef);
		changeReferenceMethod.setGroupMembers(changeText);
		RadioEvent* reply = sendMethod(changeReferenceMethod);
		delete reply;
		reply = NULL;
	}

    FUNCTION_EXIT;
}

void RadioSession::startMonitoring(const char * tsi)
{
    FUNCTION_ENTRY("startMonitoring()");

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "startMonitoring(TSI %s)", tsi);

    RadioEvent * event = NULL;

    try
    {
        RadioMethodMonitorSubscriber monitorMethod(m_sessionRef, tsi, RadioMethodMonitorSubscriber::MON_START);
        event = sendMethod(monitorMethod);
    
        MonitorSubscriberEventReader * mser = dynamic_cast<MonitorSubscriberEventReader *>(event->getEventReader());
        TA_ASSERT( mser!=0 , "EventReader not for MonitorSubscriber" );

        m_radioTcpServer.getSubscriberMonitor().addMonitor(mser->getMonitorReference(), tsi);

        delete event;
        event = NULL;
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }

    FUNCTION_EXIT;
}

void RadioSession::stopMonitoring(const char * tsi)
{
    FUNCTION_ENTRY("stopMonitoring()");

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "stopMonitoring(TSI %s)", tsi);
    
    RadioEvent * event = NULL;

    try
    {
        MonitorReference monRef = m_radioTcpServer.getSubscriberMonitor().findMonitor(tsi);
        if (0==monRef)
        {
            LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "stopMonitoring could not find Monitor for subscriber %s", tsi);
            return;
        }

        // ///////////////////////
        // MonitorSubscriber(MON_STOP)
        RadioMethodMonitorSubscriber monitorMethod(m_sessionRef, tsi, RadioMethodMonitorSubscriber::MON_STOP, monRef);
        event = sendMethod(monitorMethod);
    
        delete event;
        event = NULL;

        m_radioTcpServer.getSubscriberMonitor().removeMonitor(monRef);

        // ///////////////////////
        // DeleteReference(MonitorReference)
        RadioMethodDeleteReference delRefMethod(m_sessionRef);
        delRefMethod.setReference(RadioMethodDeleteReference::MONITOR_REFERENCE,monRef);
        event = sendMethod(delRefMethod);
    
        delete event;
        event = NULL;
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }

    FUNCTION_EXIT;
}

void RadioSession::oneShotMonitoring(const char * tsi)
{
    FUNCTION_ENTRY("oneShotMonitoring()");

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "oneShotMonitoring(TSI %s)", tsi);

    RadioEvent * event = NULL;

    try
    {
        RadioMethodMonitorSubscriber monitorMethod(m_sessionRef, tsi, RadioMethodMonitorSubscriber::MON_ONE_SHOT);
        event = sendMethod(monitorMethod);
        
        MonitorSubscriberEventReader * mser = dynamic_cast<MonitorSubscriberEventReader *>(event->getEventReader());
        TA_ASSERT( mser!=0 , "EventReader not for MonitorSubscriber" );
        
        m_radioTcpServer.getSubscriberMonitor().addMonitor(mser->getMonitorReference(), tsi);
    
        delete event;
        event = NULL;
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }

    FUNCTION_EXIT;
}

CallID RadioSession::startListening(CallID callId)
{
    FUNCTION_ENTRY("startListening()");

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "startListening(Call %lu)", callId);

    CallID new_callId = callId;

    RadioEvent * event = NULL;

    try
    {
        RadioMethodMonitorCall monCallMethod(m_sessionRef, callId);
        event = sendMethod(monCallMethod);

        if (STATUS_REJECTED == event->getStatus())
        {
            // Throw a radio session error
            TA_THROW(RadioSessionException("Could not Monitor Call",event->getStatus()));
        }
        
        MonitorCallEventReader * monCallEvtRdr = dynamic_cast<MonitorCallEventReader *>(event->getEventReader());
        TA_ASSERT( monCallEvtRdr!=0, "EventReader not for MonitorCall Event");

        // new Call Reference will be different if for a group call
        new_callId = monCallEvtRdr->getCallReference();

        m_radioTcpServer.getSubscriberMonitor().startedListenCall(callId, new_callId);
        delete event;
        event = NULL;
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }


    FUNCTION_EXIT;
    return new_callId;
}

void RadioSession::stopListening(CallID callId)
{
    FUNCTION_ENTRY("stopListening()");

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "stopListening(Call %lu)", callId);

    RadioEvent * event = NULL;

    try
    {
        m_radioTcpServer.getRadioResourceManager().detachMonitorAudio(getValidSessionRef(), callId);

        RadioMethodDisconnect disconnectMethod(m_sessionRef, callId);
        event = sendMethod(disconnectMethod);
        delete event;
        event = NULL;

        m_radioTcpServer.getSubscriberMonitor().stoppedListenCall(callId);
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }

    FUNCTION_EXIT;
}

CallID RadioSession::joinCall(CallID callId)
{
    FUNCTION_ENTRY("joinCall");

    checkRadioFallback();

    // This function is called by the Radio Monitor GUI regardless of whether
    // the original call is a conference or individual call.  Since Join is
    // intended for groups, we need to use "include" if we are joining an
    // individual call.
    // RvH 20050131 Pre-Radio-iFAT
    // If the call has been listened to, the callId will refer to a group call.
    // The better way is to check if the call is FullDuplex. Unfortunately,
    //
    RadioSessionHelper helper( getValidSessionRef(), m_radioTcpServer );
    std::string comm_type_str = helper.queryReference(callId, RadioMethodQueryReference::K_COMM_TYPE);
    if ( comm_type_str != "SPEECH" )
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, "Call %lu not valid to join, not a voice call");
        return 0;
    }


    std::string call_type_str = helper.queryReference(callId, RadioMethodQueryReference::K_CALL_TYPE);
    ECallType callType = helper.convert2CallType(call_type_str);
    if (callType == SingleCall)
    {
        std::string sessionITSI = getSessionTSI();
        long newCallRef = includeSubscriber(callId, sessionITSI);

        m_radioTcpServer.getSubscriberMonitor().joinedCall(callId, newCallRef, true);

        return newCallRef;
    }

    CallID postJoinCallId = 0;
    RadioEvent * event = NULL;

    try
    {
        CallID monitorCallId = m_radioTcpServer.getSubscriberMonitor().getJoinCallId(callId);

        RadioMethodJoin joinMethod(getValidSessionRef(), monitorCallId);
        event = sendMethod(joinMethod);

        JoinEventReader * joinEvtRdr = dynamic_cast<JoinEventReader *>(event->getEventReader());
        TA_ASSERT( joinEvtRdr!=0, "EventReader not for JoinEvent");

        postJoinCallId = joinEvtRdr->getCallReference();

        delete event;
        event = NULL;

        m_radioTcpServer.getSubscriberMonitor().joinedCall(callId, postJoinCallId, false);
    }
    catch (...)
    {
        delete event;
        event = NULL;
        throw;
    }

    FUNCTION_EXIT;
    return postJoinCallId;
}

CallID RadioSession::includeSubscriber(CallID callId, const std::string & tsi)
{
	FUNCTION_ENTRY("includeSubscriber");

    checkRadioFallback();

	// Include a subscriber
	RadioMethodInclude   includeMethod(getValidSessionRef(),callId,tsi);
	RadioEvent* incReply = sendMethod(includeMethod);

    // Get new call reference
    RadioEventReader * evtRdr = incReply->getEventReader();
    IncludeEventReader * includeEvtRdr = dynamic_cast<IncludeEventReader *>(evtRdr);
    TA_ASSERT( includeEvtRdr!=0, "EventReader not IncludeEventReader");

    long newCallId = includeEvtRdr->getCallReferenceDst();

	delete incReply;

    // old call is now disconnected, must delete reference
	deleteReference(callId,RadioMethodDeleteReference::CALL_REFERENCE);

	// remove the audio reference in our internal state
	m_radioTcpServer.getRadioResourceManager().releaseAudioResources(getValidSessionRef(), callId);

    // and remove from call stack
    m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef(), false);

	// RvH 20050118 Radio Pre-iFAT
	// Attach some audio to the call
    //
    // VoiceDataRecorder NOTE: this function shouldn't need the the data sent
    // here, because the include still causes an implicit Auto-Answer - where
    // there is a call to VoiceDataRecorder
	m_radioTcpServer.getRadioResourceManager().attachAudio(getValidSessionRef(),newCallId);

	// Update call stack to reflect new caller
	// Normally add a new call to the stack
	CallDetailsType details;
	// CallDetailsType  details;

	details.callStatus   = Connected;
	details.callSource   = OutgoingCall;
	details.callCategory = HalfDuplex;  // after inclusion, call is group call
	details.callType     = GroupUnacknowledgeCall;  // will be updated by callstackupdate task, anyway
	details.callTime     = ""; // set by RadioTcpServer::addCallToCallStack, but should
	details.time         = 0;  //              obviously be initialised here.

	// Get the call details from the event
	details.callID     = newCallId;
	details.sessionRef = getValidSessionRef();
	details.calledTSI  = ""; // filled in by CallStackUpdateTask::perform
	details.callerTSI  = ""; // ditto

	// TODO: Look up the caller name and location in the subscriber directory
	details.calledLocation = ""; // "UNAVAILABLE";
	details.calledName     = ""; // "UNAVAILABLE";
	details.callerLocation = ""; // "UNAVAILABLE";
	details.callerName     = ""; // "UNAVAILABLE";

	details.isEmergency    = false; // will be corrected in CallStackUpdateTask::perform()
	//TD 10234
    details.isInvisibleToGUIApps = false;

    // This both looks up the caller/called details and adds to the callstack
    m_radioTcpServer.addBackgroundTask(RadioTaskFactory::createCallStackUpdateTask(&m_radioTcpServer, details));

	FUNCTION_EXIT;
    return newCallId;
}

void RadioSession::terminateCall(CallID callId)
{
    FUNCTION_ENTRY("terminateCall");

    RadioMethodForceCallTermination terminateMethod(getValidSessionRef(), callId);
    RadioEvent * terminateEvent = sendMethod(terminateMethod);
    delete terminateEvent;

    m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());

    FUNCTION_EXIT;
}

void RadioSession::doLoginSession(SessionReference previousSessionRef)
{
	FUNCTION_ENTRY("doLoginSession");
    if (m_sessionStatus == SessionInitialised)
    {
        // Step 3. Login, if we have an auto- or re-login name
        if (!m_loginName.empty())
        {
            try
            {
				if ( m_loginPassword.empty() )
				{
					while (m_loginName.size() > 0 && m_loginPassword.size() < 6)
					{
						m_loginPassword += m_loginName;
					}
				}

                // Send the login method
                RadioMethodLogin   loginMethod(m_sessionRef,m_loginName,m_loginPassword);
                RadioEvent* replyEvent = sendMethod(loginMethod);
                
                LoginEventReader*  reader = dynamic_cast<LoginEventReader*>(replyEvent->getEventReader());
                
				if (reader == NULL)
				{
					LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, 
						"Can't get the LoginEventReader. Session login failed for %s using profile %s",m_sessionEntityName.c_str(),m_loginName.c_str());
					TA_THROW(RadioException("can't get LoginEventReader. dynamic_cast failed or invalid message"));
				}
				
                // Close any alarms for this login point
                m_sessionStatus = SessionLoggedIn;
				onSessionStatusChange( SessionStatusOK );

                m_radioSessionServant.onSessionLoginComplete();

                // Get the DGNA TSI from the reply event
                m_sessionDGNAITSI = reader->getDGNA();
                
                // let radio know if we made it in or out of fallback
                m_radioTcpServer.onRadioFallback((replyEvent->getStatus() == STATUS_OK_FALLBACK), fbSessionLogin);
                LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
                     "login() - Radio::onRadioFallback(%s, fbSessionLogin)", (replyEvent->getStatus() == STATUS_OK_FALLBACK) ? "true":"false");
                m_switchNotReachable = (replyEvent->getStatus() == STATUS_OK_FALLBACK);
                
                delete replyEvent;
                replyEvent = NULL;
                
                if (m_audioLink != 0)
                {
                    
                    LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
                         "login() - creating audio references");
                    
                    // Get a list of our resources
                    try
                    {
                        m_radioTcpServer.getRadioResourceManager().addAudioReferences(m_sessionRef);
                    }
                    catch (...)
                    {
                        // Advise parent class of this problem ?
                        
                        // Logout
                        logoutSession();
                        
                        // Continue to deal with the problem (like, in the outer catch(...) block)
                        throw;
                    }
                }
                
                // Attach To Groups that we're a member of
                /*int numGroups = */ attachToGroups();

                // tell the tcp server its logged in
                m_radioTcpServer.sessionLoggedIn(m_sessionRef);
                
                std::cout << "Session login complete for " << m_sessionEntityName.c_str() << std::endl;
                LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
                     "Session login complete for %s",m_sessionEntityName.c_str());
				 sendStateUpdate();
                
                // try to cache call forwarding details to improve RM startup time
                try
                {
                    CallForwardingDetails details;
                    getCallForwarding(details);
                }
                catch(...)
                {
                }
            }
			catch ( RadioSessionException& rse ) 
			{
				LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
                     "Session login failed for %s using profile %s, reason: %s",
					 m_sessionEntityName.c_str(),m_loginName.c_str(), rse.what() );
			}
            catch (...)
            {
                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
                     "Session login failed for %s using profile %s",m_sessionEntityName.c_str(),m_loginName.c_str());
                
                // Unable to login - raise alarm to advise operators
                m_radioSessionServant.onSessionLoginFailure(m_loginName);
            }
            
          
        }
        else
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
                 "No pre-existing login name for session %s using profile %s",m_sessionEntityName.c_str(),m_loginName.c_str());
        }

        //
        // If we were previously logged in, we'd better inform listeners
        // that our session has changed.
		// If login failed, there is no need for us to do so. 
        if (previousSessionRef != InternalUnassignedReference && m_sessionStatus == SessionLoggedIn)
        {
			try
			{
				m_radioSessionServant.onSessionUpdate();
			}
			catch (RadioSessionNotInitialisedException* e)
			{
				LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::ExceptionCatch, "RadioSessionNotInitialisedException catched while attempting to Update Radio Session after tried login: %s.", e->what());
			}
        }
    }


	FUNCTION_EXIT;
}

/**
* This will call the AttachSession and Initialise functions to setup the session with the radio
*/
void RadioSession::initialiseSession()
{
	FUNCTION_ENTRY("InitialiseSession");

    // tell the initialisation thread to log in now
	m_radioSessionInitialisationThread->processSessionInit(RadioSessionInitialisationThread::InitialiseSession);

	FUNCTION_EXIT;
}

/**
* Logout the user
*/
void RadioSession::doLogoutSession()
{
	FUNCTION_ENTRY("logoutSession");

    try
    {
	    // Send the login method
	    RadioMethodLogout   logoutMethod(m_sessionRef);
	    RadioEvent* replyEvent = sendMethod(logoutMethod);
	    delete replyEvent;
	    replyEvent = NULL;
    }
    catch (RadioSessionException rse)
    {
        if (rse.getErrorNumber() == STATUS_KO_NOT_LOGGED)
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, "Session %d already not logged into TcpServer", getValidSessionRef());
        }
    }
    catch ( ... )
    {
        // just allow the logic to continue
    }

	if (!m_isISCS)
	{
		//For ISCS session, these information will not change from this session created
		// so just keep these for further login.
		m_loginName = "";
		m_loginPassword = "";
		m_sessionITSI = "";
	}
    m_subscriberTextRef = "";
    m_sessionDGNAITSI = "";
    m_sessionDGNAInUse = false;
	m_sessionStatus = SessionInitialised;

	onSessionStatusChange( SessionNotLogin );

	m_radioTcpServer.sessionLoggedOut(m_sessionRef);

	sendStateUpdate();

	m_condition.signal();

	FUNCTION_EXIT;
}

void RadioSession::logoutSession()
{
	m_radioSessionInitialisationThread->processSessionInit(RadioSessionInitialisationThread::LogoutSession);
}

SessionReference RadioSession::getValidSessionRef()
{
	FUNCTION_ENTRY("getValidSessionRef");

	// Check module initialised
	if ((m_sessionStatus == SessionUnassigned)||(m_sessionStatus == SessionAssigned))

	{
		// Throw an exception as we cannot process this request without a valid session
		LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn,
			" RadioSession %s status is %d",
									getSessionEntityName().c_str() , m_sessionStatus );
		TA_THROW(RadioSessionNotInitialisedException());

	}

	FUNCTION_EXIT;
	return m_sessionRef;
}

/**
* Detach the session
*/
void RadioSession::doDetachSession()
{
	FUNCTION_ENTRY("detachSession");

	// Send the detach method
	if (m_sessionStatus != SessionUnassigned)
	{
        try
        {
            RadioMethodDetachSession   detachMethod(m_sessionRef);
            RadioEvent* replyEvent = sendMethod(detachMethod);
            delete replyEvent;
            replyEvent = NULL;
        }
        catch ( ... )
        {
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Session %d detach session failed", getRefID());
        }

		m_sessionStatus = SessionUnassigned;

		onSessionStatusChange( SessionNotLogin );

		sendStateUpdate();
	}
	FUNCTION_EXIT;
}

void RadioSession::detachSession()
{
	//only for detachSession
	m_radioSessionInitialisationThread->processSessionInit(RadioSessionInitialisationThread::DetachSession);
}

bool RadioSession::isAttached() const
{
    FUNCTION_ENTRY("isAttached");
    return (m_sessionStatus != SessionUnassigned);
	FUNCTION_EXIT;
}

bool RadioSession::isInitialised() const
{
    FUNCTION_ENTRY("isInitialised");
    return ((m_sessionStatus == SessionInitialised) || (m_sessionStatus == SessionLoggedIn));
	FUNCTION_EXIT;
}

bool RadioSession::isLoggedIn() const
{
    FUNCTION_ENTRY("isLoggedIn");
	LOG_GENERIC (SourceInfo, TA_Base_Core::DebugUtil::DebugTrace, 
		"[shouldAttemptLogin] isLoggedIn = %d.", m_sessionStatus==SessionLoggedIn);
    return (m_sessionStatus == SessionLoggedIn);
	FUNCTION_EXIT;
}

static void logCallDetailsPartial(const CallDetailsType & details, const char * introduction, int tcpSrvIdx, SessionReference sessRef)
{
    if ( TA_Base_Core::DebugUtil::getInstance().getLevel() >= TA_Base_Core::DebugUtil::DebugDebug)
    {
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "%s RadioTcpServer %d Session %lu Call %lu:\n"
                "Console %lu Time %s\nCaller %s (TSI %s Location %s)\n",
                "Called %s (TSI %s Location %s)\n",
                "Status %d Category %d Type %d Source %d\n",
                "%s Emergency %s to GUI Apps",
                introduction, tcpSrvIdx, sessRef, details.callID,
                details.consoleID, details.callTime.c_str(), details.callerName.c_str(), details.callerTSI.c_str(), details.callerLocation.c_str(),
                details.calledName.c_str(), details.calledTSI.c_str(), details.calledLocation.c_str(),
                (int)details.callStatus, (int)details.callCategory, (int)details.callType, (int)details.callSource,
                (details.isEmergency ? "IS" : "NOT"), (details.isInvisibleToGUIApps ? "Invisible":"Visible"));
    }
}

void RadioSession::answerCall(CallID callId, std::string sessionId)
{
    FUNCTION_ENTRY("answerCall");

    try
    {
        RadioMethodAnswerCall   answerMethod(m_sessionRef,callId);
        RadioEvent* replyEvent = sendMethod(answerMethod);
        delete replyEvent;
        replyEvent = NULL;
    }
    catch(RadioSessionException& rse)
    {
        if (rse.getErrorNumber() == STATUS_KO_INVALID_REFERENCE)
        {
            LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                    "Call %lu is not known in the radio system, removing from call stack", callId);

            // the call is gone
            m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());
        }

        throw;
    }

    TA_IRS_App::CallDetailsType details;
    bool callFnd = m_radioTcpServer.getCallDetailsPartial(callId, details);

    if(callFnd)
    {
        // as explained in startListening, this portion is for subscriber monitoring
        // if the monitor manager detects that this is a monitored call, then it
        // should be handling it
        // if ( (0!=m_radioTcpServer.getSubscriberMonitor().findMonitor(callId)))
        if (    (m_radioTcpServer.getSubscriberMonitor().canListenCall(callId))
             || (m_radioTcpServer.getSubscriberMonitor().isListenCall(callId)) )
        {
            bool successfulAttach = false;
            //logCallDetailsPartial(details, "Answering Monitored Call. Details:", m_radioTcpServer.getServerIndex(), m_sessionRef);

            try
            {
                // Attach some monitoring audio to the call
                m_radioTcpServer.getRadioResourceManager().attachMonitorAudio(getValidSessionRef(), callId, (FullDuplex==details.callCategory));
                successfulAttach = true;
            }
            catch (RadioException & rse)
            {
                LOG_EXCEPTION_CATCH(SourceInfo, "RadioException", rse.what() );
            }

            if (!successfulAttach)
            {
                RadioEvent * event = 0;
                try
                {
                    m_radioTcpServer.getSubscriberMonitor().stoppedListenCall(callId);
                    RadioMethodDisconnect disconnectMethod(getValidSessionRef(),callId);
                    event = sendMethod(disconnectMethod);
                }
                catch (...)
                {
                }
                delete event;
            }
        }
        else
        {
            // Attach some normal audio to the call
            m_radioTcpServer.getRadioResourceManager().attachAudio(getValidSessionRef(),callId);



            // Add call to history.
            //addCallToHistory(sessionId, details);
        }
    }
    else
    {
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                    "answerCall() - RadioTcpServer %d Session %lu Could not determine call details for Call %lu",
                    getTcpServer().getServerIndex(), m_sessionRef, callId);
    }

    m_radioTcpServer.updateCallStatusInCallStack(callId,Connected,getValidSessionRef());
	
	FUNCTION_EXIT;
}

void RadioSession::releaseCall(CallID callId,std::string sessionId)
{
	FUNCTION_ENTRY("releaseCall");

	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "RadioSession::releaseCall - Releasing CallId %d, session %s", callId, sessionId.c_str());
	// Disconnect the voice call (ignore if text)
	TA_IRS_App::CallDetailsType details;
	bool callFnd = m_radioTcpServer.getCallDetailsPartial(callId, details);
	if (!m_radioTcpServer.isSDSCall(callId))
	{
        RadioEvent * event = 0;

        try
        {
            // RvH 20050115 Radio Pre-iFAT
            // Need to deselect before disconnecting, not after.
            // Done directly rather than via ::deselectCall, as that
            // method also adjusts audio in a way not required here.
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "RadioSession::releaseCall - calling deselectMethod for Session %lu Call %lu",
                getValidSessionRef(), callId);
            RadioMethodDeselect deselectMethod(getValidSessionRef(),callId);
            event = sendMethod(deselectMethod);
            delete event;
            event = 0;

            // Detach the audio associated with this call
            // Not strictly necessary for the RCS, as the Disconnect will
            // do that, however this is very important for the
            // RadioResourceManager's purposes, to correctly update the internal
            // audio usage map.
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "RadioSession::releaseCall - releasing Audio references, Session %lu Call %lu",
                getValidSessionRef(), callId);
            m_radioTcpServer.getRadioResourceManager().releaseAudioReference(getValidSessionRef(),callId, m_radioTcpServer.getSubscriberMonitor().isListenCall(callId));

            // Disconnect the call!
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "RadioSession::releaseCall - calling RadioMethodDisconnect, Session %lu Call %lu",
                getValidSessionRef(), callId);
            RadioMethodDisconnect disconnectMethod(getValidSessionRef(),callId);
            event = sendMethod(disconnectMethod);
            delete event;
            event = 0;

            // Release the associated call reference
            deleteReference(callId,RadioMethodDeleteReference::CALL_REFERENCE);
            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                "RadioSession::releaseCall - Deleted CallReference, Session %lu Call %lu",
                getValidSessionRef(), callId);

            //
            // deassign the dynamic group participants if required
            if ( (callFnd) && (details.calledTSI==m_sessionDGNAITSI) && !(details.callText == "include") )
            {
                deassignDynamicGroup();
            }
        }
        catch(RadioSessionException& rse)
        {
            if (rse.getErrorNumber() == STATUS_KO_INVALID_REFERENCE)
            {
                LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                    "Call %lu is not known in the radio system, removing from call stack", callId);

                // the call is already released
                m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());
            }

            delete event;
            event = 0;
            throw;
        }
        catch (...)
        {
            delete event;
            event = 0;
            throw;
        }
        delete event;
        event = 0;
	}
	else
	{
		// Release the associated call reference
		deleteReference(callId,RadioMethodDeleteReference::SDS_REFERENCE);

	}

	// Now finally remove the call from the call stack
	m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());

	FUNCTION_EXIT;
}



/**
* Send the method to the radio and get the reply event.  This method simply calls the parent (m_radioTcpServer) sendMethod.
* @param    method
*/
RadioEvent* RadioSession::sendMethod(RadioMethod& method)
{
	FUNCTION_ENTRY("sendMethod");

	RadioEvent*  event = m_radioTcpServer.sendMethod(method);

	if (event == NULL){
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, "reply event is NULL");
		
		FUNCTION_EXIT;
		return NULL;
	}	// Check for an error
	else if (event->getStatus()<0)
	{
		// Throw a radio session error
		TA_THROW(RadioSessionException(event->getTextStatus(),event->getStatus()));
	}
	

	FUNCTION_EXIT;
	return event;
}

void RadioSession::holdCall(CallID callId,std::string sessionId)
{
	FUNCTION_ENTRY("holdCall");

	// Detach the audio associated with this call
    try
    {
	    m_radioTcpServer.getRadioResourceManager().releaseAudioReference(getValidSessionRef(),callId,true);

	    m_radioTcpServer.updateCallStatusInCallStack(callId,OnHold,getValidSessionRef());
    }
    catch(RadioSessionException& rse)
    {
        if (rse.getErrorNumber() == STATUS_KO_INVALID_REFERENCE)
        {
            LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                    "Call %lu is not known in the radio system, removing from call stack", callId);

            // the call is gone
            m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());
        }

        throw;
    }

	FUNCTION_EXIT;
}


void RadioSession::resumeCall(CallID callId,std::string sessionId)
{
	FUNCTION_ENTRY("resumeCall");
	
    try
    {
	    // Attach the audio associated with this call
	    m_radioTcpServer.getRadioResourceManager().attachAudio(getValidSessionRef(),callId);

	    m_radioTcpServer.updateCallStatusInCallStack(callId,Connected,getValidSessionRef());

	    TA_IRS_App::CallDetailsType details;
		m_radioTcpServer.getCallDetailsPartial(callId, details);
    }
    catch(RadioSessionException& rse)
    {
        if (rse.getErrorNumber() == STATUS_KO_INVALID_REFERENCE)
        {
            LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                    "Call %lu is not known in the radio system, removing from call stack", callId);

            // the call is gone
            m_radioTcpServer.removeCallFromCallStack(callId,getValidSessionRef());
        }

        throw;
    }

	FUNCTION_EXIT;
}


void RadioSession::demandTX(short priority,std::string sessionId,unsigned long& queuedID)
{
	FUNCTION_ENTRY("demandTX");

	RadioMethodDemandTX   demandTXMethod(getValidSessionRef(),priority);
	RadioEvent* reply = sendMethod(demandTXMethod);

	// Get the reply
	queuedID = 0;
	if (reply->getStatus()==STATUS_DEMANDTX_QUEUED)
	{
		// Queued - so give back the transaction id for reference
		queuedID = reply->getTransactionId();
	}

	delete reply;

	FUNCTION_EXIT;
}

void RadioSession::ceaseTX(std::string sessionId)
{
	FUNCTION_ENTRY("ceaseTX");

	RadioMethodCeaseTX   ceaseTXMethod(getValidSessionRef());
	RadioEvent* reply = sendMethod(ceaseTXMethod);
	delete reply;

	FUNCTION_EXIT;
}

void RadioSession::selectCall(CallID callId,std::string sessionId)
{
	FUNCTION_ENTRY("selectCall");

	// Send the message
	RadioMethodSelect   selectMethod(getValidSessionRef(),callId);
	RadioEvent* reply = sendMethod(selectMethod);
	delete reply;

	// Adjust audio to right speaker
	m_radioTcpServer.getRadioResourceManager().setAudioSpeaker(getValidSessionRef(),callId,true);

	FUNCTION_EXIT;
}

void RadioSession::deselectCall(CallID callId,std::string sessionId)
{
	FUNCTION_ENTRY("deselectCall");

	// RvH 20050115 Radio Pre-iFAT
	// If a call has status Deleted then don't call deselect
	// on the RCS here, as it will only result in an exception
	// which then cascades to an error MessageBox at the GUI.
	TA_IRS_App::CallDetailsType callDetails;
	bool detailsFound = m_radioTcpServer.getCallDetailsPartial(callId, callDetails);
	if ( ( detailsFound ) && ( callDetails.callStatus != Deleted ) )
	{
		LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug,
			 "deselectCall() - detailsFound, callStatus!=Deleted for CallID=%lu", callId);

		// Send the message
		RadioMethodDeselect deselectMethod(getValidSessionRef(),callId);
		RadioEvent* reply = sendMethod(deselectMethod);
		delete reply;

		// Adjust audio to left speaker
		m_radioTcpServer.getRadioResourceManager().setAudioSpeaker(getValidSessionRef(),callId,false);
	}
	else
	{
		LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug,
			 "deselectCall() - not deselecting non-existent or deleted call (CallID=%lu)", callId);
	}

	
	FUNCTION_EXIT;
}

void RadioSession::adjustCallVolume(CallID callId,bool increaseVol,std::string sessionId)
{
	FUNCTION_ENTRY("adjustCallVolume");

	// Adjust audio to right speaker
	m_radioTcpServer.getRadioResourceManager().adjustAudioVolume(getValidSessionRef(),callId,increaseVol);

	FUNCTION_EXIT;
}

void RadioSession::createPatch(std::vector<std::string> groupList,std::string patchName,std::string sessionId)
{
	FUNCTION_ENTRY("createPatch");

    checkRadioFallback();

	TA_ASSERT(groupList.size()>0,"No groups specified to patch.");

    // Preliminary group list modification: the given groupList is TSI's whereas
    // we need TextRefs for the ChangeReference.
	// Setup the search criteria
	std::string searchCriteria;
	bool isFirstGroup = true;
	std::vector<std::string>::const_iterator it=groupList.begin();
	while (it!=groupList.end())
	{
		if (!isFirstGroup) 
		{
			searchCriteria = searchCriteria + " OR ";
		}

		searchCriteria = searchCriteria + "TSI='" + *it + "'";
		isFirstGroup = false;
		it++;
	}

	// Search for the groups to be patched
	unsigned long searchResultSet = performSubscriberSearch(searchCriteria);
	// Get the groups references as text
	std::vector<std::string> groupTextRefList = queryResultsAsList(searchResultSet, RadioMethodQueryReference::K_MEMBERS);
	// Free the search result reference
    deleteReference(searchResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

    // NOW we're ready for the change reference
	// Get a new subscriber reference to use to create patch record
	NewReferenceEventReader::RadioReference   newSubscriberRef;
	newSubscriberRef = getNewReference(RadioMethodNewReference::SUBSCRIBER_REFERENCE);

	// Get our TSI to be used as the owner of the new patch
    std::string sessionITSI = getSessionTSI();

	// Create the new patch, with TextRefs
	RadioMethodChangeReference changeReferenceMethod(getValidSessionRef(),newSubscriberRef);
	changeReferenceMethod.setPatchDetails(sessionITSI,groupTextRefList,patchName);
	RadioEvent* reply = sendMethod(changeReferenceMethod);
	delete reply;
    reply = NULL;
	
	FUNCTION_EXIT;
}

void RadioSession::deletePatch(std::string patchName,std::string sessionId)
{
    FUNCTION_ENTRY("deletePatch()");

    checkRadioFallback();

	// Select the patch group
	unsigned long referenceResultSet = performSubscriberSearch("PATCH_ID='" + patchName + "'",
															RadioMethodSearchSubscribers::K_PATCH);

	// Get the subscriber reference text
    std::string patchTextRef = queryResults(referenceResultSet,RadioMethodQueryReference::K_MEMBERS);

	// Get the subscriber reference
 	unsigned long patchReference = convertTextToSubscriberReference(patchTextRef);

	// remove the patch
	RadioMethodDeleteSubscriber deleteSubscriberMethod(getValidSessionRef(),patchReference);
	RadioEvent* reply = sendMethod(deleteSubscriberMethod);
	delete reply;
    reply = NULL;

    FUNCTION_EXIT;
}

void RadioSession::setCallForwarding(const CallForwardingDetails& details,std::string sessionId)
{
	FUNCTION_ENTRY("setCallForwarding");

    checkRadioFallback();

    if (m_subscriberTextRef.empty())
    {
        TA_THROW(RadioSessionException("Subscriber text reference not defined.  Use getCallForwarding first.", STATUS_KO_SUBSCRIBER_NOT_FOUND));
    }
    // WAS:
	// TA_ASSERT(m_subscriberTextRef.size()>0,"Subscriber text reference not defined.  Use getCallForwarding first.");

	// Convert the text reference to a radio reference so we can use it in a QueryReference
 	unsigned long subReference = convertTextToSubscriberReference(m_subscriberTextRef);

	// Send the message
	RadioMethodChangeReference changeReferenceMethod(getValidSessionRef(),subReference);
	changeReferenceMethod.setForwardingDetails(details);
	RadioEvent* reply = sendMethod(changeReferenceMethod);

    // Construct a reader with the reply event
    //ChangeReferenceEventReader reader(*reply);
	delete reply;
    reply = NULL;

    // Delete the subscriber reference
    //deleteReference(subReference,RadioMethodDeleteReference::SUBSCRIBER_REFERENCE);

	// Notify callForwarding being set for this session
	std::stringstream message;
	message << "Type[RadioCallForwarding] " << details.getForwardingActionAsString();
	m_radioTcpServer.getRadioCallback().updateGX(sessionId, message.str(), getConsoleID() );


	FUNCTION_EXIT;
}


void RadioSession::getCallForwarding(CallForwardingDetails& details)
{
	FUNCTION_ENTRY("getCallForwarding");

    checkRadioFallback();

    // To start, we need to determine the TSI number of this operators session
	// Note this could be done as part of login process for efficiency.
    std::string sessionITSI = getSessionTSI();

    // Now that we have the ITSI we can search the subscribers for it.
	unsigned long referenceResultSet = performSubscriberSearch("TSI='" + sessionITSI + "'");

	// Need to get our subscriber textual reference
	m_subscriberTextRef = queryResults(referenceResultSet, RadioMethodQueryReference::K_MEMBERS);
	TA_ASSERT(m_subscriberTextRef.size()>0,"Subscriber text reference not defined.");

    // Before using this text reference need to delete the previous search reference (don't need it any more)
    deleteReference(referenceResultSet,RadioMethodDeleteReference::SEARCH_REFERENCE);

    // Now convert the text reference to a radio reference so we can use it in a QueryReference
	unsigned long subReference = convertTextToSubscriberReference(m_subscriberTextRef);

    // And now, perform a query on the reference to determine if forwarding is enabled
	std::string queryDetails = queryResults(subReference, RadioMethodQueryReference::K_SUPPLEMENTARY_SERVICES);
	if (queryDetails.find('W')!=std::string::npos)
	{
		// Some settings are present so go get them
		std::string destTSI = queryResults(subReference, RadioMethodQueryReference::K_FORWARD_UNCONDITIONAL);
		if (destTSI.size()>0)
		{
			details.forwardAction = TA_IRS_App::CallForwardingDetails::ForwardAlways;
		}
		else
		{
			// Must be the other forwarding
			details.forwardAction = TA_IRS_App::CallForwardingDetails::ForwardNotReachable;
		    destTSI = queryResults(subReference, RadioMethodQueryReference::K_FORWARD_UNREACHABLE);
		}

		// Only want first destination (upto ;)
		for (unsigned int iLoop=0;iLoop<destTSI.size();iLoop++)
		{
			if (destTSI[iLoop]==';') break;
			details.destinationTSI += destTSI[iLoop];
		}
	}
	else
	{
		// No forwarding setup yet
        details.forwardAction = TA_IRS_App::CallForwardingDetails::NeverForward;
        details.destinationTSI = "";
	}

    // Delete the subscriber reference
    //deleteReference(subReference,RadioMethodDeleteReference::SUBSCRIBER_REFERENCE);

	FUNCTION_EXIT;
}


void RadioSession::getAuthorisationList(AuthorisationStack& authorisationList)
{
	FUNCTION_ENTRY("getAuthorisationList");
	m_radioTcpServer.getAuthorisationManager().getAuthorisationList(authorisationList, this->getValidSessionRef());
	FUNCTION_EXIT;
}

void RadioSession::authoriseCall(unsigned long callID, bool accept, const char* sessionID)
{
	FUNCTION_ENTRY("authoriseCall");
	m_radioTcpServer.getAuthorisationManager().authoriseCall(callID, accept, sessionID);
	FUNCTION_EXIT;
}

bool RadioSession::doInitialiseSession()
{
	FUNCTION_ENTRY("doInitialiseSession");
    bool initialiseOk = false;
	// Step 2. Initialise session
	if (m_sessionStatus==SessionAssigned)
	{
        RadioMethodInitialise    initialiseMethod(m_sessionRef);
        unsigned long            linkId = m_audioLink;

        if (linkId==0)
        {
            // No audio link is this value for radio.
            linkId = 0xFFFFFFFF;
        }

        initialiseMethod.setLinkId(linkId);

        try
        {
            // Send the initialise method
            RadioEvent * reply = sendMethod(initialiseMethod);
            delete reply;

            m_sessionStatus = SessionInitialised;
            initialiseOk = true;

			onSessionStatusChange( SessionNotLogin );
            
            m_radioSessionServant.onSessionInitialisationComplete();

			if (m_isISCS)
			{
				m_radioSessionInitialisationThread->processSessionInit(RadioSessionInitialisationThread::InitialiseSession);
			}
        }
        catch (...)
        {
            // Advise parent class of this problem
            m_radioSessionServant.onSessionInitialisationFailure();
        }
        
        sendStateUpdate();
	}
	else if ( m_sessionStatus == SessionInitialised )
	{
		initialiseOk = true;
	}

    FUNCTION_EXIT;
    return initialiseOk;
} // doInitialiseSession

void RadioSession::releaseSDSReference(const unsigned long sdsReference)
{
    FUNCTION_ENTRY("releaseSDSReference");

    deleteReference(sdsReference,RadioMethodDeleteReference::SDS_REFERENCE);

    FUNCTION_EXIT;
}

void RadioSession::onConnectionEstablish()
{
    FUNCTION_ENTRY("onConnectionEstablish");

	m_connectionEstablished = true;

	onSessionStatusChange( LinkResume );

	if (m_radioTcpServer.getRadio().getIsActive())
    {
        relogin();
	}

	FUNCTION_EXIT;
}

void RadioSession::onConnectionLost()
{
	FUNCTION_ENTRY("onConnectionLost");

	m_connectionEstablished = false;

	onSessionStatusChange( LinkBroken );

	if (m_radioTcpServer.getRadio().getIsActive())
    {
        reset();
	}

	FUNCTION_EXIT;
}

void RadioSession::onSwitchConnection()
{
	FUNCTION_ENTRY("onSwitchConnection");

	m_connectionEstablished = true;

	if (m_radioTcpServer.getRadio().getIsActive())
    {
        relogin();
    }
	FUNCTION_EXIT;
}

NewReferenceEventReader::RadioReference RadioSession::setupDataCall(const std::string& destinationTsi)
{
    FUNCTION_ENTRY("setupDataCall");

	NewReferenceEventReader::RadioReference  callReference(InternalUnassignedReference);

    // Get a new call reference (to be deleted when the call disconnects)
    callReference = getNewReference(RadioMethodNewReference::DATA_REFERENCE);

    try
    {
        // Setup the call (note we might get an unsolicited CallStatus event in addition to the Setup call event)
        RadioMethodSetupCall   setupMethod(getValidSessionRef(),callReference);
        setupMethod.setCallDestination(destinationTsi);
        setupMethod.setCallType(RadioMethodSetupCall::SINGLE_CALL);
        setupMethod.setFullDuplex();
        setupMethod.setCallPriority(1);

        RadioMethodSetupCall::ECommunicationType cid = RadioMethodSetupCall::CMT_Hi_24_1;
        setupMethod.setCommunicationType(cid);

        RadioEvent* reply = sendMethod(setupMethod);
        delete reply;

        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Circuit Mode Transfer: new call reference %d", callReference );
    }
    catch (RadioSessionException rse)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Circuit Mode Transfer: exception while trying to connect callRef %d: %s (%d)", callReference, rse.what(), rse.getErrorNumber());

        // prevent resource leaks
        deleteReference(callReference,RadioMethodDeleteReference::DATA_REFERENCE);

        throw;
    }

    return callReference;

	FUNCTION_EXIT
}

void RadioSession::sendCircuitDataFrame( NewReferenceEventReader::RadioReference callReference,
                                         const RadioCircuitTransfer::Data& frame )
{
    FUNCTION_ENTRY("sendCircuitDataFrame");

	
    // Send the message
    RadioMethodSendCircuitData sendCircuitDataMethod( getValidSessionRef(),
                                                      callReference,
                                                      frame );
    RadioEvent* reply = sendMethod(sendCircuitDataMethod);
    SendCircuitDataEventReader * sendCctDataEvtRdr = dynamic_cast<SendCircuitDataEventReader *>(reply->getEventReader());
    
    TA_ASSERT( NULL != sendCctDataEvtRdr , "Received incorrect event for SendCircuitData method" );
    
    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,
                 "Circuit Mode Transfer: received reply, sent %d bytes",
                 sendCctDataEvtRdr->getSentBytes() );

    delete reply;

	FUNCTION_EXIT
}



void RadioSession::endDataCall( NewReferenceEventReader::RadioReference callReference )
{
    FUNCTION_ENTRY("endDataCall");

    try
    {
        RadioMethodDisconnect disconnectMethod(m_sessionRef, callReference);
        RadioEvent * disconnectReply = sendMethod(disconnectMethod);
        delete disconnectReply;
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Circuit Mode Transfer: disconnected call reference %d", callReference );
    }
    catch (RadioSessionException rse)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Circuit Mode Transfer: exception while trying to disconnect callRef %d: %s (%d)", callReference, rse.what(), rse.getErrorNumber());

        // prevent resource leaks
        clearDataCallReference(callReference);

        throw;
    }

    // otherwise delete the reference

    clearDataCallReference(callReference);
    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Circuit Mode Transfer: finished for call reference %d", callReference );

	FUNCTION_EXIT
}

void RadioSession::clearDataCallReference( NewReferenceEventReader::RadioReference callReference )
{
    FUNCTION_ENTRY("clearDataCallReference");

    deleteReference(callReference,RadioMethodDeleteReference::DATA_REFERENCE);

	FUNCTION_EXIT
}

void RadioSession::onAuthorisationChange(const TA_IRS_App::EAction action,const TA_IRS_App::AuthorisationRequestType& details)
{
	FUNCTION_ENTRY("authoriseCall");
    m_radioSessionServant.onAuthorisationChange(action, details);
    FUNCTION_EXIT;
}

/*
 * This function will return a subscriber reference which can be used for direct
 * manipulation of the associated record.
 *
 * Remember to free the new subscriber reference when you have finished with it!
 */
unsigned long RadioSession::convertTextToSubscriberReference(std::string textReference)
{
	FUNCTION_ENTRY("convertTextToSubscriberReference");

    checkRadioFallback();

   // Now convert the text reference to a radio reference so we can use it in a QueryReference
    RadioMethodText2SubscriberReference text2SubRef(getValidSessionRef());
    text2SubRef.setTextReference(textReference);
    RadioEvent* reply = sendMethod(text2SubRef);

    // The reply will contain the subscriber reference
    Text2SubscriberReferenceEventReader* text2SubRefReader = dynamic_cast<Text2SubscriberReferenceEventReader*>(reply->getEventReader());
    unsigned long subReference = text2SubRefReader->getSubscriberReference();

    // Delete the reply
    delete reply;
    reply = NULL;

	FUNCTION_EXIT;
	return subReference;
}

void RadioSession::checkRadioFallback()
{
    FUNCTION_ENTRY("checkRadioFallback");
    if (m_radioTcpServer.inFallback())
    {
        TA_THROW(RadioFallbackException());
    }
	FUNCTION_EXIT;
}

std::string RadioSession::getSessionDGNAITSI()
{
    FUNCTION_ENTRY("getSessionDGNAITSI");
	FUNCTION_EXIT;	
	return m_sessionDGNAITSI;
}

std::string RadioSession::getPatchOwnerITSI()
{
    FUNCTION_ENTRY("getPatchOwnerITSI");
    // Get our TSI to be used as the owner of the new patch
    // std::string sessionITSI = queryResults(getValidSessionRef(),RadioMethodQueryReference::K_TSI);
    // return sessionITSI;
	FUNCTION_EXIT;
    return getSessionTSI();
}

void RadioSession::setGwldLinkLost(bool isLinkLost)
{
    FUNCTION_ENTRY("setGwldLinkLost");
    m_gwldLinkLost = isLinkLost;
	FUNCTION_EXIT;
}

bool RadioSession::isGwldLinkLost() const
{
    FUNCTION_ENTRY("isGwldLinkLost");
    return m_gwldLinkLost;
	FUNCTION_EXIT;
}

void RadioSession::overwriteSessionStatus(SessionState state)
{
	FUNCTION_ENTRY("overwriteSessionStatus");
	m_sessionStatus = state;
	FUNCTION_EXIT;
}

void RadioSession::onSessionStatusChange( GxUpdateType state)
{
	if ( m_currentGXType == LinkBroken )
	{
		if ( state == LinkResume )
		{
			m_currentGXType = state;
		}
		else
		{
			state = m_currentGXType;
		}
	}

	if ( m_currentGXType == state )
	{
		return;/*
		time_t currentTime = RadioHelper::getCurrentTime();

		 if ( (currentTime-m_lastUpdateTime) < 5 )
		 {
			 return;
		 }

		 m_lastUpdateTime = currentTime;*/
	}

	std::stringstream message;
	message << "Type[RadioSessionStatus] ";

	m_currentGXType = state;

	switch( m_currentGXType )
	{
	case SessionStatusOK:
		message << "StatusOK";
		break;
	case SessionNotLogin:
	case LinkResume:
		if ( m_currentGXType == SessionBadUser )
		{
			return;
		}
		message << "SessionNotLogin";
		break;
	case SessionBadUser:
		message << "BadUserName";
		break;
	case LinkBroken:
		message << "LinkBroken";
		break;
	default:
		return; //other cases will be ignore
	}

	try
	{
		m_radioTcpServer.getRadioCallback().updateGX( "", message.str(), getConsoleID() );
	}
	catch ( ... )
	{
		LOG_GENERIC(SourceInfo ,TA_Base_Core::DebugUtil::DebugDebug, "Failed to update GraphWorX");
	}
}