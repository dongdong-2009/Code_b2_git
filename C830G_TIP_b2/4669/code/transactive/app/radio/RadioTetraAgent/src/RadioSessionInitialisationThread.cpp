/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_Review_Branch/4669/transactive/app/radio/RadioTetraAgent/src/RadioSessionInitialisationThread.cpp $
  * @author:  Andy Parker
  * @version: $Revision: #10 $
  *
  * Last modification: $DateTime: 2011/05/30 11:41:41 $
  * Last modified by:  $Author: bihui.luo $
  *
  * This class is used to initialise a session in the 
  * background.
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioSessionInitialisationThread.cpp
//  Implementation of the Class RadioSessionInitialisationThread
//  Generated by Enterprise Architect
//  Created on:      06-Nov-2003 15:17:11
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#ifdef __WIN32__
#pragma warning(disable:4786)
#endif

#include "app/radio/RadioTetraAgent/src/RadioSessionInitialisationThread.h"

#include "core/utilities/src/DebugUtil.h"
#include "core/utilities/src/RunParams.h"

using namespace TA_IRS_App;

using TA_Base_Core::DebugUtil;

RadioSessionInitialisationThread::RadioSessionInitialisationThread(RadioSession& radioSession)
: m_radioSession(radioSession),
  m_terminateThread(false),
  m_initialiseRetryDelay(10),
  m_semaphore(0),
  m_hasTriedLogin(true)
{
	FUNCTION_ENTRY("Constructor");

    // retrieve from runtime parameters if possible
    std::string initialiseRetryDelayStr = TA_Base_Core::RunParams::getInstance().get("InitialiseRetryDelay");
    if ( !initialiseRetryDelayStr.empty() )
    {
        long temp = atol(initialiseRetryDelayStr.c_str());

        if (temp > 0)
        {
            m_initialiseRetryDelay = temp;
        }
    }
    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "initialiseRetryDelay set to %d", m_initialiseRetryDelay );

	FUNCTION_EXIT;
}


RadioSessionInitialisationThread::~RadioSessionInitialisationThread()
{
	FUNCTION_ENTRY("Destructor");
    terminateAndWait();
	FUNCTION_EXIT;
}


void RadioSessionInitialisationThread::run()
{
	FUNCTION_ENTRY("run");

    m_terminateThread = false;
    requestedOperation tempDestinationState = InitialiseSession;
	if(!m_radioSession.isInitialised())//Queue Session Initialization... If the radio session is not yet initialized.
		processSessionInit(InitialiseSession);
    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug,
        "RadioSessionInitialisationThread for session %s started",
        m_radioSession.getSessionEntityName().c_str() );

    // this is the running loop, oly exited on shutdown
	std::pair<SessionReference,SessionReference> sessionRef;

    while (false == m_terminateThread)
    {
		TA_Base_Core::Thread::sleep( m_initialiseRetryDelay * 1000 );

		{
//			TA_Base_Core::ThreadGuard guard(m_requestStateLock);

			while (shouldAttemptProcess())
			{
				m_semaphore.timedWait(m_initialiseRetryDelay * 1000);

				if ( m_radioSession.isLoggedIn())
				{
					m_radioSession.onSessionStatusChange( SessionStatusOK );
				} 
				else
				{
					m_radioSession.onSessionStatusChange( SessionNotLogin );
				}

				try
				{
                    {   //limin++ CL-21770
                        TA_THREADGUARD( m_destinationStateQueueLock );
                        
                        if ( false == m_destinationStateQueue.empty() )
                        {
                            m_destinationState = m_destinationStateQueue.front();
                            m_destinationStateQueue.pop();
                            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo,
                                "[m_destinationState=%d][m_destinationStateQueue.size=%d]", m_destinationState, m_destinationStateQueue.size() );
                        }
						else	
						{
							if((m_destinationState==DetachSession || m_destinationState==LogoutSession) || m_radioSession.isLoggedIn())
							continue; //[Raghu] CL-21460 -- We have to continue waiting as we dont have a request to change our state.
						}
                        
                        tempDestinationState = m_destinationState;
                    }   //++limin CL-21770

					switch( tempDestinationState )
					{
						case InitialiseSession:
						case LoginSession:
							if ( !m_radioSession.isAttached() || !m_radioSession.isInitialised() )
							{
								if (m_radioSession.doAttachSession(sessionRef) && m_radioSession.doInitialiseSession())
								{
									LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug,
										"RadioSessionInitialisationThread, session: %s, ref: %d attached and initialized", 
										m_radioSession.getSessionEntityName().c_str(), sessionRef.second);
								}
								else if (shouldAttemptProcess())
								{
									LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo,
										"RadioSessionInitialisationThread for session: %s, ref: %d waiting for retry %d seconds",
										m_radioSession.getSessionEntityName().c_str(),
										sessionRef.second,
										m_initialiseRetryDelay );
									m_semaphore.timedWait(m_initialiseRetryDelay * 1000);
									continue;
								}
							}
							else
							{
								LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "RadioSession %s Attach: Intialised = %s.", 
									m_radioSession.getSessionEntityName().c_str(), m_radioSession.isAttached()?"true":"false" );
							}
							
							if (m_radioSession.isInitialised() && !m_radioSession.isLoggedIn())
							{
								m_radioSession.doLoginSession(sessionRef.first);
								
								if (shouldAttemptProcess() && !m_radioSession.isLoggedIn())
								{
									LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo,
										"RadioSessionInitialisationThread for session: %s, ref: %d waiting for retry %d seconds",
										m_radioSession.getSessionEntityName().c_str(),
										sessionRef.second,
										m_initialiseRetryDelay );
									
									if ( m_radioSession.getIsISCSSession() || m_destinationState == LoginSession )
									{
										m_semaphore.timedWait(m_initialiseRetryDelay * 1000);
										continue;
									}
								}
							} 
							else
							{
								LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug,"RadioSession %s Login: IsLoggedIn = %s",
									m_radioSession.getSessionEntityName().c_str(), m_radioSession.isLoggedIn()?"true":"false" );
							}
							break;

						case LogoutSession:
							if (m_radioSession.isLoggedIn())
							{
								m_radioSession.doLogoutSession();
								LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo,
									"Request to logout RadioSession %s ",
									m_radioSession.getSessionEntityName().c_str() );
							}
							else
							{
								LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn,
									"Request to logout RadioSession %s while it is not logged in",
									m_radioSession.getSessionEntityName().c_str() );
							}

							break;

						case DetachSession:
							if (m_radioSession.isAttached())
							{
								m_radioSession.doDetachSession();

								LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo,
									"Request to detach RadioSession %s ",
									m_radioSession.getSessionEntityName().c_str() );
							} 
							else
							{
								LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn,
									"Request to detach RadioSession %s while it is not attached",
									m_radioSession.getSessionEntityName().c_str() );
							}
							break;

						default:
							LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn,
								"Not a valid request for RadioSessionInitialisationThread");
							break;
						}

						LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn,
							"Process completed for RadioSessionInitialisationThread");
					break;
				}
				catch ( ... )
				{
					LOG_GENERIC(SourceInfo, DebugUtil::DebugWarn, "RadioSessionInitialisationThread: Got unknown error of session: %s", m_radioSession.getSessionEntityName().c_str() );
				}
			}
		}
	}

	FUNCTION_EXIT;
}


void RadioSessionInitialisationThread::processSessionInit(requestedOperation destinationState)
{
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "RadioSessionInitialisationThread, requested state: %d", destinationState); 

	if ( destinationState >= m_destinationState )
	{
		//Just overwrite here.
		LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, 
			"RadioSessionInitialisationThread, session: %s, requested state replaced by %d, Original: %d", 
			m_radioSession.getSessionEntityName().c_str(), destinationState, m_destinationState );
	} 
	else
	{
	//	TA_Base_Core::ThreadGuard guard(m_requestStateLock);

		LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, 
			"RadioSessionInitialisationThread, session: %s, requested state change to %d, Original: %d", 
			m_radioSession.getSessionEntityName().c_str(), destinationState, m_destinationState );
	}

    {   // limin++ CL-21170
        TA_THREADGUARD( m_destinationStateQueueLock );
        m_destinationStateQueue.push( destinationState );

        m_destinationState = destinationState;
    }   //++limin CL-21170

	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "RadioSessionInitialisationThread, current requested state: %d", m_destinationState); 

	// just give it a poke...
	m_semaphore.post();
}


void RadioSessionInitialisationThread::terminate()
{
	FUNCTION_ENTRY("terminate");

    // set the flag
    m_terminateThread = true;

    // unblock the thread
    m_semaphore.post();

	FUNCTION_EXIT;
}


bool RadioSessionInitialisationThread::shouldAttemptProcess()
{

	LOG_GENERIC (SourceInfo, TA_Base_Core::DebugUtil::DebugTrace, 
		"[shouldAttemptLogin] m_terminateThread = %d, request Detach - %s.", 
		m_terminateThread, (m_destinationState == DetachSession)?"true":"false");

    return ( !m_terminateThread &&
             m_radioSession.shouldLogIn() );
}

