/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File$
  * @author:  Andy Parker
  * @version: $Revision$
  *
  * Last modification: $DateTime$
  * Last modified by:  $Author$
  *
  * This class is used to manage radio resources.
  * We need to know what audio channels are available to use for calls and
  * which need releasing when voice calls complete.  The Radio class
  * and radio session will need to use this manager.
  *
  * Also SDS resources must be released.
  *
  * We need this to be a thread as we cannot use the incoming radio event (TCP thread)
  * to send synchronous messages to the train as it will block stopping further TCP
  * receipt, i.e. it will never get its reply!
  */

///////////////////////////////////////////////////////////
//
//  RadioConnectionManager.cpp
//  Implementation of the Class RadioResourceManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#ifdef __WIN32__
#pragma warning(disable:4786)
#endif

#include "core/synchronisation/src/ThreadGuard.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/data_access_interface/entity_access/src/IRadioEntityData.h"
#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"
#include "app/radio/RadioTetraAgent/src/RadioResourceManager.h"
#include "app/radio/RadioTetraAgent/src/RadioTcpServer.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionHelper.h"
#include "app/radio/RadioTetraAgent/src/RadioStateUpdateBroadcaster.h"
#include "app/radio/RadioTetraAgent/src/RadioSynchronisationTypes.h"



/**
* This class will be used to manage the audio references
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:43:57
*/

using namespace TA_IRS_App;

/*
* Constructor
*
* This function adds an audio reference to the list of managed audio connections.
* @param   radio   Need to access the sendCommand method by the run method.
*/
RadioResourceManager::RadioResourceManager(RadioTcpServer& radio) 
					 : m_workQueueSemaphore(0),
					   m_terminate(false),
					   m_radio(radio)
{
    FUNCTION_ENTRY("Constructor");
	m_currentAudioVolume = m_DefaultVolume = m_radio.getRadio().getDefaultVolume();
	// Start the background thread to process the requests
	start();
    FUNCTION_EXIT;
}


RadioResourceManager::~RadioResourceManager()
{
    FUNCTION_ENTRY("Destructor");
	// Stop the background thread
	terminate();

	// Release the audio maps
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.begin();
	while (sessionIT != m_sessionAudioMap.end())
	{
		delete sessionIT->second;
		sessionIT->second = NULL;
		sessionIT++;
	}

    FUNCTION_EXIT;
}


/**
* This function adds the audio references associated with a session.
* @param   SessionRef    indicates the owner session
*/
void RadioResourceManager::addAudioReferences(SessionReference SessionRef)
{
    FUNCTION_ENTRY("addAudioReferences");

	// Remove any existing ones
	deleteAudioReferences(SessionRef);

	// Need to perform a query reference on the operator's session reference.
	RadioMethodQueryReference queryReferenceMethod(SessionRef);
    queryReferenceMethod.setQueryType(RadioMethodQueryReference::K_CHANNELS);
	queryReferenceMethod.setQueryReference(SessionRef);
	RadioEvent* reply = m_radio.sendMethod(queryReferenceMethod);

    // The reply should have the list of audio references as text
    QueryReferenceEventReader* queryReferencereader = dynamic_cast<QueryReferenceEventReader*>(reply->getEventReader());
	TA_ASSERT(queryReferencereader!=NULL,"Incorrect reply for message");
	std::vector<std::string> resultList = queryReferencereader->getDetailsList(char(10));

    // Delete the reply
    delete reply;
    reply = NULL;

	// Now get a reference for each of the text audio references
	std::vector<std::string>::iterator  it = resultList.begin();
	while (it != resultList.end())
	{
		if (strlen(it->c_str())>0)
		{
			// Get audio reference from radio system
			RadioMethodTextToReference textToRef(SessionRef,*it);
			RadioEvent* reply = m_radio.sendMethod(textToRef);

			// The reply will contain the subscriber reference
			TextToReferenceEventReader textToRefReader(*reply);
			AudioReference audioRef = textToRefReader.getReference();

			// Delete the reply
			delete reply;
			reply = NULL;

			// Add to manager
			addAudioReference(SessionRef,audioRef);
		}

		it++;
	}
}



/**
* This function removes all audio references for a session.
* @param   SessionRef    indicates the owner session
*/
void RadioResourceManager::deleteAudioReferences(SessionReference SessionRef)
{
    FUNCTION_ENTRY("deleteAudioReferences");
	// Lock the store
	TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

	// Find the audio map for the session
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(SessionRef);
	if (sessionIT!=m_sessionAudioMap.end())
	{
		AudioEntryMap* audioMap;
		audioMap = sessionIT->second;
		m_sessionAudioMap.erase(sessionIT);
		sendRemoveSessionFromAudioMap(SessionRef);
		delete audioMap;
	}
	else
	{
		// Not found - this is ok as we just ensuring cleanup
		//TA_ASSERT(false,"Audio map not defined for this session");
	}
    FUNCTION_EXIT;
}



/**
* This function attaches an audio reference to a call.
* @param   SessionRef    indicates the owner session
* @param   CallRef       call reference to be assoicated with the audio reference
*/
void RadioResourceManager::attachAudio(SessionReference sessionRef, CallReference callRef)
{
    FUNCTION_ENTRY("attachAudio");

	unsigned long audioRef=0;

	bool found = false;
	{ // Set locking scope

		// Lock the store
		TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

		// Find the audio map for the session
		SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionRef);
		if (sessionIT==m_sessionAudioMap.end())
		{
			// Map not found for session
//			TA_ASSERT(false,"Audio map not defined for this session"); 
			// Replace Assert with error log for TD9016
	        LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugError,"Audio map not defined for session %d",sessionRef);
			return;
		}

		// Find unused entry in map
		AudioEntryMap::iterator audioIT  = sessionIT->second->begin();
		while (audioIT != sessionIT->second->end())
		{
			if (!audioIT->second.inUse)
			{
				// Found one
				audioIT->second.inUse   = true;
				audioIT->second.callRef = callRef;
				// RvH 20050202 Radio iFAT
				// Set per-call volume to the default.
				//TD10963 marc_bugfix get the default volume from the configuration 
				//audioIT->second.volume = m_currentAudioVolume = 8;
				audioIT->second.volume = m_currentAudioVolume = (int)m_DefaultVolume;
				LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugInfo,
				        "Default Volume is %i", (int)m_DefaultVolume);


				audioRef = audioIT->first; 
				found = true;
				sendUpdateAudioEntry(sessionRef, audioRef, audioIT->second);
				break;
			}

			audioIT++;
		}

		if (!found)
		{
			// No available audio resource - throw an exception
			//TA_THROW();
			return;
		}
		else
		{
			// Attach the audio at the radio
			RadioMethodAttachAudio attachAudioMethod(sessionRef,callRef,audioRef);
			RadioEvent* reply = m_radio.sendMethod(attachAudioMethod);
			delete reply;
		}
	}

    FUNCTION_EXIT;
}


/**
* This function releases the use of the audio reference.
*
* It may not do it directly but place it onto a separate thread to be processed
* as it might be necessary to make radio method calls
* 
* @param   SessionRef    indicates the owner session
* @param   CallRef       call reference to be assoicated with the audio reference
* @param   direct        indicates if action should be done on the calling thread (direct) or indirect by the manager thread
*/
void RadioResourceManager::releaseAudioReference(SessionReference sessionRef, CallReference callRef, bool direct, bool isMonitored)
{
    FUNCTION_ENTRY("releaseAudioReference");

	if (direct)
	{
		// Call direct as it is not necessary to  send the detachAudio message to
		// radio according to their docs.
        if (!isMonitored)
        {
            detachAudio(sessionRef,callRef,direct);
        }
        else
        {
            detachMonitorAudio(sessionRef,callRef,direct);
        }
	}
	else
	{
		// Place request on queue
		WorkRequestEntry   job;
		job.request    = (isMonitored) ? DETACH_MONITOR_AUDIO : DETACH_AUDIO;
		job.sessionRef = sessionRef;
		job.callRef    = callRef;
		job.sdsRef     = 0;

		{ // Nest for small scope of lock
			// Add job to queue
			TA_Base_Core::ThreadGuard  guard(m_workQueueLock);
			m_workQueue.push_back(job);
		}

		// Tell background thread to do it
		m_workQueueSemaphore.post();
	}

    FUNCTION_EXIT;
}


/**
* This function directs the audio to the specified speaker.
* Generally, selected calls are heard on the right speaker, whilst deselected calls are 
* heard on the left speaker.
* 
* @param   SessionRef    indicates the owner session
* @param   CallRef       call reference to be assoicated with the audio reference
* @param   rightSpeaker  indicates if right speaker should be used for call (false=left speaker)
*/
void RadioResourceManager::setAudioSpeaker(SessionReference sessionRef,CallReference callRef,bool rightSpeaker, int volumeDelta)
{
    FUNCTION_ENTRY("setAudioSpeaker");

	// Lock the store
	TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

	// Find the audio map for the session
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionRef);
	if (sessionIT==m_sessionAudioMap.end())
	{
		// Map not found for session
//		TA_ASSERT(false,"Audio map not defined for this session");
        LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugError,"Audio map not defined for this session %d",sessionRef);
		return;
	}

	// Get current audio settings
	bool found = false;
	AudioReference  audioRef;
    int newCallVolume = 0;
	// Find the audio reference 
	AudioEntryMap::iterator audioIT;
	for ( audioIT = sessionIT->second->begin() ;
	      audioIT != sessionIT->second->end() ;
          audioIT++ )
	{
		if ( audioIT->second.callRef == callRef )
		{
			// Found call
			audioRef = audioIT->first;
            newCallVolume = audioIT->second.volume + volumeDelta;
			found = true;
			break;
		}
	}

	if (!found)
	{
		// No audio associated with this call
		// TODO - is this possible or is it an error?
        // RvH 20050202 Radio-iFAT
        // This is possible. If the call has been previously released, the
        // RadioManager will still call deselect on the session which will in
        // turn call this function with a call reference that no longer exists
		//TA_THROW();
	}
	else
	{
		// Set speaker volumes
		int lVolume = rightSpeaker ? 0 : newCallVolume;
		int rVolume = rightSpeaker ? newCallVolume : 0;

		// Set the speaker volumes
		RadioMethodChangeReference changeReference(sessionRef,audioRef);
		changeReference.setAudioVolume(lVolume,rVolume);
		RadioEvent * reply = m_radio.sendMethod(changeReference);
		delete reply;

        // if we got this far then the volume change was successful
        audioIT->second.volume = newCallVolume;
		sendUpdateAudioEntry(sessionRef, audioRef, audioIT->second);
        LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugInfo,
                "Volume for call %lu session %lu changed to %d",
                callRef, sessionRef, audioIT->second.volume);
	}

	
	FUNCTION_EXIT;

}

/**
* This function adjusts the audio volume.  The new volume level will be used for subsequent calls.
* 
* @param   SessionRef    indicates the owner session
* @param   CallRef       call reference to be assoicated with the audio reference
* @param   increaseVolume  indicates if volume should increase (true) or decrease (false)
*/
void RadioResourceManager::adjustAudioVolume(SessionReference sessionRef,CallReference callRef,bool increaseVolume)
{
    FUNCTION_ENTRY("adjustAudioVolume");

    int delta = 0;
	// Adjust the current volume setting
	if (increaseVolume)
	{
		m_currentAudioVolume++;
		delta=+1;
	}
	else
	{
		m_currentAudioVolume--;
		delta=-1;
	}

	// Adjust the call - it will be a selected call!
	setAudioSpeaker(sessionRef,callRef,true,delta);
	sendUpdateAudioVolume(sessionRef,callRef,m_currentAudioVolume);
}

/**
* This function releases the reference associated with a sds message.
* It will not do it directly but place it onto a separate thread to be processed
* 
* @param   SessionRef    indicates the owner session
* @param   CallRef       call reference to be assoicated with the audio reference
*/
void RadioResourceManager::releaseSDSReference(SessionReference SessionRef, SDSReference sdsRef)
{
    FUNCTION_ENTRY("releaseSDSReference");
	// Place request on queue
	WorkRequestEntry   job;
	job.request    = DELETE_SDS;
	job.sessionRef = SessionRef;
	job.callRef    = 0;
	job.sdsRef     = sdsRef;

	{ // Nest for small scope of lock
		// Add job to queue
		TA_Base_Core::ThreadGuard  guard(m_workQueueLock);
		m_workQueue.push_back(job);
	}

	// Tell background thread to do it
	m_workQueueSemaphore.post();
    FUNCTION_EXIT;
}

//******************
// Private Methods *
//******************

/*
 * Method performing the background work
 */
void RadioResourceManager::run()
{
    FUNCTION_ENTRY("run");
	while (!m_terminate)
	{
		// Wait for some work to do
		m_workQueueSemaphore.wait();

		if (!m_terminate)
		{
			// Get job from queue - nest for scope of lock
			WorkRequestEntry  job;
			{
				TA_Base_Core::ThreadGuard  guard(m_workQueueLock);
				TA_ASSERT(m_workQueue.size()>0,"No work in resource manager queue");
				job = m_workQueue.at(0);
				m_workQueue.erase(m_workQueue.begin());
			}

			try
			{
				switch (job.request)
				{
					case DETACH_AUDIO:
						detachAudio(job.sessionRef,job.callRef,false);
						break;

					case DETACH_MONITOR_AUDIO:
						detachMonitorAudio(job.sessionRef,job.callRef,false);
						break;

					case DELETE_SDS:
						deleteSDS(job.sessionRef,job.sdsRef);
						break;

					default:
						TA_ASSERT(false,"Invalid job request type");
				}
			}
			catch (...)
			{
				// Don't want anything to kill our thread - e.g. timeout talking to RCS
				LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,"RadioResourceManager - Exception received when processing job");
			}
		}
	}

	m_terminate = false;
    FUNCTION_EXIT;
}

/*
 * Stop backgroung processing
 */
void RadioResourceManager::terminate()
{
    FUNCTION_ENTRY("terminate");
	m_terminate = true;

	// wake up queue
	m_workQueueSemaphore.post();
    FUNCTION_EXIT;
}


/**
* This function adds an audio reference to the list of managed audio connections.
* @param   SessionRef    indicates the owner session
* @param   AudioRef      audio reference
*/
void RadioResourceManager::addAudioReference(SessionReference SessionRef,AudioReference AudioRef)
{
    FUNCTION_ENTRY("addAudioReference");

	// Lock the store
	TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

	// Find the audio map for the session
	AudioEntryMap* audioMap;
	{
		SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(SessionRef);
		if (sessionIT!=m_sessionAudioMap.end())
		{
			audioMap = sessionIT->second;
		}
		else
		{
			// New session
			audioMap = new AudioEntryMap();
			TA_ASSERT(audioMap!=NULL,"Unable to create session audio map");
			m_sessionAudioMap[SessionRef] = audioMap;
		}
	}

	// Check audio not already in map
	AudioEntryMap::iterator audioIT  = audioMap->find(AudioRef);
	TA_ASSERT(audioIT==audioMap->end(),"Audio entry already in map");

	// Add new audio to the map
	AudioEntry  entry;
	entry.inUse   = false;
	entry.callRef = 0;
	(*audioMap)[AudioRef] = entry;
	sendUpdateAudioEntry(SessionRef, AudioRef, entry);

    FUNCTION_EXIT;
}


/*
 * This function performs the release of the audio from a call.  When called from a disconnect it cannot be done 
 * directly as calls must go to the radio which would then block the thread (which gets messages from the radio)
 */
void RadioResourceManager::detachAudio(SessionReference sessionRef, CallReference callRef,bool direct)
{
    FUNCTION_ENTRY("detachAudio");

	unsigned long audioRef=0;

	if (direct)
	{
		// Get current audio settings and delete them
		bool found = false;

		// Lock the store
		TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

		// Find the audio map for the session
		SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionRef);
		if (sessionIT==m_sessionAudioMap.end())
		{
			// Map not found for session
			//TA_ASSERT(false,"Audio map not defined for this session");
			LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugError,
				        "Audio map not defined for session %lu", sessionRef);
			return;
		}

		// Find the audio reference 
		AudioEntryMap::iterator audioIT  = sessionIT->second->begin();
		while (audioIT != sessionIT->second->end())
		{
			if (audioIT->second.callRef==callRef)
			{
				// Found call
				audioRef = audioIT->first;
				found = true;
				break;
			}

			audioIT++;
		}

		if (!found)
		{
			// No audio associated with this call
			// TODO - is this possible or is it an error?
			//TA_THROW();
            LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
                    "No audio reference found for call %lu (session %lu)", callRef, sessionRef);
		}
		else
		{
			// Detach the audio at the radio
			RadioMethodDetachAudio detachAudioMethod(sessionRef,callRef,audioRef);
			RadioEvent* reply = m_radio.sendMethod(detachAudioMethod);
			delete reply;
		}
	}
	

    /* int released = */ releaseAudioResources(sessionRef, callRef);

	FUNCTION_EXIT;
}

int RadioResourceManager::releaseAudioResources(SessionReference sessRef, CallReference callRef)
{
    FUNCTION_ENTRY("releaseAudioResources(sessRef, callRef)");

	// Lock the map
	TA_Base_Core::ThreadGuard guard(m_audioMapLock);

	// Find the audio map for the session
	SessionAudioMap::iterator sessionIter = m_sessionAudioMap.find(sessRef);
	if (sessionIter==m_sessionAudioMap.end())
	{
		// Map not found for session
		//TA_ASSERT(false,"Audio map not defined for this session");
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
			        "Audio map not defined for this session");
		return 0;
	}

	// Find and release the audio reference 
    int num_released = 0;
	AudioEntryMap::iterator audioIter  = sessionIter->second->begin();
	while (audioIter != sessionIter->second->end())
	{
		if (audioIter->second.callRef==callRef)
		{
			// Found call
			audioIter->second.inUse = false;
			audioIter->second.callRef = 0;
			audioIter->second.volume = 0;
            num_released++;
			//broadcast the change in AudioEntry
			sendUpdateAudioEntry(sessRef, audioIter->first, audioIter->second);
		}

		audioIter++;
	}

	FUNCTION_EXIT;
    return num_released;
}

void RadioResourceManager::deleteSDS(SessionReference sessionRef, SDSReference sdsRef)
{
    FUNCTION_ENTRY("deleteSDS");

    RadioMethodDeleteReference deleteReferenceMethod(sessionRef);
    deleteReferenceMethod.setReference(RadioMethodDeleteReference::SDS_REFERENCE,sdsRef);

	// remove waiting for transaction once called sendmethod
	// dont care about the return just send
	LOG_GENERIC (SourceInfo,TA_Base_Core::DebugUtil::DebugInfo,"Test DeRef Issue : Using new sendMethod");
	m_radio.sendMethodNoReply(deleteReferenceMethod);
	
	TA_Base_Core::Thread::sleep(20);

    FUNCTION_EXIT;


}

void RadioResourceManager::attachMonitorAudio(SessionReference sessionRef, CallReference callRef, bool full)
{
    FUNCTION_ENTRY("attachMonitorAudio");

    unsigned long audioRef[2]= {0, 0};

    int foundnum = 0;
    int required = (full) ? 2 : 1;
    { // ThreadGuard scope

        // Lock the store
        TA_Base_Core::ThreadGuard guard(m_audioMapLock);

        // Find the audio map for the session
        SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionRef);
        //TA_ASSERT((sessionIT!=m_sessionAudioMap.end()),"Audio map not defined for this session");
        if (sessionIT==m_sessionAudioMap.end())
        {
            LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
                        "Audio map not defined for session %lu",
                        sessionRef);
            return;
        }

        // Find unused entry in map
        AudioEntryMap::iterator audioIter  = sessionIT->second->begin();
        while ((audioIter != sessionIT->second->end()) && (foundnum < required))
        {
            if (!audioIter->second.inUse)
            {
                // Found one
                audioIter->second.inUse   = true;
                audioIter->second.callRef = callRef;
				// RvH 20050202 Radio iFAT
				// Set per-call volume to the default.
				//TD10963 marc_bugfix
				
				//TD10963 marc_bugfix get the default volume from the configuration 
				//audioIter->second.volume = m_currentAudioVolume = 8;
				audioIter->second.volume = m_currentAudioVolume = (int)m_DefaultVolume;


                audioRef[foundnum] = audioIter->first; 

                foundnum++;

				//broadcast the change in AudioEntry
				sendUpdateAudioEntry(sessionRef, audioIter->first, audioIter->second);
				LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,
							"attachMonitorAudio() - Looking for %d audio resources, found %d", required, foundnum);

                if (foundnum>=required)
                {
                    break;
                }
            }

            audioIter++;
        }

		if (foundnum<required)
		{
			// insufficient audio resources - throw an exception

			LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
						"attachMonitorAudio() - Required %d audio resources, found %d", required, foundnum);

			// TA_THROW();
			return;
		}
		else
		{
			LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
						"attachMonitorAudio() - Attaching %d audio resources for callRef %lu, audioRef[%lu,%lu]", required, callRef, audioRef[0], audioRef[1]);
			// Arrange for the RCS to attach audio for us
			RadioMethodAttachMonitorAudio attachMonAudioMethod(sessionRef,callRef,audioRef[0],audioRef[1]);
			RadioEvent * reply = m_radio.sendMethod(attachMonAudioMethod);
			delete reply;

		}
    }

    FUNCTION_EXIT;
}


void RadioResourceManager::detachMonitorAudio(SessionReference sessionRef, CallReference callRef, bool direct)
{
    FUNCTION_ENTRY("detachMonitorAudio");

    if (direct)
    {
        // Get current audio settings and delete them
        int numfound = 0;
        unsigned long audioRef[2] = {0, 0};

        // Lock the store
        TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

        // Find the audio map for the session
        SessionAudioMap::iterator sessionIter = m_sessionAudioMap.find(sessionRef);
        // TA_ASSERT((sessionIter!=m_sessionAudioMap.end()),"Audio map not defined for this session");
        if (sessionIter==m_sessionAudioMap.end())
        {
            LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn, "Audio map not defined for session 0x%X", sessionRef);
            return;
        }

        // Find the audio reference 
        for ( AudioEntryMap::iterator audioIter = sessionIter->second->begin();
              audioIter != sessionIter->second->end() ;
              audioIter++
            )
        {
            if (audioIter->second.callRef == callRef)
            {
                // Found call
                audioRef[numfound] = audioIter->first;
                numfound++;
            }
        }

        if (numfound>0)
        {
            // Request the radio to detach the monitor audio
            RadioMethodDetachMonitorAudio detachMonitorAudioMethod(sessionRef,callRef);
            RadioEvent* reply = m_radio.sendMethod(detachMonitorAudioMethod);
            delete reply;
        }
        else
        {
            // No audio associated with this call
            // TODO - is this possible or is it an error?
            //TA_THROW();
            LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
                    "No audio reference found for call 0x%X (session 0x%X)", callRef, sessionRef);
        }
    }

    /* int released = */ releaseAudioResources(sessionRef, callRef);

    FUNCTION_EXIT;
}

void RadioResourceManager::applyFullState(const RadioResourceManagerType& state)
{
	
	FUNCTION_ENTRY("applyFullState");
	
	clearFullState();
	
	this->m_currentAudioVolume = state.currentAudioVolume;
	
	SessionAudioMapType::const_iterator sourceSessionIT =state.sessionAudioMap.begin();
	
	while (sourceSessionIT != state.sessionAudioMap.end())
	{
		SessionReference sessionRef = sourceSessionIT->first.sessionRef;
		AudioEntryMapType::const_iterator sourceAudioMapIT = (sourceSessionIT->second).begin();
		//Allocate space for the Destination audioEntryMap
		AudioEntryMap *pAudioEntryMap = new AudioEntryMap();
		while(sourceAudioMapIT != (sourceSessionIT->second).end())
		{
			//copy the source AudioEntry struct to the Destination AudioEntry struct
			AudioReference audioRef = sourceAudioMapIT->first;
			AudioEntry audioEntry;
			audioEntry.callRef = (sourceAudioMapIT->second).callRef;
			audioEntry.inUse =	(sourceAudioMapIT->second).inUse ;
			audioEntry.volume = (sourceAudioMapIT->second).volume;
			//Build the audioEntryMap
			(*pAudioEntryMap).insert(std::pair<AudioReference, AudioEntry>(audioRef,audioEntry));
			++sourceAudioMapIT;
		}
		//Build the sessionAudioMap
		m_sessionAudioMap.insert(std::pair<SessionReference, AudioEntryMap*>(sessionRef,pAudioEntryMap));
		
		++sourceSessionIT;
		
	}
	
	FUNCTION_EXIT;
}

void RadioResourceManager::clearFullState()
{
	FUNCTION_ENTRY("clearFullState");
	
	//m_currentAudioVolume = 8;//default value
	//TD10963 marc_bugfix support for default volume
	m_currentAudioVolume = (int)m_DefaultVolume;

	// Releases the audio maps
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.begin();
	while (sessionIT != m_sessionAudioMap.end())
	{
		delete sessionIT->second;
		sessionIT->second = NULL;
		sessionIT++;
	}
	m_sessionAudioMap.clear();
	
	FUNCTION_EXIT;
}

void RadioResourceManager::getFullState(RadioResourceManagerType& state,
							  const std::map<SessionReference,ConsoleID>& sessions)
{
	FUNCTION_ENTRY("getFullState");

	state.currentAudioVolume = this->m_currentAudioVolume;
	
	state.sessionAudioMap.clear();

	SessionAudioMapType::iterator destSessionIT = state.sessionAudioMap.begin();
	
	// copy from m_sessionAudioMap
	SessionAudioMap::iterator sourceSessionIT = m_sessionAudioMap.begin();

	while(sourceSessionIT != m_sessionAudioMap.end())
	{
		TA_IRS_App::SessionID sessionRef = sourceSessionIT->first;

		ConsoleID consoleKey = 0;
		std::map<SessionReference,ConsoleID>::const_iterator sMap = sessions.find(sessionRef);
		if (sMap != sessions.end())
		{
			consoleKey = sMap->second;
		}

		AudioEntryMap::iterator sourceAudioMapIT = sourceSessionIT->second->begin();
		TA_IRS_App::AudioEntryMapType audioEntryMap;
		//Iterate over the source m_sessionAudioMap to be inserted into destination sessionAudioMap

		while( sourceAudioMapIT != sourceSessionIT->second->end())
		{
			TA_IRS_App::AudioReference audioRef = sourceAudioMapIT->first;
			TA_IRS_App::AudioEntryType audioEntry;
			audioEntry.callRef = sourceAudioMapIT->second.callRef; 
			audioEntry.inUse = sourceAudioMapIT->second.inUse;
			audioEntry.volume = sourceAudioMapIT->second.volume;

			//Build the audioEntry Map
			audioEntryMap.insert(std::pair<TA_IRS_App::AudioReference, TA_IRS_App::AudioEntryType>(audioRef,audioEntry));
			++sourceAudioMapIT;
		
		}

		ConsoleSessionRef csRef;
		csRef.consoleKey = consoleKey;
		csRef.sessionRef = sessionRef;
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,
			"RadioAudioResourceManager::getFullState insert(Console %d, Session %d on TcpServer %d)",consoleKey,sessionRef,m_radio.getServerIndex());
		
		//sessionAudioMap
		state.sessionAudioMap.insert(std::pair<ConsoleSessionRef, TA_IRS_App::AudioEntryMapType>(csRef,audioEntryMap));
		++sourceSessionIT;
		
	}
		
	FUNCTION_EXIT;
}


void RadioResourceManager::sendRemoveSessionFromAudioMap(SessionReference sessionReference)
{
	FUNCTION_ENTRY("sendRemoveSessionFromAudioMap");

	RadioRemoveSessionFromAudioMap message;
	message.sessionReference = sessionReference;
	message.serverIndex = m_radio.getServerIndex();
	RadioStateUpdateBroadcaster::getInstance()->sendRadioRemoveSessionFromAudioMap(message);

	FUNCTION_EXIT;
}


void RadioResourceManager::sendUpdateAudioVolume(SessionReference sessionReference,
												 CallReference callReference, int currentVolume )
{
	FUNCTION_ENTRY("sendUpdateAudioVolume");

	RadioUpdateRadioResourceManagerVars message;
	message.sessionReference = sessionReference;
	message.callReference = callReference;
	message.currrentVolume = currentVolume;
	message.serverIndex = m_radio.getServerIndex();
	RadioStateUpdateBroadcaster::getInstance()->sendRadioUpdateRadioResourceManagerVars(message);

	FUNCTION_EXIT;
}

void RadioResourceManager::updateAudioEntryInSessionMap(SessionID sessionReference, 
														AudioReference audioReference,
														const TA_IRS_App::AudioEntryType& audioEntry)
{
	FUNCTION_ENTRY("updateAudioEntryInSessionMap");
	
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionReference);
	
	//if the sessionReference is found
	if(sessionIT != m_sessionAudioMap.end())
	{
		AudioEntryMap::iterator audioMapIT = (*sessionIT->second).find(audioReference);

		//if the audioReference is found
		if(audioMapIT != sessionIT->second->end())
		{
			audioMapIT->second.callRef = audioEntry.callRef;
			audioMapIT->second.inUse = audioEntry.inUse;
			audioMapIT->second.volume = audioEntry.volume;
		}
		// If audioReference not found - create a audioEntry struct and insert into AudioEntryMap
		else
		{
			AudioEntry localAudioEntry;
			localAudioEntry.callRef = audioEntry.callRef;
			localAudioEntry.inUse = audioEntry.inUse;
			localAudioEntry.volume = audioEntry.volume;
			(*sessionIT->second).insert(std::pair<AudioReference, AudioEntry>(audioReference,localAudioEntry));
		}
	}
	//if the SessionReference not found - create a audioEntryMap and insert into the sessionAudioMap
	else
	{
		AudioEntryMap *pAudioEntryMap = new AudioEntryMap();
		AudioEntry localAudioEntry;
		localAudioEntry.callRef = audioEntry.callRef;
		localAudioEntry.inUse = audioEntry.inUse;
		localAudioEntry.volume = audioEntry.volume;
		(*pAudioEntryMap).insert(std::pair<AudioReference, AudioEntry>(audioReference,localAudioEntry));
		m_sessionAudioMap.insert(std::pair<SessionReference, AudioEntryMap*>(sessionReference,pAudioEntryMap));
	}



	
	FUNCTION_EXIT;
	
}
			

//
// Big WTF here.
// 1. this should be called "updateCallVolume"
// 2. the outer for loop and if conditional should just be a m_sessionAudioMap.find()
// two other simple pieces of logic now fixed:
void RadioResourceManager::updateCallVolume(SessionID sessionReference, 
                                                 TA_IRS_App::CallReference callReference,
                                                 int currentVolume)
{
	FUNCTION_ENTRY("updateRadioAudioResourceManagerVars");
	
	
	//check for sesssionReference in m_sessionAudioMap;
	
    // iterate over the SessionAudioMap
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.begin();
	for ( ; sessionIT != m_sessionAudioMap.end(); sessionIT++)
	{
		// if this session matches the given one,
		if(sessionIT->first == sessionReference)
		{
			// iterate over the calls within the AudioEntryMap of that session
			AudioEntryMap::iterator audioMapIT = sessionIT->second->begin();
			for ( ; audioMapIT != sessionIT->second->end() ; audioMapIT++ )
			{
                // if the CallID matches the call in the audioentry,
				unsigned long destCallRef = audioMapIT->second.callRef;
				if(destCallRef == callReference)
				{
                    // update the volume
					audioMapIT->second.volume = currentVolume;
					break;
				}
			}
		}
	}

	FUNCTION_EXIT;
}


void RadioResourceManager::removeSessionFromAudioMap(SessionID sessionReference)
{
	FUNCTION_ENTRY("removeSessionFromAudioMap");

	TA_Base_Core::ThreadGuard  guard(m_audioMapLock);

	// Find the audio map for the session
	SessionAudioMap::iterator sessionIT = m_sessionAudioMap.find(sessionReference);
	if (sessionIT!=m_sessionAudioMap.end())
	{
		AudioEntryMap* audioMap;
		audioMap = sessionIT->second;
		m_sessionAudioMap.erase(sessionIT);
		delete audioMap;
	}
	else
	{
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,
                    "The sessionReference 0x%X is not found",sessionReference);
	}

	FUNCTION_EXIT;
}


void RadioResourceManager::sendUpdateAudioEntry(SessionReference sessionReference, 
												AudioReference audioReference, const AudioEntry& audioEntry)
{
	FUNCTION_ENTRY("sendUpdateAudioEntry");

	RadioUpdateAudioEntryInSessionAudioMap message;
	message.sessionReference = sessionReference;
	message.audioReference = audioReference;
	message.audio.callRef = audioEntry.callRef;
	message.audio.inUse = audioEntry.inUse;
	message.audio.volume = audioEntry.volume;
	RadioStateUpdateBroadcaster::getInstance()->sendRadioUpdateAudioEntryInSessionAudioMap(message);

	FUNCTION_EXIT;
}



