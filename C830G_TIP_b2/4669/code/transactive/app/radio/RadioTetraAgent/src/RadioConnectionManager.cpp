///////////////////////////////////////////////////////////
//
//  RadioConnectionManager.cpp
//  Implementation of the Class RadioConnectionManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#include "app/radio/RadioTetraAgent/src/RadioConnectionManager.h"
#include "app/radio/RadioTetraAgent/src/RadioConnectionException.h"

#include "core/threads/src/Thread.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/alarm/src/AlarmHelperManager.h"
#include "core/alarm/src/AlarmHelper.h"
#include "core/message/types/RadioAlarms_MessageTypes.h"
#include "core/message/src/NameValuePair.h"

#include "app/radio/RadioTetraAgent/src/RadioConnectionManager.h"
#include "app/radio/RadioTetraAgent/src/RadioStateUpdateBroadcaster.h"
#include "app/radio/RadioTetraAgent/src/RadioTransactionManager.h"

using namespace TA_IRS_App;
using TA_Base_Core::DebugUtil;


RadioConnectionManager::RadioConnectionManager(RadioTcpServer& TCPServer)
: m_primaryConnection(0),
  m_secondaryConnection(0),
  m_active(0),
  m_currentConnection(0),
  m_waitForConnection(true),
  m_tcpServer(TCPServer),
  m_objectName(""),
  m_entityKey(0),
  m_entityLocation(0),
  m_entitySubsystem(0),
  m_entityTypeKey(0),
  m_controlConnectionStatus(NoAppliable),
  m_isConnected(false)
{
	FUNCTION_ENTRY("Constructor");
	m_observers.clear();
	FUNCTION_EXIT;
}

void RadioConnectionManager::setEntity(TA_Base_Core::IEntityData& entityData)
{
	m_objectName      = entityData.getName();
	m_entityKey       = entityData.getKey();
	m_entityLocation  = entityData.getLocation();
	m_entitySubsystem = entityData.getSubsystem();
	m_entityTypeKey   = entityData.getTypeKey();
}

void RadioConnectionManager::setRadioHost(bool isPrimary,std::string hostAddress)
{
    // basic sanity check : the "host:port" should be at least two characters
    // long. This accounts for entityparametervalues that don't have SIL2
    // integrity
	LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "Entering RadioConnectionManager::setRadioHost, isPrimary = %d, hostAddress = %s",isPrimary,hostAddress.c_str());

    if (hostAddress.size()<2)
    {
        LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "Host address \"%s\" too small, ignoring", hostAddress.c_str());
        if (isPrimary)
        {
            delete m_primaryConnection;
            m_primaryConnection = 0;
        }
        else
        {
            delete m_secondaryConnection;
            m_secondaryConnection = 0;
        }
        return;
    }
	//Separate host and port
	std::string  host;
	std::string  port;
	bool separatorFound=false;   // In this case a :
	for (unsigned int index = 0;index<hostAddress.size();index++)
	{
		if (hostAddress[index]==':')
		{
			separatorFound = true;
		}
		else
			{
			if (separatorFound)
			{
				port += hostAddress[index];
			}
			else
			{
				host += hostAddress[index];
			}
		}
	}

	if (isPrimary)
	{
		//Haipeng added the check to verify whether pointer is NULL
		if (m_primaryConnection != NULL)
		{
			delete m_primaryConnection;
			m_primaryConnection = 0;
		}
		
		m_primaryConnection = new RadioTCPConnection(m_tcpServer, *this, host, port, true);
		m_primaryConnection->setIgnoreIncomingData(!m_active);
	}
	else
	{
		//Haipeng added the check to verify whether pointer is NULL
		if (m_secondaryConnection != NULL)
		{
			delete m_secondaryConnection;
			m_secondaryConnection = 0;
		}
		
		m_secondaryConnection = new RadioTCPConnection(m_tcpServer, *this, host, port, false);
		m_secondaryConnection->setIgnoreIncomingData(!m_active);
	}
}

void RadioConnectionManager::start()
{
    if (m_primaryConnection != NULL)
    {
        m_primaryConnection->start();
    }

    if (m_secondaryConnection != NULL)
    {
        m_secondaryConnection->start();
    }
}

void RadioConnectionManager::setControlConnection(EControlConnectionStatus controlConnectionStatus)
{
	switch(controlConnectionStatus)
	{
	case NoAppliable:
		m_controlConnectionStatus = NoAppliable;
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
			"[update] set current connection NoAppliable.");
		break;
	case ConnectToPrimary:
		m_controlConnectionStatus = ConnectToPrimary;
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
			"[update] set current connection ConnectToPrimary.");
		break;
	case ConnectToSecondary:
		m_controlConnectionStatus = ConnectToSecondary;
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
			"[update] set current connection ConnectToSecondary.");
		break;
	default:
		;
	}
	
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );
}

void RadioConnectionManager::onConnectionFail(bool isPrimary)
{
	FUNCTION_ENTRY("onConnectionFail");

	TA_Base_Core::ThreadGuard connectionSwitchGuard(m_connectionSwitchGuard);
	
	LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
		"[Link Lost] connection %s fail. current connection number is %d", 
		(isPrimary ? "Primary" : "secondary"), numConnected() );

	bool isAbleToSwitch = false;

	if ( isPrimary )
	{
		isAbleToSwitch = m_secondaryConnection->isConnected();
	} 
	else
	{
		isAbleToSwitch = m_primaryConnection->isConnected();
	}

	// if no more connections, let general dependents know
    if ( !isAbleToSwitch )
    {
		m_isConnected = false;

		if (m_active)
		{
			m_controlConnectionStatus = NoAppliable;

			RadioConnectionSwitch message;
			message.controlConnectionStatus = m_controlConnectionStatus;
			message.TCPServerIndex = m_tcpServer.getServerIndex();
			RadioStateUpdateBroadcaster::getInstance()->sendRadioConnectionSwitch(message);	
		}

		releaseSendMethod();

		TA_Base_Core::ThreadGuard guard(m_observerGuard);
		std::vector< IRadioConnectionStatusObserver* >::iterator it = m_observers.begin();
		for(; it != m_observers.end() ; ++it)
		{
			(*it)->onConnectionLost();
		}		

		// Raise a "unique" alarm
		TA_Base_Core::DescriptionParameters descriptionParameters;
		
		TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().submitAlarmWithAsset(TA_Base_Core::RadioAlarms::RadioCommunicationsFailureAlarm,
			m_entityKey,
			m_entityTypeKey,
			descriptionParameters,
			m_objectName, 
			m_entityLocation, 
			m_entitySubsystem,
			m_assetName,
			TA_Base_Core::AlarmConstants::defaultTime );
	}
	else
    {
		if ( (m_currentConnection == m_primaryConnection && isPrimary) || 
			 (m_currentConnection == m_secondaryConnection && !isPrimary) )
		{
			switchConnection(!isPrimary);
			notifyConnectionSwitch();
		}
        else
		{
			LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "The standby connection lost.");
		}
    }

	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );	
	FUNCTION_EXIT;
}

void RadioConnectionManager::onConnectionResumed(bool isPrimary)
{
	FUNCTION_ENTRY("onConnectionResumed");
	TA_Base_Core::ThreadGuard connectionSwitchGuard(m_connectionSwitchGuard);

	if ( numConnected() > 0 && !m_isConnected )
    {
		m_isConnected = true;
		switchConnection(isPrimary);

		TA_Base_Core::ThreadGuard guard(m_observerGuard);
		std::vector< IRadioConnectionStatusObserver* >::iterator it = m_observers.begin();
		for(; it != m_observers.end() ; ++it)
		{
			(*it)->onConnectionEstablish();
		}

		// Close any alarm
		TA_Base_Core::AlarmHelperManager::getInstance().getAlarmHelper().closeAlarmAtLocation(TA_Base_Core::RadioAlarms::RadioCommunicationsFailureAlarm,m_entityKey,m_entityLocation);
	}
	
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );
	FUNCTION_EXIT;
}

void RadioConnectionManager::notifyConnectionSwitch()
{
	TA_Base_Core::ThreadGuard guard(m_observerGuard);
	std::vector< IRadioConnectionStatusObserver* >::iterator it = m_observers.begin();
	for(; it != m_observers.end() ; ++it)
	{
		(*it)->onSwitchConnection();
    }
}

void RadioConnectionManager::setToControlMode(void)
{
	FUNCTION_ENTRY("setToControlMode");
	LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"Setting RadioConnectionManager to control mode.");
	m_active = true;

	if (m_controlConnectionStatus == ConnectToPrimary)
	{
		m_currentConnection = m_primaryConnection;
	}
	else if (m_controlConnectionStatus == ConnectToSecondary)
	{
		m_currentConnection = m_secondaryConnection;
	}
	else if (m_controlConnectionStatus == NoAppliable && numConnected() > 0)
	{
		if( m_primaryConnection->isConnected() ) 
		{
			switchConnection(true);
		}
		else if ( m_secondaryConnection->isConnected() )
		{
			switchConnection(false);
		}
		else
		{
			m_currentConnection = NULL;
		}
	}

	// Start the sockets processing events
    // The ONLY connection we want to NOT ignore incoming data is the current
    // one, and only if it is non-null
	if (m_primaryConnection != NULL)
    {
        // ie. if primary != current, then ignore data
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"Start the sockets of primaryConnection processing events: setIgnoreIncomingData %d", m_primaryConnection != m_currentConnection);
		m_primaryConnection->setIgnoreIncomingData( m_primaryConnection != m_currentConnection );
    }

	if (m_secondaryConnection != NULL)
    {
        // ie. if secondary != current, then ignore data
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"Start the sockets of secondaryConnection processing events: setIgnoreIncomingData %d", m_secondaryConnection != m_currentConnection);
		m_secondaryConnection->setIgnoreIncomingData( m_secondaryConnection != m_currentConnection );
    }

	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );

	FUNCTION_EXIT;
}

void RadioConnectionManager::setToMonitorMode(void)
{
	FUNCTION_ENTRY("setToMonitorMode");
	LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"Setting RadioConnectionManager to monitor mode.");
	m_active = false;

	m_controlConnectionStatus = NoAppliable;

	// Stop the sockets from processing events
	if (m_primaryConnection != NULL)
    {
		m_primaryConnection->setIgnoreIncomingData(true);
    }

	if (m_secondaryConnection != NULL)
    {
		m_secondaryConnection->setIgnoreIncomingData(true);
    }
	FUNCTION_EXIT;
}

void RadioConnectionManager::registForConnectionStatus( IRadioConnectionStatusObserver* observer)
{
	FUNCTION_ENTRY("registForConnectionStatus");

	TA_Base_Core::ThreadGuard guard(m_observerGuard);

	m_observers.push_back(observer);

	FUNCTION_EXIT;
}

void RadioConnectionManager::unregistForConnectionStatus( IRadioConnectionStatusObserver* observer)
{
	FUNCTION_ENTRY("unregistForConnectionStatus");

	TA_Base_Core::ThreadGuard guard(m_observerGuard);
	std::vector< IRadioConnectionStatusObserver* >::iterator it = m_observers.begin();
	for(; it != m_observers.end() ; ++it)
	{
		if (*it == observer)
		{
			m_observers.erase(it);
			break;
		}
	}

	FUNCTION_EXIT;
}

RadioConnectionManager::~RadioConnectionManager()
{
	FUNCTION_ENTRY("Destructor");

    // ThreadGuard scope restriction
    {
        TA_Base_Core::ThreadGuard lock(m_serverGuard);
        m_currentConnection = 0;
    }
	delete m_primaryConnection;
	delete m_secondaryConnection;

	FUNCTION_EXIT;
}

/**
* Sends the content of the radio method to the Radio server via TCP/IP
* @param    Method
*/
void RadioConnectionManager::SendMethod(const ITcpMethod& method)
{
	FUNCTION_ENTRY("SendMethod");

    if (getCurrentConnection() == 0)
    {
        TA_THROW(RadioConnectionException());
    }

    // ThreadGuard scope restriction
    {
        TA_Base_Core::ThreadGuard lock(m_serverGuard);
        // and just in case its changed back to zero in the meantime...
        if (m_currentConnection != 0)
        {
            // Send it to the current server
            m_currentConnection->Send(method);
        }
    }

	FUNCTION_EXIT;
}


/**
* Change connection from primary to secondary and vice-versa
*/
void RadioConnectionManager::switchConnection(bool toPrimary)
{
    FUNCTION_ENTRY("switchConnection");

	LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"[Link Switch] about to switch connection to %s connection",toPrimary? "Primary":"Secondary");

    TA_Base_Core::ThreadGuard lock(m_serverGuard);
	
    m_currentConnection = (toPrimary) ? m_primaryConnection : m_secondaryConnection;

	m_controlConnectionStatus = (toPrimary) ? ConnectToPrimary : ConnectToSecondary;

	if ((m_primaryConnection != NULL) && (m_active))
    {
        // set to ignore incoming data if not the current connection
		m_primaryConnection->setIgnoreIncomingData(m_primaryConnection != m_currentConnection);
    }

	if ((m_secondaryConnection != NULL) && (m_active))
    {
        // set to ignore incoming data if not the current connection
        m_secondaryConnection->setIgnoreIncomingData(m_secondaryConnection != m_currentConnection);
    }

	if(m_active)
	{
		RadioConnectionSwitch message;
		message.controlConnectionStatus = m_controlConnectionStatus;
		message.TCPServerIndex = m_tcpServer.getServerIndex();
		RadioStateUpdateBroadcaster::getInstance()->sendRadioConnectionSwitch(message);

		m_currentConnection->setCheckConnection();
	}
	
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );

	FUNCTION_EXIT;
}

int RadioConnectionManager::numConnected()
{
    FUNCTION_ENTRY("numConnected");
    int numConnected = 0;
    if ((m_primaryConnection != 0) && (m_primaryConnection->isConnected()))
    {
        numConnected++;
    }

    if ((m_secondaryConnection != 0) && (m_secondaryConnection->isConnected()))
    {
        numConnected++;
    }

    LOG_GENERIC(SourceInfo, DebugUtil::DebugDebug, "Number of active connections=%d", numConnected);

    FUNCTION_EXIT;
    return numConnected;
}

RadioTCPConnection * RadioConnectionManager::getCurrentConnection()
{
    TA_Base_Core::ThreadGuard lock(m_serverGuard);
    return m_currentConnection;
}


void RadioConnectionManager::releaseSendMethod()
{
    FUNCTION_ENTRY("releaseSendMethod");
    m_waitForConnection = false;
    FUNCTION_EXIT;
}

void RadioConnectionManager::getControlConnectionStatus(EControlConnectionStatus& controlConnectionStatus)
{
	controlConnectionStatus = m_controlConnectionStatus;
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "[Connection Control] Current value: %d", m_controlConnectionStatus );
}

void RadioConnectionManager::onCloseSocket()
{
	m_primaryConnection->connectionLost();
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "Primary socket closed" );

	m_secondaryConnection->connectionLost();
	LOG_GENERIC(SourceInfo, DebugUtil::DebugInfo, "Secondary sockets closed" );
}