/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioSessionInitialisationThread.h $
  * @author:  Ripple
  * @version: $Revision: #7 $
  *
  * Last modification: $DateTime: 2011/04/06 11:11:19 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioSessionInitialisationThread.h
//  Implementation of the Class RadioSessionInitialisationThread
//  Generated by Enterprise Architect
//  Created on:      06-Nov-2003 15:17:11
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////


#if !defined(RadioSessionInitialisationThread_56DF3D82_C75E_4cc0_B9AD_F35826113E0A__INCLUDED_)
#define RadioSessionInitialisationThread_56DF3D82_C75E_4cc0_B9AD_F35826113E0A__INCLUDED_

#include "app/radio/RadioTetraAgent/src/RadioSession.h"

#include "core/threads/src/Thread.h"
#include "core/timers/src/TimedWaitSemaphore.h"
#include "core/synchronisation/src/ReEntrantThreadLockable.h"
#include "core/synchronisation/src/NonReEntrantThreadLockable.h"
#include <queue>

/**
* This class defines a background thread that will be used to
* initialise the associated radio session.  A background thread
* is used so that the agent starts up quickly and any problems with an individual
* session do not affect the other objects.
* @version 1.0
* @generator Enterprise Architect
* @created 06-Nov-2003 15:17:11
*/

namespace TA_IRS_App
{
	class RadioSession;

	class RadioSessionInitialisationThread : public TA_Base_Core::Thread
	{
		public:
			RadioSessionInitialisationThread(RadioSession& radioSession);
			virtual ~RadioSessionInitialisationThread();
            /**
             * Wakes the thread if its sleeping and makes it login
             */

			enum requestedOperation
			{
				InitialiseSession,
				LoginSession,
				LogoutSession,
				DetachSession
			};
			
			//If want to detach session, the option should be true.
			//Else, just ignore it for normal login.
            void processSessionInit(requestedOperation destinationState);
			
			void run();
			void terminate();

		private:

            /**
             * Checks if this thread should actively be attempting to log in
             */
            bool shouldAttemptProcess();

			RadioSession& m_radioSession;

            volatile bool m_terminateThread;

			volatile bool m_hasTriedLogin;

            long m_initialiseRetryDelay;

            TA_Base_Core::TimedWaitSemaphore m_semaphore;

			volatile requestedOperation m_destinationState;

			TA_Base_Core::ReEntrantThreadLockable m_requestStateLock;

            std::queue< requestedOperation > m_destinationStateQueue; //limin++ CL-21770

            TA_Base_Core::NonReEntrantThreadLockable m_destinationStateQueueLock; //limin++ CL-21770
	};
};  // namespace

#endif // !defined(RadioSessionInitialisationThread_56DF3D82_C75E_4cc0_B9AD_F35826113E0A__INCLUDED_)
