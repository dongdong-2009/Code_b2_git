/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/RadioAuthorisationManager.cpp $
  * @author:  Andy Parker
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2008/11/28 16:26:01 $
  * Last modified by:  $Author: builder $
  *
  *
  * This class is used to manage radio authorisation requests.
  *
  * We need this to be a thread as we cannot use the incoming radio event (TCP thread)
  * to send synchronous messages to the radio as it will block stopping further TCP
  * receipt, i.e. it will never get its reply!
  */


///////////////////////////////////////////////////////////
//
//  RadioConnectionManager.cpp
//  Implementation of the Class RadioResourceManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:43:57
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#ifdef __WIN32__
#pragma warning(disable:4786)
#endif

#include <time.h>
#include "core/synchronisation/src/ThreadGuard.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"

#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"
#include "app/radio/RadioTetraAgent/src/RadioAuthorisationManager.h"
#include "app/radio/RadioTetraAgent/src/Radio.h"
#include "app/radio/RadioTetraAgent/src/IRadioCallback.h"
#include "app/radio/RadioTetraAgent/src/RadioStateUpdateBroadcaster.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionHelper.h"
#include "app/radio/RadioTetraAgent/src/RadioHelper.h"
#include "app/radio/RadioTetraAgent/src/RadioSessionHelper.h"
#include "app/radio/RadioTetraAgent/src/RadioTcpServer.h"


/**
* This class will be used to manage the audio references
* @author Andy Parker
* @version 1.0
* @generator Enterprise Architect
* @created 29-Oct-2003 17:43:57
*/

using namespace TA_IRS_App;

/*
* Constructor
*
* This function adds an audio reference to the list of managed audio connections.
* @param   radio   Need to access the sendCommand method by the run method.
*/
RadioAuthorisationManager::RadioAuthorisationManager(RadioTcpServer & tcpServer)
						  : m_tcpServer(tcpServer),
							m_workQueueSemaphore(0),
							m_terminate(false)

{
    FUNCTION_ENTRY("Constructor");
	// Start the background thread to process the requests
	start();
    FUNCTION_EXIT;
}


RadioAuthorisationManager::~RadioAuthorisationManager()
{
    FUNCTION_ENTRY("Destructor");
	// Stop the background thread
	terminate();    
	FUNCTION_EXIT;
}


/**
* This function adds an incoming CAD request to the stack.
* @param   SessionRef    indicates the owner session
* @param   cadRef        reference to the CAD call
*/
void RadioAuthorisationManager::addAuthorisationRequest(SessionReference sessionRef,CADReference cadRef)
{
    FUNCTION_ENTRY("addAuthorisationRequest");

	WorkRequestEntry   job;
	job.request    = ADD_AUTHORIATION_REQUEST;
	job.sessionRef = sessionRef;
	job.CADRef     = cadRef;

	// Add job to queue
	TA_Base_Core::ThreadGuard  guard(m_workQueueLock);
	m_workQueue.push_back(job);

	// Tell background thread to do it
	m_workQueueSemaphore.post();
	FUNCTION_EXIT;
}


/**
* This function will cancel the authorisation request.
* Proably due to call being hung up before authrisation
* @param   AuthorisationStack    Reference to list to contain details
*/
void RadioAuthorisationManager::cancelRequest(CADReference callID)
{
	FUNCTION_ENTRY("cancelRequest");

	bool sessionFound = false;
	TA_IRS_App::AuthorisationRequestType request;

	{  // nest for lock scope
		TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
		for (AuthorisationStack::iterator it=m_radioAuthorisationStack.begin();it!=m_radioAuthorisationStack.end();it++)
		{
			if (it->callID == callID)
			{
				request = *it;
				m_radioAuthorisationStack.erase(it);
				//Broadcast
				sendRemoveAuthorisationRequest(callID);
				sessionFound = true;
				break;
			}
		}
	}
	
	if (!sessionFound)
	{
		// Call not in list - throw exception back to client
		return;
	}

	// Tell clients of cancellation
	m_tcpServer.onAuthorisationChange(TA_IRS_App::CANCELLED_AUTHORISATION,request);

	FUNCTION_EXIT;

}


/**
* This function get the current list of authorisation requests.
* @param   AuthorisationStack    Reference to list to contain details
*/
void RadioAuthorisationManager::getAuthorisationList(AuthorisationStack& authorisationList, SessionReference SessionRef) //TD19479
{
	FUNCTION_ENTRY("getAuthorisationList");
	AuthorisationStack::iterator it = m_radioAuthorisationStack.begin();
	for (it ; it != m_radioAuthorisationStack.end(); it ++ )
	{
		if (it->sessionRef == SessionRef)
		{
			authorisationList.push_back(*it);
		}
	}
	FUNCTION_EXIT;
}

/**
* This function will authorise the specified call.
* This is performed directly as it will come from a client thread.
* @param   AuthorisationStack    Reference to list to contain details
*/
void RadioAuthorisationManager::authoriseCall(CADReference callID,bool accept,const char* sessionID)
{
	FUNCTION_ENTRY("authoriseCall");

	// Get session id from call ID
	bool sessionFound = false;
	TA_IRS_App::AuthorisationRequestType request;

	{  // nest for lock scope
		TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
		for (AuthorisationStack::iterator it=m_radioAuthorisationStack.begin();it!=m_radioAuthorisationStack.end();it++)
		{
			if (it->callID == callID)
			{
				request = *it;
				sessionFound = true;
				break;
			}
		}
	}
	
	if (!sessionFound)
	{
		// Call not in list - throw exception back to client
		return;
	}

	// Tell radio to authorise the session
	RadioMethodAuthoriseCall  authoriseMethod(request.sessionRef,callID,accept);
	RadioEvent * reply = m_tcpServer.sendMethod(authoriseMethod);
	
	delete reply;

	// Notify the client
	if (accept) 
		m_tcpServer.onAuthorisationChange(TA_IRS_App::ACCEPTED_AUTHORISATION,request);
	else
		m_tcpServer.onAuthorisationChange(TA_IRS_App::REJECTED_AUTHORISATION,request);

	// Update the call authorisation stack
	{  // nest for lock scope
		TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
		for (AuthorisationStack::iterator it=m_radioAuthorisationStack.begin();it!=m_radioAuthorisationStack.end();it++)
		{
			if (it->callID == callID)
			{
				m_radioAuthorisationStack.erase(it);
				//Broadcast
				sendRemoveAuthorisationRequest(callID);
				break;
			}
		}
	}

	FUNCTION_EXIT;
}

/*
 * Method performing the background work
 */
void RadioAuthorisationManager::run()
{
    FUNCTION_ENTRY("run");
	while (!m_terminate)
	{
		// Wait for some work to do
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"RadioAuthorisationManager - run(), hongzhi, wait for some work to do");
		m_workQueueSemaphore.wait();
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"RadioAuthorisationManager - run(), hongzhi, get new work to do");
		if (!m_terminate)
		{
			// Get job from queue - nest for scope of lock
			WorkRequestEntry  job;
			{
				TA_Base_Core::ThreadGuard  guard(m_workQueueLock);
				TA_ASSERT(m_workQueue.size()>0,"No work in queue");
				job = m_workQueue.at(0);
				m_workQueue.erase(m_workQueue.begin());
			}

			try
			{
				switch (job.request)
				{
					case ADD_AUTHORIATION_REQUEST:
						getCADDetails(job.sessionRef,job.CADRef);
						break;

					default:
						TA_ASSERT(false,"Invalid job request type");
				}
			}
			catch (...)
			{
				// Don't want anything to kill our thread - e.g. timeout talking to RCS
				LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn,"RadioAuthorisationManager - Exception received when processing job");
			}
		}
	}

	m_terminate = false;
    FUNCTION_EXIT;
}

/*
 * Stop backgroung processing
 */
void RadioAuthorisationManager::terminate()
{
    FUNCTION_ENTRY("terminate");
	m_terminate = true;

	// wake up queue
	m_workQueueSemaphore.post();
    FUNCTION_EXIT;
}


/*
 * Get the CAD details from the radio and update the authorisation stack
 * notifying any listening clients.
 */
void RadioAuthorisationManager::getCADDetails(SessionReference sessionRef,CADReference cadRef)
{
    FUNCTION_ENTRY("addAuthorisationRequest");

	TA_IRS_App::AuthorisationRequestType request;
	RadioSessionHelper  helper(sessionRef, m_tcpServer);
	// Get the details for the call from the radio system
	request.callID     = cadRef;
	request.sessionRef = sessionRef;

	// Get the caller ITSI
    /// ANDY TODO
    /// NOTE: we're storing the TSI in the callerName/calledName fields (should be applied to 
    ///      callerTSIcalledTSI, when those members implemented in structure)
	request.callerTSI      = queryResults(sessionRef,cadRef,RadioMethodQueryReference::K_CALLING);
	request.calledTSI      = queryResults(sessionRef,cadRef,RadioMethodQueryReference::K_CALLED);

    // CALLING Subscriber details
    QueryKeyValueMap subscriberDetails;
    subscriberDetails[(unsigned long)RadioMethodQueryReference::K_NAME] = "";
    subscriberDetails[(unsigned long)RadioMethodQueryReference::K_ORGANISATION] = "";
    int num_details = helper.getSubscriberDetails(request.callerTSI, subscriberDetails);
    if ( num_details == 2 )
    {
        request.callerName      = subscriberDetails[(unsigned long)RadioMethodQueryReference::K_NAME];
        request.callerLocation  = subscriberDetails[(unsigned long)RadioMethodQueryReference::K_ORGANISATION];

        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Call participant details, callerName:%s callerTSI:%s callerLocation:%s", 
			request.callerName.c_str(), request.callerTSI.c_str(), request.callerLocation.c_str());
    }
    else
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, "Could not retrieve Calling subscriber details");
    }

    // CALLED Subscriber details
    subscriberDetails[(unsigned long)RadioMethodQueryReference::K_NAME] = "";
    subscriberDetails[(unsigned long)RadioMethodQueryReference::K_ORGANISATION] = "";
    num_details = helper.getSubscriberDetails(request.calledTSI, subscriberDetails);
    if ( num_details == 2 )
    {
        request.calledName      = subscriberDetails[(unsigned long)RadioMethodQueryReference::K_NAME];
        request.calledLocation  = subscriberDetails[(unsigned long)RadioMethodQueryReference::K_ORGANISATION];

        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Call participant details, calledName:%s calledTSI:%s calledLocation:%s", 
			request.calledName.c_str(), request.calledTSI.c_str(), request.calledLocation.c_str());
    }
    else
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugWarn, "Could not retrieve Called subscriber details");
    }

	// AJP - TODO - use search subscriber, text2sr and query methods to get their names, location and type
	// Refactor these from RadioSession into common module. also use for call queries.
	request.sourceType = PORTABLE_RADIO;
	request.destinationType = PORTABLE_RADIO;
	
	request.time = time(NULL);

	// Add to the list
	TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
	m_radioAuthorisationStack.push_back(request);

	// Tell clients of the new arrival
	m_tcpServer.onAuthorisationChange(TA_IRS_App::NEW_AUTHORISATION,request);

	sendUpdateAuthorisationRequest(request);

	FUNCTION_EXIT;
}


/*
 * Query the details from a reference.
 */
std::string RadioAuthorisationManager::queryResults(unsigned long sessionRef,
													unsigned long resultRef, 
													RadioMethodQueryReference::EKeys key)
{
	FUNCTION_ENTRY("queryResults");

	// Need to perform a query reference on the operator's session reference.
	RadioMethodQueryReference queryReferenceMethod(sessionRef);
    queryReferenceMethod.setQueryType(key);
	queryReferenceMethod.setQueryReference(resultRef);
	RadioEvent * reply = m_tcpServer.sendMethod(queryReferenceMethod);


    // The reply should have the ITSI for the current session
    QueryReferenceEventReader queryReferencereader(*reply);
    std::string resultText = queryReferencereader.getDetails();

    // Delete the reply
    delete reply;
    reply = NULL;

	FUNCTION_EXIT;
	return resultText;
}

void RadioAuthorisationManager::applyFullState(const RadioAuthorisationManagerType& state)
{
	FUNCTION_ENTRY("applyFullState");
	
	AuthorisationRequestTypeList::const_iterator it;
	
    {
        TA_Base_Core::ThreadGuard guard(m_authorisationStackLock);
		
        // clear the stack before applying the new calls
        m_radioAuthorisationStack.clear();
        
        for (it = state.radioAuthorisationStack.begin(); it != state.radioAuthorisationStack.end(); it++)
        {
			m_radioAuthorisationStack.push_back(*it);
        }
		
	}

	FUNCTION_EXIT;
}
void RadioAuthorisationManager::clearFullState()
{
	FUNCTION_ENTRY("clearFullState");
	
	TA_Base_Core::ThreadGuard guard(m_authorisationStackLock);
	//Clear the callDetails stack
	m_radioAuthorisationStack.clear();

	FUNCTION_EXIT;
}

void RadioAuthorisationManager::getFullState(RadioAuthorisationManagerType& state)
{
	FUNCTION_ENTRY("getFullState");
	
	AuthorisationRequestTypeList::const_iterator it;
	
	{
		TA_Base_Core::ThreadGuard guard(m_authorisationStackLock);
		
		// get all the calls from the stack
		state.radioAuthorisationStack.clear();
		
		for (it = m_radioAuthorisationStack.begin(); it != m_radioAuthorisationStack.end(); it++)
		{
			state.radioAuthorisationStack.push_back(*it);
		}
			
	}

	FUNCTION_EXIT;
}


void RadioAuthorisationManager::sendRemoveAuthorisationRequest(CallID callID)
{
	FUNCTION_ENTRY("sendRemoveAuthorisationRequest");

	RadioRemoveAuthorisationRequest message;
	message.callID = callID;
	message.serverIndex = m_tcpServer.getServerIndex();
	//BroadCast
	RadioStateUpdateBroadcaster::getInstance()->sendRadioRemoveAuthorisationRequest(message);

	FUNCTION_EXIT;
}


void RadioAuthorisationManager::sendUpdateAuthorisationRequest(const AuthorisationRequestType& request)
{
	FUNCTION_ENTRY("sendUpdateAuthorisationRequest");

	RadioUpdateAuthorisationRequest message;
	//message to be sent
	message.autorisationRequest = request;	
	message.serverIndex = m_tcpServer.getServerIndex();
	//Broadcast the change in the Autorisation request
	RadioStateUpdateBroadcaster::getInstance()->sendRadioUpdateAuthorisationRequest(message);

	FUNCTION_EXIT;
}


void RadioAuthorisationManager::updateAuthorisationRequest(const AuthorisationRequestType& request)
{
	FUNCTION_ENTRY("updateAuthorisationRequest");
	
	AuthorisationRequestTypeList::iterator it;
	AuthorisationRequestTypeList::iterator foundIterator;
	bool callIDFound = false;
	{
		TA_Base_Core::ThreadGuard guard(m_authorisationStackLock);
		
		// Check if callID exists first
        for (it = m_radioAuthorisationStack.begin(); it != m_radioAuthorisationStack.end() && !callIDFound; it++)
        {
            if (it->callID == request.callID)
            {
                foundIterator = it;
                callIDFound = true;
            }
        }
        
        if (callIDFound)
        {
            // update the AuthorisationRequest details
            *foundIterator = request;
        }
        else
        {
            // add the AuthorisationRequest details
            m_radioAuthorisationStack.push_back(request);
        }
    }
	
	
	FUNCTION_EXIT;
}
void RadioAuthorisationManager::removeAuthorisationRequest(CADReference callID)
{
	
	FUNCTION_ENTRY("removeAuthorisationRequest");
		
	TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
	for (AuthorisationStack::iterator it=m_radioAuthorisationStack.begin();it!=m_radioAuthorisationStack.end();it++)
	{
		if (it->callID == callID)
		{
			m_radioAuthorisationStack.erase(it);
			break;
		}
	}

	FUNCTION_EXIT;
}

void RadioAuthorisationManager::sessionLoggedOut(SessionReference sessionRef)
{
	
	FUNCTION_ENTRY("sessionLoggedOut");
		
    { // ThreadGuard scope

        TA_Base_Core::ThreadGuard  guard(m_authorisationStackLock);
        for (AuthorisationStack::iterator it=m_radioAuthorisationStack.begin();it!=m_radioAuthorisationStack.end();it++)
        {
            if (it->sessionRef == sessionRef)
            {
                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
                            "Erasing authorisation request %lu for session %d", (*it).callID, sessionRef);
                m_radioAuthorisationStack.erase(it);
                break;
            }
        }
	} // ThreadGuard scope

	FUNCTION_EXIT;
}

