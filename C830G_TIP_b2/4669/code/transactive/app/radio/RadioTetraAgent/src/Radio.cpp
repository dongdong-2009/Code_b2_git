/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/radio/RadioTetraAgent/src/Radio.cpp $
  * @author:  Ripple
  * @version: $Revision: #5 $
  *
  * Last modification: $DateTime: 2009/09/23 13:09:47 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  Radio.cpp
//  Implementation of the Class Radio
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 16:10:10
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/ILogType.h"
#include "core/utilities/src/DebugUtil.h" 
#include "core/utilities/src/RunParams.h"
#include "core/exceptions/src/DataException.h"
#include "core/exceptions/src/DatabaseException.h"
#include "core/message/types/RadioAlarms_MessageTypes.h"

#include "Radio.h"
#include "RadioHelper.h"
#include "RadioSession.h"
#include "RadioTcpServer.h"
#include "IRadioCallback.h"
#include "RadioTaskFactory.h"
#include "RadioSessionHelper.h"
#include "RadioSessionException.h"
#include "RadioTransactionManager.h"
#include "IRadioDirectoryCallback.h"
#include "RadioCorbaTypeConverter.h"
#include "RadioBackgroundProcessor.h"
#include "RadioAgentConstants.h"
#include "RadioConnectionManager.h"

#include "core/data_access_interface/radio/src/RASpeedDialSet.h"
#include "core/exceptions/src/DataException.h"
using namespace TA_Base_Core;
using namespace TA_IRS_App;


Radio::Radio(RadioServerLinkStatusUpdateThread* linkStatusThread,IRadioCallback& callback/*, TA_Base_Bus::ItaScada& scada*/) 
      : m_ISCSRadioSession(0),
        m_callback(callback),
        m_directoryCallback(0),
        m_backgroundProcessor(0),
        m_active(false),
        m_inFallback(false),
        m_fallbackReplacementString(""),
        m_serverLinkStatusThread(linkStatusThread),
		m_defaultVolume(RadioAgentConstants::DEFAULT_AUDIO_VOLUME)
		
{
	FUNCTION_ENTRY("Constructor");

    m_backgroundProcessor = new RadioBackgroundProcessor(this);

    m_radioCircuitModeManager = new RadioCircuitModeManager(*this);
    m_radioCircuitModeManager->start();

	FUNCTION_EXIT;
}


Radio::~Radio()
{
	FUNCTION_ENTRY("Destructor");
    m_radioCircuitModeManager->terminateAndWait();
    delete m_radioCircuitModeManager;
    delete m_backgroundProcessor;

	FUNCTION_EXIT;
}

void Radio::setEntity(TA_Base_Core::IEntityData& entityData)
{
	RadioTcpServerArray::const_iterator it;
	for (it = m_radioTcpServers.begin();
		 it != m_radioTcpServers.end();
		 it ++)
	{
		(*it)->setEntity(entityData);
	}
}

IRadioCallback& Radio::getRadioCallback()
{
    return this->m_callback;
}

void Radio::start()
{
	FUNCTION_ENTRY("start");
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->start();
    }
    FUNCTION_EXIT;
}


void Radio::setParameters( const std::string & primaryAddresses,
                           const std::string & secondaryAddresses,
						   unsigned long defaultVolume,
                           unsigned char serialiseTransactionLevel,
                           unsigned long xonXoffTimeout,
                           unsigned long circuitDataFramesPerPacket )
{
	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
            "Using radio hosts primary <%s>, secondary <%s>",
            primaryAddresses.c_str(), secondaryAddresses.c_str() );

    std::vector<std::string> primaryHosts;
    std::vector<std::string> secondaryHosts;

	m_defaultVolume = defaultVolume;

    RadioHelper::tokenise(primaryAddresses.c_str(), primaryHosts, ",");
    RadioHelper::tokenise(secondaryAddresses.c_str(), secondaryHosts, ",");

    // even up the secondary addresses, by adding nullstrings until there are
    // as many secondary as primary.  If there are more secondary than primary
    // they will be ignored subsequently...
    while ( secondaryHosts.size() < primaryHosts.size() )
    {
        secondaryHosts.push_back("");
    }

    //
    // delete/remove/deallocate all the current tcp servers
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        delete (*iter);
    }

    // use an integer index rather than iterator, as we need to use both 
    // primary and secondary vectors, plus the tcpserver array simultaneously
    // Note that we only set the servers until the end of the primaryAddresses
    // list, so extra secondary servers are ignored.
    // TODO: fix so that primaryaddresses.size() is correct
    for( size_t i=0 ; i< secondaryHosts.size() ; i++ )
    {
        RadioTcpServer * newRadioTcpServer = new RadioTcpServer( m_callback,
                                                                 i,
                                                                 *this,
                                                                 //m_scada,
                                                                 primaryHosts[i],
                                                                 secondaryHosts[i],
                                                                 serialiseTransactionLevel);                                                                
        m_radioTcpServers.push_back(newRadioTcpServer);
    }

    m_radioCircuitModeManager->setParameters( xonXoffTimeout, circuitDataFramesPerPacket );
}

void Radio::updateControlConnectionState(EControlConnectionStatus controlConnectionStatus, unsigned long TcpServerIndex)
{
	m_radioTcpServers[TcpServerIndex]->updateControlConnectionState( controlConnectionStatus );
}

/**
* Used by the ISCS Radio session to advise Radio of the special session (used for trainborne comms)
* @param    session
*/
void Radio::setISCSRadioSession(RadioSession& session)
{
	FUNCTION_ENTRY("setISCSRadioSession");
	TA_ASSERT(m_ISCSRadioSession==NULL,"ISCS radio session already defined.");
	m_ISCSRadioSession = &session;
	FUNCTION_EXIT;
}


void Radio::setToControlMode(void)
{
	FUNCTION_ENTRY("setToControlMode");
	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Setting radio to control mode");
	m_active = true;
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->setToControlMode();
    }
	FUNCTION_EXIT;
}

void Radio::setToMonitorMode(void)
{
	FUNCTION_ENTRY("setToMonitorMode");
	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
		 "Setting radio to monitor mode");
	m_active = false;
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->setToMonitorMode();
    }
	FUNCTION_EXIT
}

bool Radio::getIsActive(void)
{
	return m_active;
}

void Radio::onTerminate(bool peerAvailable)
{
    FUNCTION_ENTRY("onTerminate");
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->onTerminate(peerAvailable);
    }
    FUNCTION_EXIT;
}


/**
* This function returns the session reference for this session.  It is used to identify calls that belong to this session
*/
SessionReference Radio::getISCSRadioSessionRef()
{
	FUNCTION_ENTRY("getISCSRadioSessionRef");
	FUNCTION_EXIT;
	return m_ISCSRadioSession->getValidSessionRef();
}

RadioSession* Radio::getISCSRadioSession()
{
	FUNCTION_ENTRY("getISCSRadioSession");
	FUNCTION_EXIT;
	return m_ISCSRadioSession;
}


/**
* This method sends a method request to the radio system and waits for a reply (event).  
* It will be used by the RadioSession to perform its operations.
* @param    Method
*/
TA_IRS_App::RadioEvent* Radio::sendMethod(RadioMethod& method)
{
	FUNCTION_ENTRY("sendMethod");
	
	FUNCTION_EXIT;
	return m_ISCSRadioSession->getTcpServer().sendMethod(method);
	
}	



std::vector<RadioEvent*> Radio::sendMethodMultipleResponse(RadioMethod& method)
{
	FUNCTION_ENTRY("sendMethodMultipleResponse");
	FUNCTION_EXIT;
	return m_ISCSRadioSession->getTcpServer().sendMethodMultipleResponse(method);
}


void Radio::getCallList(ConsoleID consoleId, CallList& callList) 
{
	FUNCTION_ENTRY("getCallList");

	TA_Base_Core::ThreadGuard  guard(m_callStackLock);	

	// Reset the list
	callList.clear();

    ConsoleToSessionServerMap::iterator fndC2ss = m_consoleSessionServers.find(consoleId);
	if(fndC2ss == m_consoleSessionServers.end())
	{
		FUNCTION_EXIT;
		return;
	}

	ServerIndex srvIdx = fndC2ss->second.second;
	for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
		  iter != m_radioTcpServers.end() ;
		  iter++)
	{
		if((*iter)->getServerIndex() == srvIdx)
		{
			(*iter)->getCallList(callList);
			FUNCTION_EXIT;
			return;
		}

	}

	FUNCTION_EXIT;
}


// TD12462 In fallback, cannot send SDS to train if audio already established
void Radio::getTsiCallList(const std::string & tsi, bool audioOnly, CallList & callList)
{
	FUNCTION_ENTRY("getTsiCallList");

	TA_Base_Core::ThreadGuard  guard(m_callStackLock);	

	// Reset the list
	callList.clear();

    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->getTsiCallList(tsi, audioOnly, callList);
    }

	FUNCTION_EXIT;
}


bool Radio::getCallDetails(CallID callId, ConsoleID consoleId, CallDetailsType& details)
{
	FUNCTION_ENTRY("getCallDetails");
	
    // TODO: fix this MEGA-HACKA-KLUDGEROONI by adding console and session
    // stuff into the idl
    ConsoleToSessionServerMap::iterator fndC2ss = m_consoleSessionServers.find(consoleId);
	if(fndC2ss == m_consoleSessionServers.end())
	{
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Console ID=%lu NOT found", consoleId);
        std::ostringstream oss;
        oss << "Consoles available:";
        for ( ConsoleToSessionServerMap::iterator iter = m_consoleSessionServers.begin() ; iter != m_consoleSessionServers.end() ; iter++ )
        {
            unsigned long iterConsoleId = (*iter).first;
            oss << " " << iterConsoleId;
        }
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, oss.str().c_str() );

		FUNCTION_EXIT;
		return false;
	}

	ServerIndex srvIdx = fndC2ss->second.second;
    try
    {
        RadioTcpServer * tcpServer = m_radioTcpServers[srvIdx];
        bool success = tcpServer->getCallDetails(callId, details);
        FUNCTION_EXIT;
        return success;
    }
    catch (...)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, "Invalid RadioTcpServer requested: %d", srvIdx );
    }


	FUNCTION_EXIT;
	return false;
}

// RvH 20050115 Radio Pre-iFAT
bool Radio::getCallDetailsPartial(CallID callId, ConsoleID consoleId, CallDetailsType& details)
{
	FUNCTION_ENTRY("getCallDetailsPartial");
	
    ConsoleToSessionServerMap::iterator fndC2ss = m_consoleSessionServers.find(consoleId);
	if(fndC2ss == m_consoleSessionServers.end())
	{
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Console ID=%lu NOT found", consoleId);
        std::ostringstream oss;
        oss << "Consoles available:";
        for ( ConsoleToSessionServerMap::iterator iter = m_consoleSessionServers.begin() ; iter != m_consoleSessionServers.end() ; iter++ )
        {
            unsigned long iterConsoleId = (*iter).first;
            oss << " " << iterConsoleId;
        }
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, oss.str().c_str() );

		FUNCTION_EXIT;
		return false;
	}

	ServerIndex srvIdx = fndC2ss->second.second;
    try
    {
        RadioTcpServer * tcpServer = m_radioTcpServers[srvIdx];
        bool success = tcpServer->getCallDetailsPartial(callId, details);
        FUNCTION_EXIT;
        return success;
    }
    catch (...)
    {
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, "Invalid RadioTcpServer requested: %d", srvIdx );
    }

	FUNCTION_EXIT;
	return false;
}


void Radio::addCallDriverRequest(unsigned char trainID,const char* trainTSI)
{
	FUNCTION_ENTRY("addCallDriverRequest");
	TA_IRS_App::CallDetailsType   callDetails;

	callDetails.callID         = trainID;
	callDetails.sessionRef     = m_ISCSRadioSession->getValidSessionRef();
	callDetails.callStatus     = TA_IRS_App::Ringing;
	callDetails.callCategory   = TA_IRS_App::CallDriver;
	callDetails.callType       = TA_IRS_App::SingleCall;
	callDetails.callSource     = TA_IRS_App::IncomingCall;
    callDetails.time           = 0;
	callDetails.callTime       = "";
	callDetails.callerName     = trainTSI;
	callDetails.callerTSI      = trainTSI;
	callDetails.callerLocation = "";
	callDetails.calledName     = "";
	callDetails.calledTSI      = "";
	callDetails.calledLocation = "";
    callDetails.isEmergency    = false;
	//TD 10234
    callDetails.isInvisibleToGUIApps = false;

	m_ISCSRadioSession->getTcpServer().addCallToCallStack(callDetails);
}

void Radio::removeCallDriverRequest(unsigned char trainID)
{

	FUNCTION_ENTRY("removeCallDriverRequest");
    // WAS:
	// removeCallFromCallStack(trainID,true);
    for (   RadioTcpServerArray::iterator iter=m_radioTcpServers.begin() ;
            iter != m_radioTcpServers.end() ;
            iter++
        )
    {
        if ((*iter)->removeCallFromCallStack(trainID, true))
        {
            return;
        }
    }

	FUNCTION_EXIT;			
}




/**
* sends an SDS message to the train identified in the message.  
* It will then create a message for the radio to send an SDS with the train message embedded. 
* The ISCS radio session will be used. This will then be transmitted through the TCP/IP link
*/
void Radio::sendTrainCommand(const char* trainITSI,std::vector<unsigned char> message)
{
	FUNCTION_ENTRY("sendTrainCommand");

	TA_ASSERT(m_ISCSRadioSession!=NULL,"No ISCS radio session defined to send train command");
	m_ISCSRadioSession->sendTextDataMessage(trainITSI,message);

	FUNCTION_EXIT;
}


NewReferenceEventReader::RadioReference Radio::setupDataCall(const std::string& destinationTsi)
{
    FUNCTION_ENTRY("setupDataCall");

	TA_ASSERT(m_ISCSRadioSession!=NULL,"No ISCS radio session defined to send train circuitData");
	return m_ISCSRadioSession->setupDataCall(destinationTsi);

	FUNCTION_EXIT
}


void Radio::sendCircuitDataFrame( NewReferenceEventReader::RadioReference callReference,
                                  const RadioCircuitTransfer::Data& frame )
{
    FUNCTION_ENTRY("sendCircuitDataFrame");

	TA_ASSERT(m_ISCSRadioSession!=NULL,"No ISCS radio session defined to send train circuitData");
	m_ISCSRadioSession->sendCircuitDataFrame( callReference, frame );

	FUNCTION_EXIT
}


void Radio::endDataCall( NewReferenceEventReader::RadioReference callReference )
{
    FUNCTION_ENTRY("endDataCall");

	TA_ASSERT(m_ISCSRadioSession!=NULL,"No ISCS radio session defined to send train circuitData");
	m_ISCSRadioSession->endDataCall( callReference );

	FUNCTION_EXIT
}


void Radio::clearDataCallReference( NewReferenceEventReader::RadioReference callReference )
{
    FUNCTION_ENTRY("clearDataCallReference");

	TA_ASSERT(m_ISCSRadioSession!=NULL,"No ISCS radio session defined to send train circuitData");
	m_ISCSRadioSession->clearDataCallReference( callReference );

	FUNCTION_EXIT
}






/**
* Sent when the hardware is acknowledging a circuit mode data transfer packet.
* This will be recorded in the RadioCircuitModeManager and another packet sent
* for that call.
*/
void Radio::onIncomingCircuitData(const TA_IRS_App::IncomingCircuitDataEventReader& eventReader)
{
	FUNCTION_ENTRY("onIncomingCircuitData");

    std::vector<unsigned char> data;
    eventReader.getData( data );

    RadioCircuitTransfer::EXStatus status = RadioCircuitTransfer::XON;

    for( unsigned int i = data.size();
         i > 0;
         i-- )
    {
        if( data[i-1] == 0x11 )  // XOFF is ^Q
        {
            status = RadioCircuitTransfer::XON;
            break;
        }
        else if( data[i-1] == 0x13 ) // XON is ^S
        {
            status = RadioCircuitTransfer::XOFF;
            break;
        }
    }  

    m_radioCircuitModeManager->processIncomingCircuitModeData(
        eventReader.getCallReference(),
        status );

	FUNCTION_EXIT;
}


void Radio::onCircuitDataCapacity(const TA_IRS_App::CircuitDataCapacityEventReader& eventReader)
{
	FUNCTION_ENTRY("onCircuitDataCapacity");

    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Reference: %d", eventReader.getCallReference() );

    m_radioCircuitModeManager->processIncomingCircuitModeDataCapacity(
        eventReader.getCallReference(), eventReader.getFreeBytes() );

	FUNCTION_EXIT;
}


RadioCircuitModeManager* Radio::getRadioCircuitModeManager()
{
	return m_radioCircuitModeManager;
}


/**
* This method will handle changes to radio fall back mode.  Some functions will
* become unavailable therefore applications must be notified.  An alarm should
* be raised/closed to alert the operator.
*/
void Radio::onRadioFallback(bool isFallback, EFallbackReason fallbackReason)
{
	FUNCTION_ENTRY("onRadioFallback");

    LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
         "Received Notification of RadioFallback [%s] (Currently %s)", (isFallback)?"Fallback":"Normal", (m_inFallback)?"Fallback":"Normal");

    // only trigger activities if we haven't already
    if ( m_inFallback != isFallback )
    {
        m_inFallback = isFallback;

		setDpServerFallback(m_inFallback);

		if (m_inFallback) // TD9023
		{
			TA_Base_Core::DescriptionParameters descriptionParameters;
			m_callback.submitAlarm(TA_Base_Core::RadioAlarms::RadioFallbackModeAlarm,descriptionParameters);
		}
		else // add closeAlarm() in IRadioCallback
		{
			m_callback.closeAlarm(TA_Base_Core::RadioAlarms::RadioFallbackModeAlarm);	
		}

        // If we came here via a systemError, we're supposed to detach and
        // re-login with fallback state
        if (fallbackReason==fbUnsolicited)
        {
            // reset the connection entering or leaving fallback

            LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
                 "Unsolicited Notification of RadioFallback. Resetting connection");
            //
            // TODO: find out if we should terminate on-going calls that
            // haven't been terminated automatically by the RCS
            resetConnection();
        }
    }
    
    if (fallbackReason==fbSessionLogin)
    {
        // this tells the TrainAgent
        m_callback.onRadioFallback(isFallback);

        // Can't think of anything else that needs doing here that hasn't
        // already been done in the RadioSession class.
        // Do we need to alert session-aware entities
        // (CallBanner, RadioManager, RadioMonitor) ?
        LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
            "SessionLogin Notification of RadioFallback (no additional action taken)");
    }

	FUNCTION_EXIT;
}


void Radio::addBackgroundTask(RadioTaskPtr task)
{
    m_backgroundProcessor->addTask(task);
}

void Radio::setDirectoryCallback(IRadioDirectoryCallback * directoryCallback)
{
    if (m_directoryCallback != 0)
    {
        LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugInfo, 
             "Overwriting previously registered Directory Callback");
    }

    m_directoryCallback = directoryCallback;
}


void Radio::applyFullState(const RadioType& state)
{
	{
		TA_Base_Core::ThreadGuard guard(m_callStackLock);

		RadioTcpServerArray::const_iterator it;

		for ( it = m_radioTcpServers.begin(); it != m_radioTcpServers.end(); it ++ )
		{
			RadioType::const_iterator itr = state.find( (*it)->getServerIndex() );

			if ( itr != state.end() )
			{
				LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Radio::applyFullState on TcpServer %d", (*it)->getServerIndex() );
				(*it)->applyFullState( itr->second );
			}
		}
	}
}

void Radio::clearFullState()
{
    {
        TA_Base_Core::ThreadGuard guard(m_callStackLock);
        
		RadioTcpServerArray::const_iterator it;

		for (   it = m_radioTcpServers.begin();
				it != m_radioTcpServers.end();
				it++)
		{
			(*it)->clearFullState();
		}
    }
}

void Radio::getFullState(RadioType& state)
{
	FUNCTION_ENTRY("getFullState");

    {
        
        RadioTcpServerArray::const_iterator it;
        // get all the calls from the stack
        state.clear();

		for ( it = m_radioTcpServers.begin(); it != m_radioTcpServers.end(); it ++ )
		{
			TcpServerType serverType;
			(*it)->getFullState( serverType );
			state.insert( std::pair< ServerIndex, TcpServerType >( (*it)->getServerIndex(), serverType ) );
		}

    }

	//get Full state of the Subscriber Monitor Manager
#if defined MONITOR_STATEUPDATE_BROKEN_BY_TD17613
    // TODO: move to RadioTcpServer, use m_subscriberMonitor
    //m_radioMonitorManager->getFullState(state.radioMonitorManager);
#endif // #if defined MONITOR_STATEUPDATE_BROKEN_BY_TD17613
	//get Full state of the Authorisation Manager
	// TODO: broken by TD15273
    // m_radioAuthorisationManager->getFullState(state.radioAuthorisationManager);



	FUNCTION_EXIT;
}

void Radio::updateCallInRadioCallStack(const CallDetailsType& callDetails)
{
    // find the appropriate RadioTcpServer to delegate to
    ConsoleToSessionServerMap::iterator fndC2ss = m_consoleSessionServers.find(callDetails.consoleID);
	if(fndC2ss == m_consoleSessionServers.end())
	{
		return;
	}

	ServerIndex srvIdx = fndC2ss->second.second;
	for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
		  iter != m_radioTcpServers.end() ;
		  iter++)
	{
		if((*iter)->getServerIndex() == srvIdx)
		{
			(*iter)->updateCallInRadioCallStack(callDetails);
			return;
		}
	}

}

//
// state synchronisation 
// TODO: rename this to indicate its state-sync-ness
void Radio::removeCallFromRadioCallStack(CallID callID, unsigned long consoleID)
{
    // find the appropriate RadioTcpServer to delegate to
    ConsoleToSessionServerMap::iterator fndC2ss = m_consoleSessionServers.find(consoleID);
	if(fndC2ss == m_consoleSessionServers.end())
	{
		return;
	}

	ServerIndex srvIdx = fndC2ss->second.second;
	for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
		  iter != m_radioTcpServers.end() ;
		  iter++)
	{
		if((*iter)->getServerIndex() == srvIdx)
		{
			(*iter)->removeCallFromRadioCallStack(callID);
			return;
		}
	}
}

bool Radio::inFallback() const
{
    return m_inFallback;
}


void Radio::resetConnection()
{

    // delegate to individual tcpservers. Since this only happens at station
    // BaseStations, this is unlikely to affect more than one tcpserver, but
    // that's over-engineering for you.
    for ( RadioTcpServerArray::iterator iter = m_radioTcpServers.begin() ;
          iter != m_radioTcpServers.end() ;
          iter++)
    {
        (*iter)->resetConnection();
    }


}

std::string Radio::getFallbackReplacementString()
{
    // first time, get the string.
    if ( m_fallbackReplacementString.empty() )
    {
        // retrieve from runtime parameters if possible
        m_fallbackReplacementString = TA_Base_Core::RunParams::getInstance().get("FallbackReplacementString");

        // otherwise, a default is imperative
        if ( m_fallbackReplacementString.empty() )
        {
            m_fallbackReplacementString = "(F)";
        }
    }

    return m_fallbackReplacementString;
}


void Radio::updateRadioMonitoredCallProgression(unsigned long monitorReference)
{
#if defined MONITOR_STATEUPDATE
	addMonitor(monitorReference);
//	subscriberActivity();
#endif
}


void Radio::removeMonitoredSubscriberDetails(unsigned long monitoredReference, long	serverIndex)
{
//	m_subscriberMonitor->removeMonitor(monitoredReference);
	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		if(serverIndex == (*it)->getServerIndex() )
		{
			(*it)->removeMonitoredSubscriberDetails(monitoredReference);
			break;
		}
	}

}
			
void Radio::updateAudioEntryInSessionMap(SessionID sessionReference, 
								  AudioReference audioReference,
								  const AudioEntryType& audioEntry)
{	


	FUNCTION_ENTRY("updateAudioEntryInSessionMap");

	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Radio::updateAudioEntryInSessionMap on TcpServer %d", (*it)->getServerIndex() );
		(*it)->updateAudioEntryInSessionMap(sessionReference, 
  										    audioReference,
											audioEntry);
	}

	FUNCTION_EXIT;
}

void Radio::updateRadioResourceManagerVars(SessionID sessionReference, CallReference callReference,
										   int currentVolume, long serverIndex)
{	
	FUNCTION_ENTRY("updateRadioResourceManagerVars");

	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		if(serverIndex == (*it)->getServerIndex())
		{
			(*it)->updateRadioResourceManagerVars(sessionReference, callReference, currentVolume);
			break;
		}
	}

	FUNCTION_EXIT;
}

void Radio::updateAuthorisationRequest(const AuthorisationRequestType& authorisationRequest, long serverIndex)
{ 
	FUNCTION_ENTRY("updateAuthorisationRequest");

	//this->m_radioAuthorisationManager->updateAuthorisationRequest(authorisationRequest);

	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		if(serverIndex == (*it)->getServerIndex() )
		{
			(*it)->updateAuthorisationRequest(authorisationRequest);
			break;
		}
	}

	FUNCTION_EXIT;
}
	
	
void Radio::removeAuthorisationRequest(CallID callID, long serverIndex)
{
	FUNCTION_ENTRY("removeAuthorisationRequest");

	//this->m_radioAuthorisationManager->removeAuthorisationRequest(callID);

	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		if(serverIndex == (*it)->getServerIndex() )
		{
			(*it)->removeAuthorisationRequest(callID);
			break;
		}
	}


	FUNCTION_EXIT;

}


void Radio::addSessionServerConsole(SessionReference sessionRef, ServerIndex svrIdx, ConsoleID consoleID)
{
    TA_Base_Core::ThreadGuard sscMapGuard(m_sscMapLock);

    SessionServerIndex ssi(sessionRef,svrIdx);

    // check if the ssi is in the map yet

    // otherwise just add the blessed thing
    m_consoleSessionServers[consoleID] = ssi;
}

void Radio::onConnectionFailed(ServerIndex svrIdx)
{
	FUNCTION_ENTRY("onConnectionFailed");

    // each server raises the alarm via the IRadioCallback
    
	setDpServerLostConnection(svrIdx, true);
    //
    // notify the directory callback but only if the connection that has
    // failed is that of the ISCS RadioSession.
    if (m_directoryCallback != 0)
    {
        if (m_ISCSRadioSession->getTcpServer().getServerIndex() == svrIdx)
        {
            m_directoryCallback->onConnectionLost();
        }
    }

	FUNCTION_EXIT;
}

void Radio::onSwitchConnection(ServerIndex svrIdx)
{
	FUNCTION_ENTRY("onSwitchConnection");

    if (m_directoryCallback != 0)
    {
        if (m_ISCSRadioSession->getTcpServer().getServerIndex() == svrIdx)
        {
            m_directoryCallback->onSwitchConnection();
        }
    }

	FUNCTION_EXIT;
}

void Radio::onConnectionResumed(ServerIndex svrIdx)
{
	FUNCTION_ENTRY("onConnectionResumed");

	setDpServerLostConnection(svrIdx, false);

    if (m_ISCSRadioSession != 0)
    {
        if (m_ISCSRadioSession->getTcpServer().getServerIndex() == svrIdx)
        {
            if (m_directoryCallback != 0)
            {
                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugTrace, 
                        "Notifying Directory Callback of connection restored (server index %lu)", svrIdx);
                m_directoryCallback->onConnectionEstablish();
            }
        }
    }

	FUNCTION_EXIT;
}



RadioTcpServer * Radio::getAudioLinkServer(unsigned int audioLinkServerId)
{
    // if the requested server id is out of range, we just return null and
    // expect the client function to deal with that consequence
    if (m_radioTcpServers.size()>=(audioLinkServerId+1))
    {
        return m_radioTcpServers[audioLinkServerId];
    }

    return 0;
}

void Radio::removeSessionFromAudioMap(SessionID sessionReference, long serverIndex)
{
	RadioTcpServerArray::const_iterator it;
	for (   it = m_radioTcpServers.begin();
			it != m_radioTcpServers.end();
			it++)
	{
		if(serverIndex == (*it)->getServerIndex() )
		{
			(*it)->removeSessionFromAudioMap(sessionReference);
			break;
		}
	}
}
TA_Base_Bus::IRadioCorbaDef::SpeedDialList* Radio::getSpeedDialSet(const std::string& setName)
{
	FUNCTION_ENTRY("getSpeedDialSet");
	// Get the speed dial list from the database
	std::vector<TA_Base_Core::IRASpeedDialButton*> dialList = 
		TA_Base_Core::RASpeedDialButtonAccessFactory::getInstance().getSpeedDialSetByName(setName);
	
	// Create the speed dial list for returning.
	TA_Base_Bus::IRadioCorbaDef::SpeedDialList* c_dialList = 
		new TA_Base_Bus::IRadioCorbaDef::SpeedDialList();
	
	// Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
	// sequences don't automatically increase in size)
	c_dialList->length(dialList.size());
	
	// Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
	for (unsigned int i = 0;i < dialList.size();i++)
	{
		(*c_dialList)[i].label    = dialList[i]->getButtonLabel().c_str();
		(*c_dialList)[i].TSI      = dialList[i]->getButtonTSI().c_str();
		(*c_dialList)[i].position = static_cast<unsigned char>(dialList[i]->getButtonPosition());
		
		// And delete the database member while we're here
		delete dialList[i];
		dialList[i] = NULL;
	}
	
	FUNCTION_EXIT;
	return c_dialList;
}

void Radio::updateSpeedDialSet(const TA_Base_Bus::IRadioCorbaDef::SpeedDialSet& setDetails, const std::string& sessionID)
{
	FUNCTION_ENTRY("updateSpeedDialSet");
	// 1. Attempt to retrieve existing record (we don't pass setID through Corba)
	unsigned long setKey = ULONG_MAX;
	try
	{        
		RASpeedDialSet findSet(std::string(setDetails.setName));
		findSet.getSetName();
		setKey = findSet.getKey();
	}
	catch(DataException& ex)
	{
		if (ex.getFailType() != DataException::NO_VALUE)
		{
			throw TA_Base_Bus::IRadioCorbaDef::invalidSpeedDialSetException();
		}
	}
	
	// By here, we should either have setKey == ULONG_MAX to indicate new record
	// or, setKey == valid key in database. Note: zero is invalid !!!
	TA_ASSERT(0 != setKey,"Key was 0");
	
	// 2. Update the record in database (method decides whether to update or insert)
	RASpeedDialSet mySet(
		setKey, 
		setDetails.isSystem,
		setDetails.operatorID, 
		setDetails.profileID, 
		std::string(setDetails.setName),
		true // new record flag
		);
	mySet.applyChanges(); 
	mySet.getSetName(); // trigger reload
	
	FUNCTION_EXIT;
}


void Radio::updateSpeedDial(const std::string& setName, const TA_Base_Bus::IRadioCorbaDef::SpeedDialEntry& newEntry, const std::string& sessionID)
{
     FUNCTION_ENTRY("updateSpeedDial");

      // Determine the key of the set in which this button is located. The set must exist before a button can be added to it.
        unsigned long setKey = ULONG_MAX;
		//libo
		char sProfileID[9] = {0};
		std::string   setNameTemp=setName;
		if(setName == "User")
		{
			TA_Base_Bus::AuthenticationLibrary authLibrary;
			TA_Base_Bus::SessionInfo sessionInfo = authLibrary.getSessionInfo(sessionID,sessionID);
			int nProfileId = sessionInfo.ProfileId[0];
			sprintf( sProfileID, "_%d", nProfileId );
			setNameTemp +=  sProfileID;
		}
		//libo
        try
        {        
            RASpeedDialSet findSet(setNameTemp);
            findSet.getSetName();
            setKey = findSet.getKey();
        }
        catch(DataException&)
        {
            IRASpeedDialSet* dialSet = RASpeedDialSet::createNewSetByName(setNameTemp);
            dialSet->setSystem(false);
            // TODO: Don't leave this as a constant...
            if (setName == "User")
            {
                try
                {
                    TA_Base_Bus::AuthenticationLibrary authLibrary;

                    TA_Base_Bus::SessionInfo sessionInfo = authLibrary.getSessionInfo(sessionID,sessionID);
                    dialSet->setProfileId(sessionInfo.ProfileId[0]);
                }
                catch(...)
                {
                    throw TA_Base_Bus::IRadioCorbaDef::invalidSpeedDialSetException();
                }                
            }
            dynamic_cast<RASpeedDialSet*>(dialSet)->applyChanges();

            setKey = dialSet->getKey();

            delete dialSet;
            dialSet = NULL;
        }
        if (ULONG_MAX == setKey)
        {
            throw TA_Base_Bus::IRadioCorbaDef::invalidSpeedDialSetException();
        }

        // 2. Now find out if this button already exists. To do that, iterate through the list of all speed dial buttons.
        std::vector<TA_Base_Core::IRASpeedDialButton*> dialList = 
            TA_Base_Core::RASpeedDialButtonAccessFactory::getInstance().getSpeedDialSetByName(setNameTemp);
        std::vector<TA_Base_Core::IRASpeedDialButton*>::iterator i = std::find_if(dialList.begin(), dialList.end(),
            RASpeedDialButton::compareByButtonPosition(newEntry.position));

        try
        {
            // If the button currently exists...
            if (dialList.end() != i) 
            {
                // 3. If newEntry.label blank, delete this record
                if (strlen(newEntry.label)<1)
                {
                    TA_Base_Core::RASpeedDialButtonAccessFactory::getInstance().deleteSpeedDialButton(*i);
                }
                else
                {
                    // And if not, update the button details
					TA_Base_Core::RASpeedDialButton* speedDialButton = reinterpret_cast<TA_Base_Core::RASpeedDialButton*>(*i);
					TA_ASSERT(speedDialButton!=NULL,"Cannot access implementation of speed dial");
                    speedDialButton->setButtonLabel(std::string(newEntry.label));
                    speedDialButton->setButtonTSI(std::string(newEntry.TSI));
					speedDialButton->applyChanges();
                }
            }
            else
            {
                // It's a new button.
                unsigned long buttonID = ULONG_MAX;

                // create the button object, and apply changes
                RASpeedDialButton myButton(
                    buttonID, 
                    setKey,
                    newEntry.position, 
                    std::string(newEntry.label), 
                    std::string(newEntry.TSI),
                    true // new record flag
                    );
                myButton.applyChanges(); 
                myButton.getButtonLabel(); // trigger reload
            }
        }
        catch(...)
        {
            // Only catching here to clean up - dont' actually care what type of exception it is.
            for (unsigned int i = 0;i < dialList.size();i++)
            {
                delete dialList[i];
                dialList[i] = NULL;
            }
            // Rethrow
            throw;
        }

        // If no exception, still need to clean up...
        for (i = dialList.begin();i != dialList.end();i++)
        {
            delete (*i);
            (*i) = NULL;
        }


        FUNCTION_EXIT;
}

std::string Radio::getUserSetName(const std::string& sessionID)
{
	FUNCTION_ENTRY("getUserSetName");
	
	try
	{
		TA_Base_Bus::AuthenticationLibrary authLibrary;
		
		TA_Base_Bus::SessionInfo sessionInfo = authLibrary.getSessionInfo(sessionID,sessionID);
		
		IRASpeedDialSet* set = TA_Base_Core::RASpeedDialSetAccessFactory::getInstance().getRASpeedDialSetByProfile(sessionInfo.ProfileId[0]);
		
		return set->getSetName();
	}
	catch(...)
	{
		return "";
	}
}


//************************************
// IRadioDirectory Interface Methods *
//************************************

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::getGroupSubscribers()
    {
        FUNCTION_ENTRY("getGroupSubscribers");
        // Get the subscribers list from the database
        std::vector<TA_Base_Core::IRASubscribers*> groups = 
            TA_Base_Core::RAGroupMembersAccessFactory::getInstance().getGroupSubscribers();

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* groupSubscribers = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        groupSubscribers->length(groups.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < groups.size();i++)
        {
            (*groupSubscribers)[i].TSI = groups[i]->getTSI().c_str();
            (*groupSubscribers)[i].subscriberName = groups[i]->getSubscriberName().c_str();
            (*groupSubscribers)[i].locationName = groups[i]->getLocation().c_str();
            (*groupSubscribers)[i].locationKey = groups[i]->getLocationKey();
            (*groupSubscribers)[i].type = TA_Base_Bus::IRadioCorbaDef::GROUP_SUBSCRIBER;

            // And delete the database member while we're here
            delete groups[i];
            groups[i] = NULL;
        }

        FUNCTION_EXIT;
        return groupSubscribers;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::getPatchSubscribers()
    {
        FUNCTION_ENTRY("getPatchSubscribers");
        // Get the subscribers list from the database
        std::vector<TA_Base_Core::IRASubscribers*> patches = 
            TA_Base_Core::RAPatchMembersAccessFactory::getInstance().getPatchSubscribers();

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* patchSubscribers = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        patchSubscribers->length(patches.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < patches.size();i++)
        {
            (*patchSubscribers)[i].TSI = patches[i]->getTSI().c_str();
            (*patchSubscribers)[i].subscriberName = patches[i]->getSubscriberName().c_str();
            (*patchSubscribers)[i].locationName = patches[i]->getLocation().c_str();
            (*patchSubscribers)[i].locationKey = patches[i]->getLocationKey();
            (*patchSubscribers)[i].type = TA_Base_Bus::IRadioCorbaDef::PATCH_SUBSCRIBER;

            // And delete the database member while we're here
            delete patches[i];
            patches[i] = NULL;
        }

        FUNCTION_EXIT;
        return patchSubscribers;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::getIndividualSubscribers()
    {
        FUNCTION_ENTRY("getIndividualSubscribers");
        // Get the subscribers list from the database
        std::vector<TA_Base_Core::IRASubscribers*> individuals = 
            TA_Base_Core::RASubscribersAccessFactory::getInstance().getIndividualSubscribers();

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* individualSubscribers = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        individualSubscribers->length(individuals.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < individuals.size();i++)
        {
            (*individualSubscribers)[i].TSI = individuals[i]->getTSI().c_str();
            (*individualSubscribers)[i].subscriberName = individuals[i]->getSubscriberName().c_str();
            (*individualSubscribers)[i].locationName = individuals[i]->getLocation().c_str();
            (*individualSubscribers)[i].locationKey = individuals[i]->getLocationKey();
            (*individualSubscribers)[i].type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;

            // And delete the database member while we're here
            delete individuals[i];
            individuals[i] = NULL;
        }

        FUNCTION_EXIT;
        return individualSubscribers;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberDetails* Radio::getSubscriberDetails(const std::string& TSI)
    {
        FUNCTION_ENTRY("getSubscriberDetails");
        // Get the subscribers details from the database
        TA_Base_Core::IRASubscribers* subscriber = 
            TA_Base_Core::RASubscribersAccessFactory::getInstance().getSubscriberDetails(TSI);

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberDetails* subscriberDetails = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberDetails();

        subscriberDetails->TSI = CORBA::string_dup(subscriber->getTSI().c_str());
        subscriberDetails->subscriberName = CORBA::string_dup(subscriber->getSubscriberName().c_str());
        subscriberDetails->locationName = CORBA::string_dup(subscriber->getLocation().c_str());
        subscriberDetails->locationKey = subscriber->getLocationKey();
		subscriberDetails->ownerTSI = CORBA::string_dup("");
        IRASubscribers::SubscriberType type = subscriber->getSubscriberType();

        switch(type)
        {
        case IRASubscribers::DISPATCHER:
            {
				subscriberDetails->type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                break;
            }
        case IRASubscribers::GROUP:
            {
                subscriberDetails->type = TA_Base_Bus::IRadioCorbaDef::GROUP_SUBSCRIBER;
                break;
            }
        case IRASubscribers::MOBILE:
            {
				subscriberDetails->type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                break;
            }
        case IRASubscribers::PATCH_GROUP:
            {
                subscriberDetails->type = TA_Base_Bus::IRadioCorbaDef::PATCH_SUBSCRIBER;
                break;
            }
        case IRASubscribers::INDIVIDUAL:
            {
                subscriberDetails->type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                break;
            }
        }

        // And delete the database member while we're here
        delete subscriber;
        subscriber = NULL;

        FUNCTION_EXIT;
        return subscriberDetails;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::getGroupMembers(const std::string& TSI)
    {
        FUNCTION_ENTRY("getGroupMembers");
        // Get the subscribers list from the database
        TA_Base_Core::RAGroupMembersAccessFactory::GroupMembersType groupMembers = 
            TA_Base_Core::RAGroupMembersAccessFactory::getInstance().getGroupMembers(TSI);

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* groupMembersList = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        groupMembersList->length(groupMembers.second.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < groupMembers.second.size();i++)
        {
            (*groupMembersList)[i].TSI = groupMembers.second[i]->getTSI().c_str();
            (*groupMembersList)[i].subscriberName = groupMembers.second[i]->getSubscriberName().c_str();
            (*groupMembersList)[i].locationName = groupMembers.second[i]->getLocation().c_str();
            (*groupMembersList)[i].locationKey = groupMembers.second[i]->getLocationKey();
            (*groupMembersList)[i].type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;

            // And delete the database member while we're here
            delete groupMembers.second[i];
            groupMembers.second[i] = NULL;
        }

        FUNCTION_EXIT;
        return groupMembersList;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::getPatchMembers(const std::string& TSI)
    {
        FUNCTION_ENTRY("getPatchMembers");
        // Get the subscribers list from the database
        TA_Base_Core::RAPatchMembersAccessFactory::PatchMembersType patchMembers = 
            TA_Base_Core::RAPatchMembersAccessFactory::getInstance().getPatchMembers(TSI);

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* patchMembersList = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        patchMembersList->length(patchMembers.second.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < patchMembers.second.size();i++)
        {
            (*patchMembersList)[i].TSI = patchMembers.second[i]->getTSI().c_str();
            (*patchMembersList)[i].subscriberName = patchMembers.second[i]->getSubscriberName().c_str();
            (*patchMembersList)[i].locationName = patchMembers.second[i]->getLocation().c_str();
            (*patchMembersList)[i].locationKey = patchMembers.second[i]->getLocationKey();
            (*patchMembersList)[i].type = TA_Base_Bus::IRadioCorbaDef::GROUP_SUBSCRIBER;

            // And delete the database member while we're here
            delete patchMembers.second[i];
            patchMembers.second[i] = NULL;
        }

        FUNCTION_EXIT;
        return patchMembersList;
    }

    TA_Base_Bus::IRadioCorbaDef::SubscriberList* Radio::searchSubscriber(const std::string& searchText)
    {
        FUNCTION_ENTRY("searchSubscriber");
        // Get the subscribers list from the database
        std::vector<TA_Base_Core::IRASubscribers*> subscribers = 
            TA_Base_Core::RASubscribersAccessFactory::getInstance().searchSubscribers(searchText);

		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, "[search]: Search subscribers return %d match records.",subscribers.size());

        // Create the subscriber list for returning.
        TA_Base_Bus::IRadioCorbaDef::SubscriberList* subscriberList = 
            new TA_Base_Bus::IRadioCorbaDef::SubscriberList();

        // Set it's length (it's a CORBA sequence, and as such needs its length specifed, because
        // sequences don't automatically increase in size)
        subscriberList->length(subscribers.size());

        // Now put the data from the IRASubscribers into the SubscriberDetails objects in the CORBA sequence
        for (unsigned int i = 0;i < subscribers.size();i++)
        {
			LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug, 
						"[search]:search subscribers: TSI[%d] = %s,\
						subscribername[%d]=%s,location[%d]=%s.",i,subscribers[i]->getTSI().c_str(),i,subscribers[i]->getSubscriberName().c_str(),i,subscribers[i]->getLocation().c_str());

            (*subscriberList)[i].TSI = CORBA::string_dup(subscribers[i]->getTSI().c_str());
            (*subscriberList)[i].subscriberName = CORBA::string_dup(subscribers[i]->getSubscriberName().c_str());
            (*subscriberList)[i].locationName = CORBA::string_dup(subscribers[i]->getLocation().c_str());
            (*subscriberList)[i].locationKey = subscribers[i]->getLocationKey();
            IRASubscribers::SubscriberType type = subscribers[i]->getSubscriberType();

            switch(type)
            {
            case IRASubscribers::DISPATCHER:
                {
					(*subscriberList)[i].type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                    break;
                }
            case IRASubscribers::GROUP:
                {
                    (*subscriberList)[i].type = TA_Base_Bus::IRadioCorbaDef::GROUP_SUBSCRIBER;
                    break;
                }
            case IRASubscribers::MOBILE:
                {
					(*subscriberList)[i].type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                    break;
                }
            case IRASubscribers::PATCH_GROUP:
                {
                    (*subscriberList)[i].type = TA_Base_Bus::IRadioCorbaDef::PATCH_SUBSCRIBER;
                    break;
                }
            case IRASubscribers::INDIVIDUAL:
                {
                    (*subscriberList)[i].type = TA_Base_Bus::IRadioCorbaDef::INDIVIDUAL_SUBSCRIBER;
                    break;
                }
            }

            // And delete the database member while we're here
            delete subscribers[i];
            subscribers[i] = NULL;
        }

        FUNCTION_EXIT;
        return subscriberList;
    }

void Radio::setDpServerFallback(bool isFallback)
{
	m_serverLinkStatusThread->setLinkStatus(RadioServerLinkStatusUpdateThread::ServerFallback, isFallback);
}

void Radio::setDpServerLostConnection(int serverIndex, bool isLost)
{
	switch(serverIndex)
	{
	case 0:
		m_serverLinkStatusThread->setLinkStatus( RadioServerLinkStatusUpdateThread::Server0Down, isLost );
		break;
	case 1:
		m_serverLinkStatusThread->setLinkStatus( RadioServerLinkStatusUpdateThread::Server1Down, isLost );
		break;
	default:
		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugWarn, "Invalid TcpServer index , value = %d", serverIndex);
		break;
	}
}
