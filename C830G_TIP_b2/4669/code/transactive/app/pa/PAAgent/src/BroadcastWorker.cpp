/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/4669_T01271350/4669/transactive/app/pa/PAAgent/src/BroadcastWorker.cpp $
  * @author:  Ripple
  * @version: $Revision: #2 $
  *
  * Last modification: $DateTime: 2009/05/13 15:05:48 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  BroadcastWorker.cpp
//  Implementation of the Class BroadcastWorker
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290)
#endif // defined _MSC_VER

#include <time.h>
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/message/src/MessagePublicationManager.h"
#include "core/message/src/StateUpdateMessageSender.h"
#include "core/message/types/PAAgentStateUpdate_MessageTypes.h"
#include "core/message/types/PAAgentComms_MessageTypes.h"
#include "core/message/src/CommsMessageSender.h"
#include "app/pa/PAAgent/src/BroadcastWorker.h"
#include "app/pa/PAAgent/src/AbstractBroadcast.h"
#include "app/pa/PAAgent/src/AbstractBroadcastCircularList.h"
#include "app/pa/PAAgent/src/CachedConfig.h"
#include "core/message/src/MessageSubscriptionManager.h"

using namespace TA_Base_Core;

namespace TA_IRS_App
{

// ExceptionChecked
BroadcastWorker::BroadcastWorker () 
: m_allBroadcasts(NULL),
  m_isRunning(false),
  m_paAgentCommsSender(NULL),
  m_trainAgentSubscriber(),
  m_stateUpdateMessageSender(NULL),
  m_isEnabled(false),
  m_cachedConfigInstance(NULL),
  m_isChangingToControlMode(false)
{
    FUNCTION_ENTRY("Constructor");

    m_allBroadcasts = AbstractBroadcastCircularList::getInstance();

    m_cachedConfigInstance = CachedConfig::getInstance();
    if (!m_paAgentCommsSender)
    {
        m_paAgentCommsSender = 
            MessagePublicationManager::getInstance().getCommsMessageSender( PAAgentComms::Context );
    }

    if (!m_stateUpdateMessageSender)
    {
        m_stateUpdateMessageSender = 
            MessagePublicationManager::getInstance().getStateUpdateMessageSender(PAAgentStateUpdate::Context);
    }

	FUNCTION_EXIT;
}



// ExceptionChecked
BroadcastWorker::~BroadcastWorker()
{
    FUNCTION_ENTRY("Destructor");
    TA_ASSERT(!m_isRunning, "Deleting a running thread");

    m_trainAgentSubscriber.unsubscribe();

    if ( m_stateUpdateMessageSender != NULL )
    {
	    delete m_stateUpdateMessageSender;
	    m_stateUpdateMessageSender = NULL;
    }

    if (m_paAgentCommsSender)
    {
        delete m_paAgentCommsSender;
        m_paAgentCommsSender = NULL;
    }

    m_allBroadcasts = NULL;

	FUNCTION_EXIT;
}



// ExceptionChecked
void BroadcastWorker::run()
{
    FUNCTION_ENTRY("run");

    m_trainAgentSubscriber.subscribe();
    m_isRunning = true;

    while (m_isRunning)
    {
		if(!m_isChangingToControlMode)
		{
			try
			{
				// This call will block if nothing is there
				processNextBroadcast(m_allBroadcasts->getNext());
			}
			catch (...)
			{
				// Not expecting any failures...
				LOG_EXCEPTION_CATCH( SourceInfo, "Unknown exception", "Unknown reason" );
			}
		}
		else
		{
			Thread::sleep(10000);
		}

        Thread::sleep ( m_cachedConfigInstance->getWorkerThreadsSleepTimeInMSecs() );
    }

    m_trainAgentSubscriber.unsubscribe();

    FUNCTION_EXIT;
}


// ExceptionChecked
void BroadcastWorker::terminate()
{
    FUNCTION_ENTRY("terminate");

    m_isRunning = false;
    // Wake up the semaphore so we can exit the run loop
    m_allBroadcasts->unBlockList();

    FUNCTION_EXIT;
}

void BroadcastWorker::processNextBroadcast(AbstractBroadcast* broadcast)
{
    if (!broadcast)
    {
        return;
    }

    if (!m_isEnabled)
    {
        return;
    }

    switch (broadcast->getBroadcastState())
    {
    case TA_Base_Bus::IPAAgentCorbaDef::Creation:
        broadcast->setBroadcastState(TA_Base_Bus::IPAAgentCorbaDef::Execution);
        sendProgressUpdateIfChanged(broadcast);
        break;
    case TA_Base_Bus::IPAAgentCorbaDef::Execution:
        broadcast->execute();
        sendProgressUpdateIfChanged(broadcast);
        break;
    case TA_Base_Bus::IPAAgentCorbaDef::Runtime:
        broadcast->updateRuntimeState();
        sendProgressUpdateIfChanged(broadcast);
        break;
    case TA_Base_Bus::IPAAgentCorbaDef::Termination:
        broadcast->terminate();
        sendProgressUpdateIfChanged(broadcast);
        break;
    case TA_Base_Bus::IPAAgentCorbaDef::PendingRemoval:
        if (shouldRemoveBroadcast(broadcast))
        {
            deleteBroadcast(broadcast);
            broadcast = NULL;
        }
        break;
    default:
        // CorruptInternalStateData - we will dispose of this broadcast
        deleteBroadcast(broadcast);
        broadcast = NULL;
        break;
    }
}

void BroadcastWorker::deleteBroadcast(AbstractBroadcast* broadcast)
{
    TA_ASSERT(broadcast, "broadcast is NULL");

    m_allBroadcasts->remove(broadcast);

    // Notify all PA Managers
    TA_Base_Bus::IPAAgentCorbaDef::CurrentBroadcastsUpdateData updateData;

    // Note: string members will make a deep copy from a const char*
    updateData.fromBroadcastId = broadcast->getBroadcastId().c_str();
    updateData.toBroadcastId   = CORBA::string_dup("");
    updateData.broadcastType   = broadcast->getBroadcastType();
    updateData.sessionId       = broadcast->getSessionId().c_str();

    PasHelpers::getInstance()->sendCurrentBroadcastsUpdate(updateData);
    PasHelpers::getInstance()->sendPAAgentRemovedBroadcastUpdate( broadcast->getBroadcastId().c_str() );

    delete broadcast;
    broadcast = NULL;
}

bool BroadcastWorker::shouldRemoveBroadcast(AbstractBroadcast* broadcast)
{
    if (broadcast->getIsEventTriggered())
    {
        return true;
    }

    if (broadcast->getIsTaggedForRemoval())
    {
        return true;
    }

    switch(broadcast->getBroadcastType())
    {
    case TA_Base_Bus::IPAAgentCorbaDef::StationMusic:
        // All music (and music termination) broadcasts are removed ASAP.
    case TA_Base_Bus::IPAAgentCorbaDef::StationRecording:
        // Same goes for the recording broadcast as there is no option to
        // retry.
        return true;
    case TA_Base_Bus::IPAAgentCorbaDef::StationDva:
    case TA_Base_Bus::IPAAgentCorbaDef::StationLive:
    case TA_Base_Bus::IPAAgentCorbaDef::TrainDva:
    case TA_Base_Bus::IPAAgentCorbaDef::TrainLive:

        // In the case of live broadcasts, these should be removed as soon as
        // the operator closes the status dialog.  In the odd occurrence that 
        // the PA Manager crashes, the terminated live broadcast will be 
        // cleaned up in 24 hours regardless.
        {
	        time_t now = time(NULL);
            time_t howOld = now - broadcast->getLastUpdate();
            if (howOld > m_cachedConfigInstance->getKeepTerminatedBroadcastsInSecs())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    default:
        // CorruptInternalStateData - we will dispose of this broadcast
        return true;
    }

    return true;
}

void BroadcastWorker::sendProgressUpdateIfChanged(AbstractBroadcast* broadcast)
{
    if (!broadcast->getHasProgressReportChanged())
    {
        return;
    }

    if (broadcast->getIsEventTriggered())
    {
        // No updates for event triggered broadcasts required
        return;
    }

    LOG(SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugInfo, 
        "Sending BroadcastProgressUpdate message for broadcastId=%s",
        broadcast->getBroadcastId().c_str());

    CORBA::Any data;
    NameValuePair nvp( TA_Base_Bus::IPAAgentCorbaDef::BROADCAST_ID_FILTER_STRING,
                       broadcast->getBroadcastId() );

    std::vector<NameValuePair*> extraFilterableData;
    extraFilterableData.push_back(&nvp);

    data <<= broadcast->getProgressReportCopy();

    // Send Comms message for PA Managers
    m_paAgentCommsSender->sendCommsMessage(
        PAAgentComms::BroadcastProgressUpdate,                  // Context::Type
        m_cachedConfigInstance->getAgentKey(),                  // EntityKey
        data,                                                   // Data
        m_cachedConfigInstance->getAgentSubsystemKey(),         // Subsystem
		m_cachedConfigInstance->getAgentLocationKey(),          // LocationKey
        &extraFilterableData);                                  // BroadcastId

    // Send State update message for PA Agents
    m_stateUpdateMessageSender->sendStateUpdateMessage(
        PAAgentStateUpdate::PAAgentBroadcastProgressUpdate,
        0,
        m_cachedConfigInstance->getAgentName(),
        data );

    // reset the flag
    broadcast->setHasProgressReportChanged(false);
}

} // namespace TA_IRS_App

