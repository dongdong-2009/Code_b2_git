/**
  * The source code in this file is the property of 
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source: $File$
  * @author Nick Jardine
  * @version $Revision$
  * Last modification: $DateTime$
  * Last modified by: Nick Jardine
  * 
  * SimpleDbDatabase is an implementation of IDatabase, and is responsible for executing queries
  * on the database. It does not analyse the returned data - that is the responsiblility of 
  * SimpleDbData. 
  * SimpleDbDatabase is specific to SimpleDb and will not work for any other database library.
  * 
  */


///////////////////////////////////////////////////////////
//
//  SimpleDbDatabase.cpp
//  Implementation of the Class SimpleDbDatabase
//  Generated by Enterprise Architect
//  Created on:      11-Mar-2003 15:25:06
//  Original author: Karen Graham
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#ifdef __WIN32__
#pragma warning(disable:4786)
#pragma warning(disable:4503)
#endif

#include <sstream>
#include "core/data_access_interface/src/SimpleDbDatabase.h"
#include "core/data_access_interface/src/SimpleDbData.h"
#include "core/data_access_interface/src/DbStatus.h"
#include "core/database/src/SimpleDb.h"
#include "core/database/src/DBException.h"
#include "core/database/src/OCIConnection.h"
#include "core/exceptions/src/DatabaseException.h"
#include "core/exceptions/src/DataException.h"
#include "core/exceptions/src/DbConnectionFailed.h"
#include "core/exceptions/src/DbUniqueConstraintViolated.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/RunParams.h"

using TA_Base_Core::DebugUtil;

using TA_Base_Core::DatabaseException;

namespace TA_Base_Core
{
 
    void SimpleDbDatabase::connect(const std::string& connectionString)
	{
		FUNCTION_ENTRY("connect");

        if (m_db == NULL) // The pointer has not been initialised. We need to set it up.
		{
			// Get the database connection information (i.e. servicename:username:password).
			//
            LOG ( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugDebug,
                    "SimpleDbDatabase::connect(): Database connection string is: %s", connectionString.c_str());

			// Parse the Connection String to seperate the database connection information.
			//
			std::vector<std::string> dbConnData;
			SimpleDb::ParseConnectStr(connectionString, dbConnData); 

			// 3 is used because dbConnData should consist of servicename:username:password
			// The comparrison operator is "<" to support legacy connection strings that include
			// the hostname on the end. Oracle will ignore all but the first three items anyway, so
			// as long as we have at least three, then there is not a problem.
			if (dbConnData.size() < 3) //The connection string is not valid
			{
                FUNCTION_EXIT;
				TA_THROW( DbConnectionFailed("The database connection string is not valid.") );
			}

			// SimpleDb creates the database connection in the constructor, hence we must 
			// pass the connection string with a call to "new"
			try
			{
				m_db = new SimpleDb(dbConnData[0].c_str(), dbConnData[1].c_str(), dbConnData[2].c_str());
			}
			catch( const DBException& e )
			{
                try
                {
                    // mark this db bad if we can
                    std::string db (RPARAM_DBPREFIX + dbConnData[0] );
                    DbStatus::getInstance().onRunParamChange(db, std::string(RPARAM_DBOFFLINE));
                }
                catch(...)
                {
                }
				LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
                FUNCTION_EXIT;
				TA_THROW( DatabaseException(e.getReason()) );
			}
		}

        try
        {
            tryToOpenDb();
        }
        catch( const DBException& e )
        {
            // this db has gone bad, caller should try another one
            disconnect();
            try
            {
			    // Parse the Connection String to seperate the database connection information.
			    //
			    std::vector<std::string> dbConnData;
			    SimpleDb::ParseConnectStr(connectionString, dbConnData); 
                // mark this db bad if we can
                std::string db (RPARAM_DBPREFIX + dbConnData[0] );
                DbStatus::getInstance().onRunParamChange(db, std::string(RPARAM_DBOFFLINE));
            }
            catch(...) // don't care about errors - nothing we can do about them anyway
            {
            }
            LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
            FUNCTION_EXIT;
            TA_THROW( DatabaseException(e.getReason()) );
        }
		FUNCTION_EXIT;
	}


	void SimpleDbDatabase::disconnect()
	{
		FUNCTION_ENTRY("disconnect");
		if (NULL != m_db)
		{
			try
			{
				m_db->Close();
			}
			catch( const DBException& e )
			{
				LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
			}

			delete m_db;
			m_db = NULL;
		}
		FUNCTION_EXIT;
	}

	SimpleDbDatabase::~SimpleDbDatabase()
	{
		FUNCTION_ENTRY("~SimpleDbDatabase");
		disconnect();
		FUNCTION_EXIT;
	}

	void SimpleDbDatabase::cleanQuery()
	{
		FUNCTION_ENTRY("cleanQuery");
		if(m_db != NULL)
		{
			try
			{
				m_db->cleanQuery();
			}
			catch ( ... )
			{
				LOG(SourceInfo, DebugUtil::ExceptionCatch, DebugUtil::DebugDatabase, "database cleanQuery failure");
			}
		}
		else
		{
			LOG(SourceInfo, DebugUtil::ExceptionCatch, DebugUtil::DebugDatabase, "database is NULL");
		}
		FUNCTION_EXIT;
	}

	IData* SimpleDbDatabase::executeQuery(const std::string& sql,const std::vector<std::string>& columnNames)
	{
		return( executeQuery( sql, columnNames, SimpleDb::MAX_ROWS ) );
	}

	IData* SimpleDbDatabase::executeQuery(const std::string& sql,const std::vector<std::string>& columnNames,
										  const unsigned long numRows )
	{
		FUNCTION_ENTRY("executeQuery");

        LOG ( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugSQL, "SimpleDbDatabase::executeQuery(): SQL statement to execute is: %s", sql.c_str());

        // Assert the pre-conditions on this function
		TA_ASSERT(0 < sql.size(),"SQL statement passed in is zero size");
		TA_ASSERT(0 < numRows, "numRows is 0 - this is not a sensible number");
		TA_ASSERT(static_cast<unsigned int>(SimpleDb::MAX_ROWS) >= numRows, "numRows is greater than SimpleDb::MAX_ROWS - this is not permissable by SimpleDb");
        TA_ASSERT(columnNames.size() <= static_cast<unsigned int>(m_db->getMaxColumns()), "number of columns is greater than OCIAccess::MAX_COLS - not permissable by SimpleDb");
		TA_ASSERT(0 < columnNames.size(), "columnNames is zero size");
		TA_ASSERT(NULL != m_db, "Database pointer is null."); // connect has not been called
		
		tryToOpenDb();

		// Create a buffer in which to store the retrieved data
		Buffer data;

		try
		{
			m_db->Exec( sql.c_str(), columnNames.size(), data, numRows );
		}
		catch( const DBException& e )
		{
            disconnect();
            try
            {
                DatabaseFactory::getInstance().getDatabase(m_dataType, m_dataAction, this);
                m_db->Exec( sql.c_str(), columnNames.size(), data, numRows );
            }
            catch(...)
            {
                // if we catch anything it means there are no dbs available
                // so just throw original error
                LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
                TA_THROW( DbConnectionFailed(e.getReason()) );
            }
        }

		// Set the member variables to match the passed-in variables
		m_columnNames = columnNames;
		

		// Place the data we just loaded into an instance of TA_Base_Core::SimpleDbData (which IS A IData)
		TA_Base_Core::SimpleDbData* idata = new TA_Base_Core::SimpleDbData(columnNames,data);
		m_numRows = idata->getNumRows();

		FUNCTION_EXIT;
		return idata; // Return a pointer to the new IData object
	}



	void SimpleDbDatabase::executeModification(const std::string& sql)
	{
		FUNCTION_ENTRY("executeModification");

        LOG ( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugDebug,
                "The SQL modification to execute is: %s", sql.c_str());

		// Assert the pre-conditions on this function
		TA_ASSERT(0 < sql.size(),"SQL statement passed in is zero size");
		TA_ASSERT(NULL != m_db, "Database pointer is null."); // connect has not been called

		tryToOpenDb();

		try
		{
			m_db->Exec( sql.c_str() );

#ifdef TDS_DEVELOP
			// If running in TDS station, log update SQL which trigged from CE, add by hongzhi
			if((RunParams::getInstance().get(RPARAM_ENTITYNAME).compare("ConfigurationEditor") == 0) &&
				(TA_Base_Core::RunParams::getInstance().isSet(RPARAM_TDSCE)))
			{
				std::string str = TA_Base_Core::RunParams::getInstance().get("ComponentType");
				LOG_GENERIC( SourceInfo, DebugUtil::DebugDebug, "ComponentType=%s",str.c_str());
				if((TA_Base_Core::RunParams::getInstance().get("ComponentType").compare("DataPoints") == 0) ||
					(TA_Base_Core::RunParams::getInstance().get("ComponentType").compare("Displays") == 0) || 
					(TA_Base_Core::RunParams::getInstance().get("ComponentType").compare("Station System") == 0) ||
					(TA_Base_Core::RunParams::getInstance().get("ComponentType").compare("MMS Scheduling") == 0))
				{
					if(sql.find("update config_editor_timestamp set last_timestamp = current_timestamp") == std::string::npos 
						&& sql.find("insert into EVENT ") == std::string::npos
						&& sql.find("update TDS_SQLLOG set LOG_CONTENT='") == std::string::npos
						&& sql.find("insert into USER_SETTINGS(OP_KEY,AP_TYPE_KEY,SETTING_NAME,SETTING_VALUE) values")==std::string::npos)
					{
						std::string strSql = sql;
						if (  (strSql.find("audit_data_queue_pkg.enqueue_audit_data") != std::string::npos)
							||(strSql.find("AUDIT_DATA_QUEUE_PKG.ENQUEUE_AUDIT_DATA") != std::string::npos)  )
						{	// there are aq statement inside, if we filter aq, just call ParserCallPkgString() instead of escapeInsertString()
							ParserCallPkgString(strSql);
//							strSql = escapeInsertString(strSql);
						}
						else
						{	//it is not a aq statement, it is a normal statement
							strSql = escapeInsertString(strSql);			//call this always no matter if it is aq
						}
						ParserSQLString(strSql);		//add ";" and "/n" to the end of sql
						std::string sqlTDS;
						sqlTDS = "update tds_sqllog set log_content = concat((select log_content from tds_sqllog) , '" + strSql + "')";
						m_db->Exec( sqlTDS.c_str() );
//						TdsSQLLoggerWritter::getInstance().WriteTDSLog(sqlTDS.c_str());
					}
				}
			}
#endif
		}
		catch( const DBException& e )
		{
			LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );

			switch( e.getNativeCode() )
			{
				case OCIConnection::UNIQUE_CONSTRAINT_VIOLATED_ERROR:
					TA_THROW( DbUniqueConstraintViolated(e.getReason()) );
					break;

				default:
                    // this db has gone bad, try another one
                    disconnect();
                    try
                    {
                        DatabaseFactory::getInstance().getDatabase(m_dataType, m_dataAction, this);
                        m_db->Exec( sql.c_str() );
                    }
                    catch(...)
                    {
                        // if we catch anything it means there are no dbs available
                        // so just throw original error
                        LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
                        TA_THROW( DbConnectionFailed(e.getReason()) );
                    }
					break;
			}
		}
		FUNCTION_EXIT;
	}


	IData* SimpleDbDatabase::executeProcedure(const std::string& sql,const std::vector<std::string>& columnNames,
											  const unsigned long numRows /*=1000*/)
	{
		// Due to restrictions in SimpleDb, we are not able to return data from a procedure.
        // As such, the use of this method is a programming error.
        TA_ASSERT(false,"This method is not valid for SimpleDbDatabase");

        // We have to return here to allow the program to compile
        return NULL;
	}


	void SimpleDbDatabase::executeProcedure(const std::string& sql)
	{
		// Oracle procedures are executed in the same manner as standard queries - therefore we use
		// the same code
		executeModification(sql);
	}


	bool SimpleDbDatabase::moreData(IData*& returnData)
	{
		FUNCTION_ENTRY("moreData");

		// The IData pointer MUST be null when passed to this method. If it is not, a memory leak 
		// will result. This is tested by the assert.
		TA_ASSERT(NULL != m_db            , "Database pointer is null");
		//TA_ASSERT( false != m_db->IsOpen(), "Database must be open to request more data" );
		if (! m_db->IsOpen())
		{
			tryToOpenDb();
			LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugWarn, "jhp, why the m_db is closed? Database must be open to request more data");
		}

		if (true == m_db->HasMore()) // There is data to read
		{
			Buffer data;

			try
			{
				LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugDatabase, "OCL calling FetchMore...");
				m_db->FetchMore( m_columnNames.size(),data, SimpleDb::MAX_ROWS );
			}
			catch( const DBException& e )
			{
				LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
				TA_THROW(DatabaseException(e.getReason()) );
			}

	        // Check if there was actually more data to retrieve
            if(data.size() == 0)
            {
				FUNCTION_EXIT;
                return false;
            }

			returnData = new TA_Base_Core::SimpleDbData(m_columnNames, data);
			FUNCTION_EXIT;
			return true;
		}
 		else
 		{
			m_db->cleanQuery();
 		}

		FUNCTION_EXIT;
		return false; // There was no more data to read
	}


	void SimpleDbDatabase::readBLOB( const std::string& fieldName, const std::string& tableName, 
									 const std::string& whereClause, std::vector<unsigned char>& data )
	{
		TA_ASSERT( m_db != NULL, "Database pointer has not been initialised" );
		TA_ASSERT( fieldName.length() > 0, "The BLOB field name has not been specified" );
		TA_ASSERT( tableName.length() > 0, "The BLOB table name has not been specified" );
		
		tryToOpenDb();
		
		try
		{
			m_db->readBLOB( fieldName, tableName, whereClause, data );
		}
		catch( const DBException& e )
		{
            // this db has gone bad, try another one
            disconnect();
            try
            {
                DatabaseFactory::getInstance().getDatabase(m_dataType, m_dataAction, this);
                m_db->readBLOB( fieldName, tableName, whereClause, data );
            }
            catch(...)
            {
                // if we catch anything it means there are no dbs available
                // so just throw original error
                LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );

                LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, "Failed to read BLOB filed \
				%s from table %s with clause %s", fieldName.c_str(), tableName.c_str(), whereClause.c_str() );

                TA_THROW( DatabaseException(e.getReason()) );
            }
		}
	}	


	void SimpleDbDatabase::writeBLOB( const std::string& fieldName, const std::string& tableName, 
									  const std::string& whereClause, std::vector<unsigned char>& data )
	{
		TA_ASSERT( m_db != NULL, "Database pointer has not been initialised" );
		TA_ASSERT( fieldName.length() > 0, "The BLOB field name has not been specified" );
		TA_ASSERT( tableName.length() > 0, "The BLOB table name has not been specified" );
		
		tryToOpenDb();


		try
		{
			m_db->writeBLOB( fieldName, tableName, whereClause, data );
		}
		catch( const DBException& e )
		{
            // this db has gone bad, try another one
            disconnect();
            try
            {
                DatabaseFactory::getInstance().getDatabase(m_dataType, m_dataAction, this);
                m_db->writeBLOB( fieldName, tableName, whereClause, data );
            }
            catch(...)
            {
                // if we catch anything it means there are no dbs available
                // so just throw original error
                LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );

                LOG( SourceInfo, DebugUtil::GenericLog, DebugUtil::DebugError, "Failed to write BLOB filed \
				%s to table %s with clause %s", fieldName.c_str(), tableName.c_str(), whereClause.c_str() );

                TA_THROW( DatabaseException(e.getReason()) );
            }
		}
	}	


    //Mintao++: use for Distributed DB
    std::string SimpleDbDatabase::escapeAQSQLString(const std::string& theString)
    {
        return (escapeInsertString(escapeInsertString(theString)));         
    }
    //Mintao++: use for Distributed DB

    std::string SimpleDbDatabase::escapeInsertString(const std::string& theString)
    {
        // create a new string to hold the parsed string
        std::string escapedString = theString;
		std::string::size_type pos = escapedString.find_first_of("'");
		while (std::string::npos != pos)
        {
            char charToInsert = escapedString.at(pos);
            escapedString.insert(pos,&charToInsert, 1);
			pos = escapedString.find_first_of("'", pos + 2);
        }
        return escapedString;
    }

    std::string SimpleDbDatabase::escapeQueryString(const std::string& theString)
    {
        return escapeInsertString(theString);
    }

   
    void SimpleDbDatabase::beginTransaction()
    {
        TA_ASSERT(false,"beginTransaction() is not supported by SimpleDb");
    }

   
    void SimpleDbDatabase::commitTransaction()
    {
        TA_ASSERT(false,"commitTransaction() is not supported by SimpleDb");
    }

    void SimpleDbDatabase::rollbackTransaction()
    {
        TA_ASSERT(false,"rollbackTransaction() is not supported by SimpleDb");
    }

	void SimpleDbDatabase::tryToOpenDb()
	{
		if( false == m_db->IsOpen() )
		{
			try
			{
				m_db->Open();
			}
			catch( const DBException& e )
			{
				LOG( SourceInfo, DebugUtil::ExceptionCatch, "TA_Base_Core::DBException", e.getSummary().c_str() );
				//TD17205,jianghp				
				TA_THROW(e);				
			}
		}
	}

#ifdef TDS_DEVELOP
	//hongzhi, for TDS
	void SimpleDbDatabase::ParserCallPkgString(std::string& str)
	{
		std::string::size_type len = 0,  pos_begin, pos_end;
		
		pos_begin = str.find(",");
		if (pos_begin !=std::string::npos )
		{
			pos_begin = str.find(",",pos_begin+1);
			if (pos_begin !=std::string::npos )
			{
				pos_begin = str.find("'",pos_begin+1);		//find third parameter
			}
		}
		str.erase(0, pos_begin+1);
		
		pos_end = str.rfind("'");
		if (pos_begin !=std::string::npos )
		{
			len = str.length();
			str.erase(pos_end, len - pos_end);
		}		
		str = str + ";";
		LOG_GENERIC(SourceInfo, DebugUtil::DebugSQL, "ParserCallPkgString returned: %s",str.c_str());
	}
	//hongzhi, for TDS
	void SimpleDbDatabase::ParserSQLString(std::string& str)
	{		
		std::string::size_type len = 0, dindx =std::string::npos;
		len = str.length();
		dindx = str.rfind(";");
		
		if ( ( dindx == std::string::npos ) || ( (dindx != std::string::npos)&&(dindx < (len -3)) ) ) 
		{
			str += ';';			
		}
		str += '\n';
		
        dindx =std::string::npos;
		std::string::size_type indx1 = std::string::npos, indx2 = std::string::npos, indx3 = std::string::npos;
		
		indx1 = str.find("begin");
		indx2 = str.find("BEGIN");
		indx3 = str.find("Begin");
		
		if ((indx1 != std::string::npos) && (indx1 < 3))
			dindx = indx1;
		if ((indx2 != std::string::npos) && (indx2 < 3))
			dindx = indx2;
		if ((indx3 != std::string::npos) && (indx3 < 3))
			dindx = indx3;
		
		if (dindx != std::string::npos)
		{
			//need to add '/' and '\n'
			str += '/';
			str += '\n'; 
		}
		LOG_GENERIC(SourceInfo, DebugUtil::DebugSQL, "ParserSQLString returned: %s",str.c_str());
	}

	//hongzhi, for TDS
	std::string SimpleDbDatabase::getNextPkey(const std::string& strSeqName)
	{
		std::string sql;
		sql = "select pkg_seq.get_next_number('" + strSeqName + "') as NEXT_PKEY from Dual";

		std::vector<std::string> columnNames;
		columnNames.push_back("NEXT_PKEY");
		
		// Run the query
		IData* data = executeQuery(sql,columnNames);
		
		// check the number of rows returned - 1 is good, antything else is bad.
		if (data->getNumRows()<1) // No entry found with the specified name
		{
			// clean up the pointer
			delete data;
			data = NULL;
			
			std::ostringstream reasonMessage;
			reasonMessage << "Cannot get next pkey for sequence " << strSeqName.c_str();
			TA_THROW (DataException(reasonMessage.str().c_str(),DataException::NO_VALUE,"") );
		}
		
		std::ostringstream strRet;
		strRet << data->getUnsignedLongData(0,"NEXT_PKEY");

		return strRet.str();
	}
#endif
} // closes TA_Base_Core
