/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/GZL6_TIP/3002/transactive/app/ecs/ECSAgent/src/IscsAliveWorker.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2012/06/12 13:35:44 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  IscsAliveWorker.cpp
//  Implementation of the Class IscsAliveWorker
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author:
//
///////////////////////////////////////////////////////////
//  Modification history:
//
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290 4503)
#endif // defined _MSC_VER

#include <time.h>

#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/synchronisation/src/ThreadGuard.h"

#include "core/data_access_interface/src/LocationAccessFactory.h"	// TD19822
#include "core/data_access_interface/src/ILocation.h"				// TD19822


#include "bus/scada/common_library/src/CobraCppConvertUtilities.h"
#include "bus/scada/common_library/src/DpValue.h"
#include "bus/scada/proxy_library/src/IDataPointProxy.h"
#include "bus/scada/proxy_library/src/DataPointProxySmartPtr.h"


#include "app/ecs/ECSAgent/src/IscsAliveWorker.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedConfig.h"
#include "app/ecs/ECSAgent/src/ItaEcsDatapoints.h"
#include "app/ecs/ECSAgent/src/EcsGlobals.h"

// This needs to be calculated since CLOCKS_PER_SEC is different on different platforms
static const unsigned long CLOCKS_PER_MSEC = CLOCKS_PER_SEC / 1000;
static const unsigned long OCC_DEAD_PSC_ALIVE_VALUE = 2;
static const unsigned long OCC_ALIVE_PSC_ALIVE_VALUE = 3;


IscsAliveWorker::IscsAliveWorker(ItaEcsCachedConfig& theConfig, ItaEcsDatapoints& theDatapoints)
: m_isRunning(false),
  m_theConfig(theConfig),
  m_theDatapoints(theDatapoints),
  m_dpAccessInterface(NULL),
  m_entityKey(0),
  m_timerUtility(TA_Base_Core::SingletonTimerUtil::getInstance()),
  m_proxyFactory ( 0 )
{
    FUNCTION_ENTRY("Constructor");

	m_dpAccessInterface = new DpAccessInterface();
	m_dpAccessInterface->setObjectTimeout(5);

	// TD19822++
	// get a handle to the ScadaProxyFactory
	m_proxyFactory = &(TA_Base_Bus::ScadaProxyFactory::getInstance());
	TA_ASSERT ( ( 0 != m_proxyFactory ), "SCADA Proxy Factory not created");
	m_proxyFactory->setProxiesToControlMode();

	initProxy();
	// ++TD19822

    FUNCTION_EXIT;
}

void IscsAliveWorker::initProxy()
{
	TA_Base_Core::ILocation* locationInfo = TA_Base_Core::LocationAccessFactory::getInstance().getLocationByKey(m_theConfig.getAgentLocationKey());
    std::string locationName = locationInfo->getName();
	delete locationInfo;
	locationInfo = NULL;
	
	std::string rtu1PollingStatusEntityName = locationName + ".BMF.SWC.RTU01ECS.tdiSWCR-PollingStatus";
	std::string rtu2PollingStatusEntityName = locationName + ".BMF.SWC.RTU02ECS.tdiSWCR-PollingStatus";
	LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "zhangnan RTU1 = %s, RTU2 = %s", rtu1PollingStatusEntityName.c_str(), rtu2PollingStatusEntityName.c_str());
	
	TA_Base_Core::IEntityData* rtu1EntityData = TA_Base_Core::EntityAccessFactory::getInstance().getEntity(rtu1PollingStatusEntityName);
	TA_Base_Core::DataPointEntityData* rtu1DPEntityData = dynamic_cast<TA_Base_Core::DataPointEntityData*>(rtu1EntityData);
	TA_ASSERT(rtu1DPEntityData != NULL, "RTU1 is not defined as datapoint entity");
	
	TA_Base_Core::IEntityData* rtu2EntityData = TA_Base_Core::EntityAccessFactory::getInstance().getEntity(rtu2PollingStatusEntityName);
	TA_Base_Core::DataPointEntityData* rtu2DPEntityData = dynamic_cast<TA_Base_Core::DataPointEntityData*>(rtu2EntityData);
	TA_ASSERT(rtu2DPEntityData != NULL, "RTU2 is not defined as datapoint entity");
	
	m_proxyFactory->createDataPointProxy(boost::shared_ptr<TA_Base_Core::DataPointEntityData>(rtu1DPEntityData), m_nullEventProcessor, m_rtu1proxy);
	m_proxyFactory->createDataPointProxy(boost::shared_ptr<TA_Base_Core::DataPointEntityData>(rtu2DPEntityData), m_nullEventProcessor, m_rtu2proxy);

}



// ExceptionChecked
IscsAliveWorker::~IscsAliveWorker()
{
    FUNCTION_ENTRY("Destructor");

	delete m_dpAccessInterface;
    m_dpAccessInterface = NULL;

	// TD19822++
	// remove handle to ScadaProxyFactory
	m_proxyFactory->setProxiesToMonitorMode();
	TA_Base_Bus::ScadaProxyFactory::removeInstance();
	m_proxyFactory = NULL;
	// ++TD19822
    
    FUNCTION_EXIT;
}

void IscsAliveWorker::timerExpired(long timerId, void* userData)
{
    m_enableSignal.signal();
}

// ExceptionChecked
void IscsAliveWorker::run()
{ 
    FUNCTION_ENTRY("run");

    m_isRunning = true;

	std::string interfaceName(TA_Base_Bus::DP_ACCESS_INTERFACE);
	std::string agentName = m_theConfig.getIscsAgentName();

    m_dpAccessInterface->setCorbaName(agentName, agentName + interfaceName);

	m_entityKey = m_theConfig.getIscsEntityKey();

	LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
                    "Entity key for ISCS Allive datapoint is %d, agentName=%s", m_entityKey, agentName.c_str());

    m_timerUtility.startPeriodicTimeOutClock(this, m_theConfig.getIscsAlivePollTimeInMSecs(), false);

    while (m_isRunning)
    {
        if (m_isEnabled)
        {
            //TD13744, run function of thread should catch all exceptions
            try
            {
                process();
            }
            catch (...) 
            {
                LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
                    "UnknownException Caught when set iscs alive, retrying..." );
            }
        }

        //wait for timer expired or enabled changed
        m_enableSignal.wait();
    }

    m_timerUtility.stopPeriodicTimeOutClock(this);

    FUNCTION_EXIT;
}

void IscsAliveWorker::process()
{

    // The format of the data is as follows
    // 
    // OCC Dead  && PSC Dead  = 0
    // OCC Alive && PSC Dead  = 1
    // OCC Dead  && PSC Alive = 2
    // OCC Alive && PSC Alive = 3
    //
    // Assumptions - if we are processing, then PSC is alive therefore the 
    // values are simplified to 
    //
    // OCC Dead  = 2
    // OCC Alive = 3
    //

	unsigned long value;
    if (m_theConfig.getIsOccOnline())
    {
        //m_theDatapoints.setIscsAlive(OCC_ALIVE_PSC_ALIVE_VALUE);
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "20364 will send 333333" );
		value = OCC_ALIVE_PSC_ALIVE_VALUE;
    }
    else
    {
        //m_theDatapoints.setIscsAlive(OCC_DEAD_PSC_ALIVE_VALUE);
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "20364 will send 222222" );
		value = OCC_DEAD_PSC_ALIVE_VALUE;
    }
	
	writeDataPointValueWithoutLoggingEvent ( TA_Base_Bus::DPT_INTERNAL_SESSION_ID, 
		value, 0, NULL );

	
}

void IscsAliveWorker::writeDataPointValueWithoutLoggingEvent ( const std::string& sessionId, unsigned long value, unsigned long triggeringEntityKey, const char * triggeringEntityValue )
{
	#define HEARTBEART_TRIGGER  0xfffffffe

	TA_Base_Bus::ScadaCorbaTypes::UTag corbaDpValue;
	TA_Base_Bus::ScadaCorbaTypes::SEnumTag enumValue;

	struct timeb currentSystemTime;
    ftime ( &currentSystemTime );

	enumValue.value = value; 
	TA_Base_Bus::converQualityStatus(TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON, enumValue.quality);
	TA_Base_Bus::converTimeStamp(currentSystemTime, enumValue.timeStamp);
	corbaDpValue.enumTag(enumValue);	
    
    if (0 == m_entityKey)
    {
		m_entityKey = m_theConfig.getIscsEntityKey();
    }

	if (0 != m_entityKey)
	{
		// TD19822++
		if ( checkBothRTUPollingStatus() )
		{	
			CORBA_CALL( ( *m_dpAccessInterface ),
			            writeDataPointValueWithoutLoggingEvent,
			            ( m_entityKey, sessionId.c_str(), corbaDpValue, HEARTBEART_TRIGGER, CORBA::string_dup( "" ) ) );
		}
		else
		{
			LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
                    "Both RTU is not available, will not send the iscs alive message" );
		}
		// ++TD19822

	}
	else
	{
		LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
                    "Failed to get the valid entity key for ISCS Alive Data Point." );
	}
}

// TD19822++
bool IscsAliveWorker::checkBothRTUPollingStatus()
{
	unsigned long rtu1Quality = m_rtu1proxy->getStatus();
	unsigned long rtu2Quality = m_rtu2proxy->getStatus();
	LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "RTU1Quality = %lu, RTU2Quality = %lu", rtu1Quality, rtu2Quality);

	unsigned long rtu1Value	= m_rtu1proxy->getValue().getEnum();
	unsigned long rtu2Value	= m_rtu2proxy->getValue().getEnum();
	LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "RTU1Value = %lu, RTU2Value = %lu", rtu1Value, rtu2Value);

	const unsigned long VALIDVALUE = 7;

	if ( (rtu1Quality >= TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON && rtu1Value == VALIDVALUE) || (rtu2Quality >= TA_Base_Bus::QUALITY_GOOD_NO_SPECIFIC_REASON && rtu2Value == VALIDVALUE) )
	{
		return true;
	}

	return false;	
}
// ++TD19822

