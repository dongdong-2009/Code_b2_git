/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/GZL6_TIP/3002/transactive/app/ecs/ECSAgent/src/CongestionProposalEngine.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2012/06/12 13:35:44 $
  * Last modified by:  $Author: builder $
  *
  */
///////////////////////////////////////////////////////////
//
//  CongestionProposalEngine.cpp
//  Implementation of the Class CongestionProposalEngine
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author:
//
///////////////////////////////////////////////////////////
//  Modification history:
//
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290 4503)
#endif // defined _MSC_VER

#include "app/ecs/ECSAgent/src/EcsHelpers.h"
#include "app/ecs/ECSAgent/src/CongestionProposalEngine.h"
#include "app/ecs/ECSAgent/src/ItaEcsAgentCompleteState.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedMaps.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedConfig.h"

#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "core/exceptions/src/MathematicalEvaluationException.h"


#include <algorithm>


CongestionProposalEngine::CongestionProposalEngine(
    ItaEcsCachedConfig& theConfig, 
    ItaEcsCachedMaps& theMaps, 
    ItaEcsDatapoints& theDatapoints,
    ItaEcsAgentCompleteState& theCompleteState)
: m_theMaps(theMaps),
  m_theConfig(theConfig),
  m_theDatapoints(theDatapoints),
  m_theCompleteState(theCompleteState),
  m_booleanContext(theDatapoints)
{
    FUNCTION_ENTRY("Constructor");

    refreshMaps();

    m_theDatapoints.attachCongestionObserver(this);

    FUNCTION_EXIT;
}


// ExceptionChecked
CongestionProposalEngine::~CongestionProposalEngine()
{
    FUNCTION_ENTRY("Destructor");

    m_theDatapoints.detachCongestionObserver(this);

	cleanUpMaps();

    FUNCTION_EXIT;
}

void CongestionProposalEngine::cleanUpMaps()
{
    TA_Base_Core::ThreadGuard guard( m_lockForConfigUpdates );

	LocationToEvaluationDetailsMapIt it; 
	for (it=m_locationEvaluationDetails.begin(); it!=m_locationEvaluationDetails.end(); ++it)
	{
		delete (it->second).m_expression;
	}

    m_locationEvaluationDetails.clear();
	m_zoneLocations.clear();
}


void CongestionProposalEngine::setControl(bool isOnStartup)
{
    AbstractFailoverable::setControl(isOnStartup);

	// Reprocess MODE_STATION proposal for all locations
    m_theCompleteState.clearProposedModes(TA_IRS_Bus::IMasterEcsAgentCorbaDef::MODE_STATION);
    std::vector<unsigned long> locationKeys = m_theMaps.getAllStationEcsAgentLocationKeys();

    std::vector<unsigned long>::iterator it; 
    for (it= locationKeys.begin(); it!=locationKeys.end(); ++it)
    {
        processProposalsForLocation(*it, TA_IRS_Bus::INVALID_LOCATION_KEY_OF_CONGESTION_PAIR);
    }

    m_theCompleteState.commitProposedModes();
}

void CongestionProposalEngine::setMonitor(bool isOnStartup)
{
    AbstractFailoverable::setMonitor(isOnStartup);
}

void CongestionProposalEngine::processCongestionUpdate(unsigned long zoneId, unsigned long value)
{
    if (false == m_isEnabled)
    {
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping operation in operation mode");        
        return;
    }

    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
        "Processing congestion notification at ECS Zone %ld with value %ld", zoneId, value);        
    
	// Perform congestion initialization
	std::pair<ZoneToLocationsMapIt, ZoneToLocationsMapIt> range = m_zoneLocations.equal_range (zoneId);
	ZoneToLocationsMapIt iter;  

	for (iter=range.first; iter!=range.second; ++iter)
    {
		m_theCompleteState.clearProposedStationModes(iter->second);

		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
					"Clear station proposals for station %s before process new congestion update.",
					m_theMaps.getLocationName(iter->second).c_str());    
	}


	// Find locations of congestion pair
	range = m_zoneLocations.equal_range(zoneId);

	unsigned long firstLocationKey = (range.first)->second;
	unsigned long secondLocationKey = TA_IRS_Bus::INVALID_LOCATION_KEY_OF_CONGESTION_PAIR;
	
    for (iter=range.first; iter!=range.second; ++iter)
    {  
		if(firstLocationKey!=iter->second)
		{
			secondLocationKey = iter->second;
			break;
		}
    }

	processProposalsForLocation(firstLocationKey, secondLocationKey);

    m_theCompleteState.commitProposedModes();
}


void CongestionProposalEngine::processProposalsForLocation(unsigned long location, unsigned long locationKeyOfCongestionPair)
{
    TA_Base_Core::ThreadGuard guard( m_lockForConfigUpdates );

    std::pair<LocationToEvaluationDetailsMapIt, LocationToEvaluationDetailsMapIt> range; 


    // Expect three expressions to calculate usually.
    bool congestionProposed(false);

	LocationToEvaluationDetailsMapIt iter;
	range = m_locationEvaluationDetails.equal_range(location);

    for (iter=range.first; iter!=range.second; ++iter)
    {
        EvaluationDetail& detail = iter->second;

		TA_ASSERT(detail.m_expression, "ExpressionEvaluator is NULL");

		bool result(false);
		
		try
		{
			result = (detail.m_expression)->evaluateBooleanExpression();
		}
		catch (TA_Base_Core::MathematicalEvaluationException& )
		{
			LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
				"Failed to evaluate congestion expression - process congestion proposals for station %s failed",
				m_theMaps.getLocationName(location).c_str());        
		}

        if (true == result)
        {
            // Lazy evaluation - we quit after the first success

			// Add proposed mode for congestion location
            TA_IRS_Bus::IMasterEcsAgentCorbaDef::ProposedMode proposedStationMode;
            proposedStationMode.mode = detail.m_stationMode;
            proposedStationMode.locationKey = location;
            proposedStationMode.locationKeyOfCongestionPair = locationKeyOfCongestionPair;
            proposedStationMode.modeType = TA_IRS_Bus::IMasterEcsAgentCorbaDef::MODE_STATION;
            
            m_theCompleteState.addProposedMode(proposedStationMode); 

			LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
				"Evaluated Station Mode %d for station %s, congestion proposal succeed.",
				proposedStationMode.mode, m_theMaps.getLocationName(proposedStationMode.locationKey).c_str());  
			
			// Add proposed mode for congestion mode pair location
			if(locationKeyOfCongestionPair != TA_IRS_Bus::INVALID_LOCATION_KEY_OF_CONGESTION_PAIR)
			{
				proposedStationMode.mode = detail.m_stationMode;
				proposedStationMode.locationKey = locationKeyOfCongestionPair;
				proposedStationMode.locationKeyOfCongestionPair = location;
				proposedStationMode.modeType = TA_IRS_Bus::IMasterEcsAgentCorbaDef::MODE_STATION;
            
				m_theCompleteState.addProposedMode(proposedStationMode);
				
				LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
							"Evaluated Station Mode %d for station %s, congestion proposal succeed.",
							proposedStationMode.mode, m_theMaps.getLocationName(proposedStationMode.locationKey).c_str());  
			}

			// Set congestion proposed flag
            congestionProposed = true;

            break;
        } 
    } 

	//
	// See if we need to propose the Normal Station Mode
	//

	// No need to propose normal mode if congestion proposed
    if (true == congestionProposed)
    {
		return;
	}

	// No need to propose normal mode if overriding station mode proposed 
    ProposedModeSet overridingStationModes;
    m_theCompleteState.getProposedModeSet(location, TA_IRS_Bus::IMasterEcsAgentCorbaDef::MODE_OVERRIDING_STATION, overridingStationModes);
    if (false == overridingStationModes.empty())
    {
		return;
	}

	//
    // We are clear to propose the Normal station mode as there are no congestions nor master modes proposed.
	//

    // I slight problem - The Normal station modes are not known by the 
    // Master ECS Agent directly.  We have to find this station's normal
    // Station Mode by looking at the Normal Master Mode.
    
    TA_IRS_Bus::EcStationModeRecords normalStationModes = m_theMaps.getEcStationModeRecordsFromMasterMode(m_theConfig.getNormalMasterMode());

    // In case the Normal station mode cannot be found
    bool normalStationModeFound(false);
	bool pairStationModeFound(false);

	// There's no pair location, so considered found
	if (locationKeyOfCongestionPair == TA_IRS_Bus::INVALID_LOCATION_KEY_OF_CONGESTION_PAIR)
	{
		pairStationModeFound = true;
	}

    for (int i=0; i< normalStationModes.length(); ++i)
    {
        // Find normal station mode for the location of congestion pair
		unsigned long foundLocation=0;
        if (normalStationModes[i].locationKey != location)
		{
			if (normalStationModes[i].locationKey != locationKeyOfCongestionPair)
			{
				continue;
			}

			foundLocation = locationKeyOfCongestionPair;
			pairStationModeFound = true;
		}
		else
		{
			foundLocation = location;
			normalStationModeFound = true;
		}

		// Mode proposal

        TA_IRS_Bus::IMasterEcsAgentCorbaDef::ProposedMode proposedStationMode;

        proposedStationMode.mode = normalStationModes[i].stationMode;
		proposedStationMode.locationKey = foundLocation;
        proposedStationMode.locationKeyOfCongestionPair = TA_IRS_Bus::INVALID_LOCATION_KEY_OF_CONGESTION_PAIR;
        proposedStationMode.modeType = TA_IRS_Bus::IMasterEcsAgentCorbaDef::MODE_STATION;
        
        m_theCompleteState.addProposedMode(proposedStationMode);

		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
						"Evaluated Normal Station Mode %ld for station %s, congestion proposal succeed.",
						proposedStationMode.mode, 
						m_theMaps.getLocationName(proposedStationMode.locationKey).c_str()); 
   
		if (true == pairStationModeFound && true == normalStationModeFound)
		{
			break;
		}  
    } 

    if (false == normalStationModeFound)
    {
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
			"Cannot propose the Normal Station Mode for %s, normalStationModeFound=false - Normal Station Mode not defined as part of the Normal Master Mode.",
			m_theMaps.getLocationName(location).c_str());        
    }

	if (false == pairStationModeFound)
    {
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugError, 
			"Cannot propose the Normal Station Mode for %s, pairStationModeFound=false - Normal Station Mode not defined as part of the Normal Master Mode.",
			m_theMaps.getLocationName(locationKeyOfCongestionPair).c_str());        
    }
        
}

void CongestionProposalEngine::refreshMaps()
{
	cleanUpMaps();

	TA_IRS_Bus::EcStationModeRecords records;
	m_theMaps.getEcStationModeRecords(records);

	for (unsigned long i=0;i< records.length(); ++i)
	{
		// Check for a non-null CongestionLogic field
		if (strlen(records[i].congestionLogic) == 0)
		{
			continue;
		}
		
		// Found congestion expression.
		TA_Base_Bus::ExpressionEvaluator* expression = 
			new TA_Base_Bus::ExpressionEvaluator(static_cast<const char*>(records[i].congestionLogic));

        expression->addBooleanContext(&m_booleanContext);
		
		EvaluationDetail detail;
		detail.m_expression	 = expression;
		detail.m_stationMode = records[i].stationMode;

		m_locationEvaluationDetails.insert(Location2EvaluationDetail(records[i].locationKey, detail));
	
		// Parse congestionLogic for zone id
		std::string congestionLogic(static_cast<const char*>(records[i].congestionLogic));
		
        unsigned long lastFoundPos = 0;
		unsigned long ecsZoneId = getNextZoneId(congestionLogic, lastFoundPos);
		while (ecsZoneId != TA_IRS_Bus::ECS_NONE_OR_INVALID)
		{
            unsigned long loc = records[i].locationKey;

			ZoneToLocationsMapIt value = std::find(m_zoneLocations.begin(), m_zoneLocations.end(), Zone2Location(ecsZoneId, records[i].locationKey));
			if(value ==m_zoneLocations.end())
			{
				m_zoneLocations.insert(Zone2Location(ecsZoneId, records[i].locationKey));
			}

			ecsZoneId = getNextZoneId(congestionLogic, lastFoundPos);
		}
	}
}

unsigned long CongestionProposalEngine::getNextZoneId(std::string& congestionLogic, unsigned long& lastFoundPos)
{
	if (congestionLogic.empty())
	{
		return TA_IRS_Bus::ECS_NONE_OR_INVALID;
    }

    std::string::size_type startOfZoneId = congestionLogic.find_first_of(NUMERALS, lastFoundPos);

    if (startOfZoneId == std::string::npos)
    {
        congestionLogic = "";
        return TA_IRS_Bus::ECS_NONE_OR_INVALID;
    }

    std::string::size_type endOfZoneId = congestionLogic.find_first_not_of(NUMERALS, startOfZoneId);

    std::string zoneId;

    if (endOfZoneId == std::string::npos)
    {
        zoneId = congestionLogic.substr(startOfZoneId);
    }
    else
    {
        zoneId = congestionLogic.substr(startOfZoneId, endOfZoneId-startOfZoneId);
        lastFoundPos = endOfZoneId;
    }

	return atol(zoneId.c_str());
}
