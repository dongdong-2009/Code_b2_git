import "class" : new ;
import os path string assert print sequence option path project param modules errors common ;
import ta-path ta-project ta-version ta-os ;

path-constant	TOP							: . ;
constant		ADDRESS_MODEL				: 32 ;
constant 		PCH							: true ;
path-constant	PROJECT_DEPENDENCY_FILE		: $(TOP)/project-dependency.jam ;
constant		TA_Path						: [ new ta-path ] ;
constant		TA_OS						: [ new ta-os-class ] ;

include $(TOP)/config.jam ;

if $(config.p4.sync) = true
{
	local force-sync-option = "" ;
	if $(config.p4.force-sync) = true
	{
		force-sync-option = -f ;
	}
	local branch = [ $(TA_Path).branch ] ;
	local cmd = [ sequence.join "$(config.p4.command)"
								"-p $(config.p4.port)"
								"-u $(config.p4.user)"
								"-P $(config.p4.password)"
								"-c $(config.p4.client)"
								"sync $(force-sync-option) //depot/$(branch)/..."
								: " " ] ;

	local result = [ SHELL "$(cmd) 2>&1" ] ;
	echo $(result) ;
	local m = [ MATCH ("^//depot/$(branch)/... - file\\(s\\) up-to-date.") : $(result) ] ;

	if ! $(m)
	{
		SHELL [ sequence.join [ common.rm-command ] $(PROJECT_DEPENDENCY_FILE) : " " ] ;
	}
}

constant TA_Projects : [ ta-project.create $(TA_Path) : $(PROJECT_DEPENDENCY_FILE) ] ;

import cots ;
cots.init [ $(TA_Path).cots ] : $(config.gcc-version) : $(config.msvc-version) : $(ADDRESS_MODEL) ;
constant Cots : [ cots.create $(config.cots) ] ;

import sqlgen ;
sqlgen.init [ $(Cots).get sqlgen : sqlgen ] ;

if [ os.on-unix ]
{
	constant TOOLSET_NAME			: gcc ; # 3.4.3 4.8.5 4.9.4 5.5.0 6.4.0 7.3.0
	constant TOOLSET_VERSION		: $(config.gcc-version) ; # 3.4.3 4.8.5 4.9.4 5.5.0 6.4.0 7.3.0

	if [ os.name ] = SOLARIS
	{
		constant SYSTEM_LIBRARIES	: z posix4 socket uuid nsl ;
	}

	if [ os.name ] = LINUX
	{
		constant SYSTEM_LIBRARIES	: pthread nsl ;
	}

	local cflags = ;
	local cxxflags = ;
	local linkflags = ;
	local preprocessor-definitions = [ $(TA_OS).preprocessor ] STL_HAS_DEFAULT_ARGS UsePthread _REENTRANT _POSIX_PTHREAD_SEMANTICS ;
	cxxflags += -D$(preprocessor-definitions) ;

	local force-includes = typeinfo string memory cstdlib climits string.h stdio.h stdint.h ;
	if $(PCH) = true
	{
		force-includes = pch.hpp ;
	}
	cxxflags += "-include $(force-includes)" ;

	cxxflags += -fpermissive ;

	if [ ta-version.ge $(TOOLSET_VERSION) : 4.0.0 ]
	{
		cxxflags += -pthread ;
	}
	else
	{
		cxxflags += -pthreads ;
	}

	if [ ta-version.ge $(TOOLSET_VERSION) : 4.7 ]
	{
		# cxxflags += -std=c++11 ;
	}

	if [ os.name ] = SOLARIS
	{
		linkflags += "-z rescan" ;
	}

	constant TOOLSET_OPTIONS : <cflags>$(cflags) <cxxflags>$(cxxflags) <linkflags>$(linkflags) ;

	if $(TOOLSET_VERSION) = 3.4.3
	{
		using gcc : 3.4.3 : /usr/sfw/bin/g++ : $(TOOLSET_OPTIONS) ;
	}
	else
	{
		using gcc : : : $(TOOLSET_OPTIONS) ;
		# using gcc : $(TOOLSET_VERSION) : /usr/local/gcc-$(TOOLSET_VERSION)/bin/g++ : $(TOOLSET_OPTIONS) ;
	}
}
else
{
	constant TOOLSET_NAME		: msvc ;
	constant TOOLSET_VERSION	: $(config.msvc-version) ; # 9.0 12.0 14.1
	constant SYSTEM_LIBRARIES	: winmm Rpcrt4 Ws2_32 ;

	local cxxflags = ;

	local preprocessor-definitions = [ $(TA_OS).preprocessor ] _USE_32BIT_TIME_T _AFXDLL ;
	cxxflags += -D$(preprocessor-definitions) ;

	if $(PCH) = true
	{
		cxxflags += "/FI pch.hpp" ;
	}

	if [ ta-version.ge $(TOOLSET_VERSION) : 14.1 ]
	{
		cxxflags += /FS ;
	}

	constant TOOLSET_OPTIONS : <cxxflags>$(cxxflags) ;
	using msvc : $(TOOLSET_VERSION) : : $(TOOLSET_OPTIONS) ;

	# use boost
	local boost-version = [ $(Cots).get boost : version-numbers ] ;
	boost-version = $(boost-version:J=_) ;
	local include-path = [ path.native [ $(Cots).get boost : include-path ] ] ;
	local library-path = [ path.native [ $(Cots).get boost : library-path ] ] ;
	using boost : $(boost-version) : <include>$(include-path) <library>$(library-path) ;
	import boost ;
	boost.use-project $(boost-version) ;
}

import omniidl ; # MUST AFTER 'using msvc'
omniidl.init [ $(Cots).get omniorb : omniidl ] : [ $(Cots).get omniorb : omniidl-options ] : [ $(TA_Path).transactive base proj ] ;

rule current-ta-project.get ( function + )
{
	local proj = [ project.current ] ;
	return [ ta-project.transform [ $(TA_Projects).find [ $(proj).get location ] ] : $(function) ] ;
}

rule ta-install ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	install $(name)
		: $(sources) # [ current-ta-project.get location-based-target-id ]
		: $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule ta-install-lib ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	local debug-installation-path = [ current-ta-project.get installation-path debug ] ;
	local release-installation-path = [ current-ta-project.get installation-path release ] ;
	ta-install $(name)
		: $(sources)
		: <install-type>LIB
		  <variant>debug:<location>$(debug-installation-path)
		  <variant>release:<location>$(release-installation-path)
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule ta-install-exe ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	local debug-installation-path = [ current-ta-project.get installation-path debug ] ;
	local release-installation-path = [ current-ta-project.get installation-path release ] ;
	ta-install $(name)
		: $(sources)
		: <install-type>EXE
		  <variant>debug:<location>$(debug-installation-path)
		  <variant>release:<location>$(release-installation-path)
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;

	if $(config.transactive-path)
	{
		ta-install $(name)-transactive-bin
			: $(sources)
			: <install-type>EXE
			  <location>$(config.transactive-path)/bin
			  $(requirements)
			: $(default-build)
			: $(usage-requirements)
			;
	}
}

rule talib ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	lib $(name)
		: $(sources)
		: [ get-transactive-includes ]
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
	ta-install-lib install-library-$(name)
		: $(name)
		: $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule idl-lib ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	local idl-skeleton-path = [ path.native [ current-ta-project.get idl-skeleton-path ] ] ;
	if ! $(sources)
	{
		local src-path = [ current-ta-project.get src-path ] ;
		sources = [ path.glob $(src-path) : *.idl ] ;
		sources = src/$(sources:BS) ;
	}
	talib $(name)
		: $(sources)
		: <link>static
		  <omniidl-out-dir>$(idl-skeleton-path)
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule ta-lib ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	if ! $(sources) # TODO: search .cpp .c
	{
		local src-path = [ current-ta-project.get src-path ] ;
		sources = [ path.glob $(src-path) : *.cpp ] ;
		sources = src/$(sources:BS) ;
	}
	if [ os.on-windows ] && ( $(PCH) = true ) # TODO: shared pch
	{
		cpp-pch pch : $(TOP)/pch.hpp : $(requirements) <link>static ;
		sources += pch ;
	}
	talib $(name)
		: $(sources)
		: <link>static
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule ta-dlib ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	talib $(name)
		: $(sources)
		: <link>shared
		  <toolset>gcc:<cflags>-fPIC
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule ta-exe ( name : sources * : requirements * : default-build * : usage-requirements * )
{
	param.handle-named-params name sources requirements default-build usage-requirements ;
	if ! $(sources)
	{
		src-path = [ current-ta-project.get src-path ] ;
		sources = [ path.glob $(src-path) : *.cpp ] ;
		sources = src/$(sources:BS) ;
	}
	if [ os.on-windows ] && ( $(PCH) = true )
	{
		cpp-pch pch : $(TOP)/pch.hpp ;
		sources += pch ;
	}

	local project-level-libraries = ;
	if [ current-ta-project.get is-project-level ]
	{
		project-level-libraries = TA_IRS_Bus TA_IRS_Core ;
	}

	local ta-libraries = [ ta-project.transform [ $(TA_Projects).find $(project-level-libraries) TA_Base_Bus TA_Base_Core ] : target-id ] ;
	local boost-libraries = [ $(Cots).get boost : library-names ] ;
	exe $(name)
		: $(sources)
		  $(ta-libraries)
		  [ $(Cots).get-libraries ]
		  [ lib $(SYSTEM_LIBRARIES) ]
		: <toolset>msvc:<library>/boost//$(boost-libraries)/<link>static
		  [ get-transactive-includes ]
		  $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
	ta-install-exe install-exe-$(name)
		: $(name)
		: $(requirements)
		: $(default-build)
		: $(usage-requirements)
		;
}

rule get-transactive-includes ( )
{
	local includes = [ sequence.transform path.native : [ $(TA_Path).includes ] ] ;
	return <include>$(includes) ;
}

rule get-project-requirements ( )
{
	.project-requirements ?=
		<warnings>off
		<threading>multi
		<address-model>$(ADDRESS_MODEL)
		[ $(Cots).get-includes ] <include>$(TOP)
	;
	return $(.project-requirements) ;
}

if [ os.on-unix ] && ( $(PCH) = true )
{
	cpp-pch pch
		: $(TOP)/pch.hpp
		: [ get-project-requirements ] <link>static
		;
	project
		: requirements <dependency>pch
		;
}

for ta-project in [ $(TA_Projects).projects ]
{
	use-project [ $(ta-project).id ] : [ $(ta-project).path ] ;
	use-project [ $(ta-project).id2 ] : [ $(ta-project).path ] ;
}

project
	: requirements [ get-project-requirements ]
	;

if $(config.transactive-path)
{
	install transactive-lib
		: [ $(Cots).get-shared-libraries ]
		: <install-type>LIB
		  <location>$(config.transactive-path)/lib
		;
}

###############
#
# DEBUG RULES
#
###############

rule show-cots ( )
{
	$(Cots).__debug__ ;
}

rule show-branch ( )
{
	print.lines branch [ $(TA_Path).branch ] : "\t" ;
}

rule show-config ( )
{
	print.lines "config" ;
	local proj = [ project.current ] ;

	for local config in [ MATCH "(config.*)" : [ VARNAMES [ $(proj).project-module ] ] ]
	{
		print.lines [ sequence.join [ PAD $(config) : 28 ] ": " "$($(config):J= )" ] : "\t" "\t" ;
	}
}

rule show-projects ( )
{
	$(TA_Projects).__debug__ ;
	$(TA_Projects).transform : __debug__ ;
}

rule show-project-ids ( )
{
	for local tp in [ $(TA_Projects).projects ]
	{
		print.lines [ sequence.join [ $(tp).id ] " => " [ path.native [ $(tp).path ] ] ] : "\t" "\t" ;
	}
}

rule show-dependency ( )
{
	local by = [ option.get "by" : "target-name" : "target-name" ] ;

	if ! $(by) in id target-id target-name
	{
		errors.error "'$(by)' is not a valid option. avaliable options are : id target-id target-name(default)" ;
		exit ;
	}

	for local tp in [ $(TA_Projects).select is-library ]
	{
		print.lines [ $(tp).$(by) ] ;
		for dep-tp in [ $(TA_Projects).find [ $(tp).dependency ] ]
		{
			print.lines [ $(dep-tp).$(by) ] : "\t" "\t" ;
		}
	}
}

rule show-path ( )
{
	$(TA_Path).__debug__ ;
}

rule show-env ( )
{
	for local e in [ VARNAMES ]
	{
		echo $(e) => [ os.environ $(e) ] $($(e)) ;
	}
}

rule show-os ( )
{
	$(TA_OS).__debug__ ;
}

rule show-build ( )
{
	import property targets feature property-set ;
	local default-properties = [ feature.add-defaults ] ;
	local project-ps = [ targets.main-target-requirements : [ project.current ] ] ;
	local project-properties = [ $(project-ps).raw ] ;
	local ps = [ property-set.create $(default-properties) $(project-properties) ] ;
	local target-path = [ $(ps).target-path ] ;

	for local x in default-properties project-properties target-path TOOLSET_OPTIONS SYSTEM_LIBRARIES
	{
		print.lines $(x:L) $($(x)) : "\t" ;
	}
}

rule virtual-targets ( types * )
{
	import modules virtual-target targets project "class" property-set feature build-request ;
	modules.poke build-system : .command-line-free-features : [ property-set.empty ] ;

	project.push-current [ project.current ] ;

	for local jamfile in [ $(TA_Path).jamfiles ]
	{
		local m = [ project.load $(jamfile:D) ] ;
		project.initialize $(m) : $(jamfile:D) ;
	}

	for ta-project in [ $(TA_Projects).projects ]
	{
		local jamfile = [ $(ta-project).jamfile ] ;
		local m = [ project.load $(jamfile:D) ] ;
		project.register-id [ $(ta-project).id ] : $(m) ;
		project.register-id [ $(ta-project).id2 ] : $(m) ;
	}

	types ?= EXE STATIC_LIB ;
	local result = ;

	for local jamfile in [ $(TA_Path).jamfiles ]
	{
		local m = [ project.load $(jamfile:D) ] ;
		project.initialize $(m) : $(jamfile:D) ;
		local proj = [ project.current ] ;
		# local attrib = [ project.attributes $(m) ] ;
		local g = [ $(proj).generate [ property-set.empty ] ] ;

		for local vt in [ sequence.unique $(g[2-]) ]
		{
			local the-type = [ $(vt).type ] ;

			if $(the-type) && $(the-type) in $(types)
			{
				result += $(vt) ;
			}
		}
	}

	project.pop-current ;
	return $(result) ;
}

rule clean-exe ( agents * )
{
	virtual-targets EXE ;
	for local vt in [ virtual-targets EXE ]
	{
		if ( ! $(agents) ) || [ $(vt).name ] in $(agents)
		{
			local exe-file = [ path.native [ path.join [ $(vt).path ] [ $(vt).name ] ] ] ;
			local cmd = [ sequence.join [ common.rm-command ] $(exe-file) : " " ] ;
			SHELL "$(cmd)" : no-output ;
		}
	}
}

{
	local agents = [ option.get "clean-exe" : : true ] ;
	if $(agents)
	{
		if $(agents) = true
		{
			clean-exe ;
		}
		else
		{
			clean-exe $(agents) ;
		}
	}
}

rule show-help ( all-show-rules + )
{
	print.lines "usage:" "--show-$(all-show-rules)" : "\t" ;
}

rule __debug__ ( )
{
	local proj = [ project.current ] ;
	local ruls = [ RULENAMES [ $(proj).project-module ] ] ;
	local show-rules = [ MATCH "^show-(.*)" : $(ruls) ] ;
	local show-arg = [ MATCH "--(show.*)" : [ modules.peek : ARGV ] ] ;

	if $(show-arg)
	{
		local what = [ MATCH "show-(.*)" : $(show-arg) ] ;

		if $(what) && ( $(what) in $(show-rules) ) && ( $(what) != help )
		{
			show-$(what) ;
		}
		else
		{
			show-help $(show-rules) ;
		}

		exit ;
	}
} __debug__ ;
