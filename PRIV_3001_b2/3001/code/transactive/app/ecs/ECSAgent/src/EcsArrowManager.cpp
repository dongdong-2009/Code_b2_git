/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/PRIV_3001/3001/transactive/app/ecs/ECSAgent/src/EcsArrowManager.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2018/03/14 13:51:20 $
  * Last modified by:  $Author: lim.cy $
  *
  */
///////////////////////////////////////////////////////////
//
//  EcsArrowManager.cpp
//  Implementation of the Class EcsArrowManager
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author:
//
///////////////////////////////////////////////////////////
//  Modification history:
//
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290 4503)
#endif // defined _MSC_VER


#include "app/ecs/ECSAgent/src/ItaEcsDatapoints.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedMaps.h"
#include "app/ecs/ECSAgent/src/EcsArrowManager.h"

#include "core/utilities/src/DebugUtil.h"
#include "core/exceptions/src/ECSAgentExceptions.h"


EcsArrowManager::EcsArrowManager(ItaEcsCachedMaps& theMaps, ItaEcsDatapoints& theDatapoints)
: m_theMaps(theMaps),
  m_theDatapoints(theDatapoints),
  m_currentSelectedMasterMode(TA_IRS_Bus::ECS_NONE_OR_INVALID),
  m_currentAppliedMasterMode(TA_IRS_Bus::ECS_NONE_OR_INVALID)
{
    FUNCTION_ENTRY("Constructor");

	m_theDatapoints.attachEmergencyObserver(this);

    FUNCTION_EXIT;
}


// ExceptionChecked
EcsArrowManager::~EcsArrowManager()
{
    FUNCTION_ENTRY("Destructor");

	m_theDatapoints.detachEmergencyObserver(this);

    FUNCTION_EXIT;
}


void EcsArrowManager::setControl(bool isOnStartup)
{
    AbstractFailoverable::setControl(isOnStartup);

    // reset tracking variables
    {
        TA_Base_Core::ThreadGuard guard( m_lock );
        m_currentSelectedMasterMode = TA_IRS_Bus::ECS_NONE_OR_INVALID;
        m_currentAppliedMasterMode = TA_IRS_Bus::ECS_NONE_OR_INVALID;
    }

	//TD16709	
    arrowsInitialise();
}

void EcsArrowManager::setMonitor(bool isOnStartup)
{
    AbstractFailoverable::setMonitor(isOnStartup);
}

void EcsArrowManager::processEmergencyUpdate(unsigned long zoneId, bool value)
{
    if (!m_isEnabled)
    {
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping operation in operation mode");        
        return;
    }

	if (true == value)
	{
		// only interested when the value is false (no longer in emergency)
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, 
			"Ignoring processing when entering an emergency state");
		return;
	}

    if ( TA_IRS_Bus::ECS_NONE_OR_INVALID == zoneId )
    {
        LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Skipping invalid zone id");        
        return;
    }

	TA_Base_Core::ThreadGuard guard( m_lock );

	try
	{
		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
			"EcsArrowManager::processEmergencyUpdate-m_currentAppliedMasterMode=%d m_currentSelectedMasterMode=%d",
			m_currentAppliedMasterMode, m_currentSelectedMasterMode);    

		if ( m_currentAppliedMasterMode != TA_IRS_Bus::ECS_NONE_OR_INVALID && 
			 m_currentAppliedMasterMode != TA_IRS_Bus::ECS_NONE_AND_EXPECTING )
		{
			unsigned long currentAppliedEcsZone = m_theMaps.getZoneIdFromMasterMode(m_currentAppliedMasterMode);

			if (currentAppliedEcsZone == zoneId)
			{
				// This ECS Zone was on fire and the master mode was applied successfully. 
				// Now that the fire is gone, we can remove the applied arrows.
				setAppliedMasterMode(TA_IRS_Bus::ECS_NONE_OR_INVALID);
			}
		}
	
		if (m_currentSelectedMasterMode != TA_IRS_Bus::ECS_NONE_OR_INVALID && 
		    m_currentSelectedMasterMode != TA_IRS_Bus::ECS_NONE_AND_EXPECTING)
		{
			TA_IRS_Bus::EcMasterModeRecord record = m_theMaps.getEcMasterModeRecordFromMasterMode(m_currentSelectedMasterMode);
			unsigned long currentSelectedEcsZone = record.ecsZoneId;

			if (currentSelectedEcsZone == zoneId)
			{
				setSelectedMasterMode(TA_IRS_Bus::ECS_NONE_OR_INVALID);
			}	
		}
    }
    catch( TA_Base_Core::CachedMappingNotFoundException& expWhat )
    {
        // Can do nothing, ignore
        LOG_EXCEPTION_CATCH( SourceInfo, "CachedMappingNotFoundException", expWhat.what() );
    }
    catch( ... )
    {
        LOG_EXCEPTION_CATCH( SourceInfo, "UnknownException", "Caught unknown exception" );
    }
}

void EcsArrowManager::processDisplayDirection(const char* displayDirection, 
                                                   unsigned long& evacuationState, 
                                                   unsigned long& airflowState)
{
    evacuationState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;
    airflowState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;

    if (NULL == displayDirection)
    {
        return;
    }

    unsigned long length = strlen(displayDirection);

    switch (strlen(displayDirection))
    {
    case 0:
        return;
    case 1:
        evacuationState = convertToArrowsEnum(toupper(displayDirection[0]));
        return;
    default:
        evacuationState = convertToArrowsEnum(toupper(displayDirection[0]));
        airflowState = convertToArrowsEnum(toupper(displayDirection[1]));
        return;   
    }
}

unsigned long EcsArrowManager::convertToArrowsEnum(char displayDirection)
{
    switch (displayDirection)
    {
    case 'U': 
        return TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_UP;
    case 'D':
        return TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_DOWN;
    case 'L': 
        return TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_LEFT;
    case 'R':
        return TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_RIGHT;
    default:
        return TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;
    }
}


void EcsArrowManager::setSelectedMasterMode(unsigned long masterMode)
{
	if (m_currentSelectedMasterMode == masterMode)
    {
        return;
    }

    if (false == m_isEnabled)
    {
        LOG(SourceInfo, TA_Base_Core::DebugUtil::GenericLog,  TA_Base_Core::DebugUtil::DebugInfo, 
            "Skipping operation in operation mode");        
        return;
    }

    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Selecting Master Mode %ld", masterMode);        
  
    {
        TA_Base_Core::ThreadGuard guard( m_lock );

        m_currentSelectedMasterMode = masterMode;
    }

    updateAllArrows(SELECTED);  //TD16709
}

void EcsArrowManager::setAppliedMasterMode(unsigned long masterMode)
{
	if (m_currentAppliedMasterMode == masterMode)
    {
        return;
    }

    if (false == m_isEnabled)
    {
        LOG(SourceInfo, TA_Base_Core::DebugUtil::GenericLog,  TA_Base_Core::DebugUtil::DebugInfo, 
            "Skipping operation in operation mode");        
        return;
    }

    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugInfo, "Applying Master Mode %ld", masterMode);        

    {
        TA_Base_Core::ThreadGuard guard( m_lock );   
		
        m_currentAppliedMasterMode = masterMode;
    }

    updateAllArrows(APPLIED);  //TD16709
}

void EcsArrowManager::updateAllArrows(ArrowUpdateType updateType)
{

    LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, "Updating all arrow datapoints with updateType");        

	unsigned long selectedZoneId = TA_IRS_Bus::ECS_NONE_OR_INVALID;
	unsigned long selectedEvacuationState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;
	unsigned long selectedAirflowState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;

	unsigned long appliedZoneId = TA_IRS_Bus::ECS_NONE_OR_INVALID;
	unsigned long appliedEvacuationState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;
	unsigned long appliedAirflowState = TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE;


	if (updateType != APPLIED)  //TD16709
	{
		if (m_currentSelectedMasterMode == TA_IRS_Bus::ECS_NONE_OR_INVALID ||
			m_currentSelectedMasterMode == TA_IRS_Bus::ECS_NONE_AND_EXPECTING)
		{   
			selectedZoneId = TA_IRS_Bus::ECS_NONE_OR_INVALID;
		}
		else
		{
			try
			{
				TA_Base_Core::ThreadGuard guard( m_lock );

				TA_IRS_Bus::EcMasterModeRecord record = m_theMaps.getEcMasterModeRecordFromMasterMode(m_currentSelectedMasterMode);
				selectedZoneId = record.ecsZoneId;
				processDisplayDirection(record.displayDirection, selectedEvacuationState, selectedAirflowState);
			}
			catch(TA_Base_Core::CachedMappingNotFoundException& expWhat)
            {
                LOG_EXCEPTION_CATCH( SourceInfo, "CachedMappingNotFoundException", expWhat.what() );
            }
            catch( ... )
            {
                LOG_EXCEPTION_CATCH( SourceInfo, "UnknownException", "Caught unknown exception" );
            }
		}
	}

	if (updateType != SELECTED)  //TD16709
	{
		if(m_currentAppliedMasterMode == TA_IRS_Bus::ECS_NONE_OR_INVALID)
		{
			appliedZoneId = TA_IRS_Bus::ECS_NONE_OR_INVALID;
		}
		else
		{
			try
			{
				TA_Base_Core::ThreadGuard guard( m_lock );
				TA_IRS_Bus::EcMasterModeRecord record = m_theMaps.getEcMasterModeRecordFromMasterMode(m_currentAppliedMasterMode);
				appliedZoneId = record.ecsZoneId;
				processDisplayDirection(record.displayDirection, appliedEvacuationState, appliedAirflowState);
			}
			catch(TA_Base_Core::CachedMappingNotFoundException& expWhat)
            {
                LOG_EXCEPTION_CATCH( SourceInfo, "CachedMappingNotFoundException", expWhat.what() );
            }
            catch( ... )
            {
                LOG_EXCEPTION_CATCH( SourceInfo, "UnknownException", "Caught unknown exception" );
            }
		}
	}


    std::vector<unsigned long> allZoneIds = m_theMaps.getAllZoneIds();

	for (std::vector<unsigned long>::iterator it = allZoneIds.begin(); it!=allZoneIds.end(); ++it)
	{
		unsigned long zoneId = *it;
		// Unknown ecs zones will be ignored

		if (updateType != APPLIED)  //TD16709
		{
			if (zoneId == selectedZoneId)
			{
				m_theDatapoints.setEvacuationSelected(zoneId, selectedEvacuationState);
				m_theDatapoints.setAirflowSelected(zoneId, selectedAirflowState); 
			}
			else
			{
				m_theDatapoints.setEvacuationSelected(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);
				m_theDatapoints.setAirflowSelected(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE); 
			}
		}

		if (updateType != SELECTED)  //TD16709
		{
			if (zoneId == appliedZoneId)
			{
				m_theDatapoints.setEvacuationApplied(zoneId, appliedEvacuationState);
				m_theDatapoints.setAirflowApplied(zoneId, appliedAirflowState);
			}
			else
			{
				m_theDatapoints.setEvacuationApplied(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);
				m_theDatapoints.setAirflowApplied(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);  
			}
		}
	}
}


//TD16709
void EcsArrowManager::arrowsInitialise()
{
	std::vector<unsigned long> allZoneIds = m_theMaps.getAllZoneIds();
   
	for (std::vector<unsigned long>::iterator it = allZoneIds.begin(); it!=allZoneIds.end(); ++it)
	{
		unsigned long zoneId = *it;

	
		m_theDatapoints.setEvacuationSelected(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);
		m_theDatapoints.setAirflowSelected(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE); 
		
		m_theDatapoints.setEvacuationApplied(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);
		m_theDatapoints.setAirflowApplied(zoneId, TA_IRS_Bus::ECS_ZONE_ARROWS_ENUM_NONE);  
	}
}

