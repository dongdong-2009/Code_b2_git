/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/PRIV_3001/3001/transactive/app/ecs/ECSAgent/src/ForcedDataPointSynchroniser.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2018/03/14 13:51:20 $
  * Last modified by:  $Author: lim.cy $
  *
  */
///////////////////////////////////////////////////////////
//
//  ForcedDataPointSynchroniser.cpp
//  Implementation of the Class ForcedDataPointSynchroniser
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author:
//
///////////////////////////////////////////////////////////
//  Modification history:
//
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290 4503)
#endif // defined _MSC_VER

#include "core/message/types/ECSAgentStateUpdate_MessageTypes.h"
#include "bus/scada/DataPointCorbaDef_Impl/src/DataPoint.h"
#include "bus/scada/DataPointCorbaDef_Impl/src/AgentStateUpdateQueueSingletonManager.h"
#include "app/ecs/ECSAgent/src/ForcedDataPointSynchroniser.h"
#include "app/ecs/ECSAgent/src/ItaEcsCachedConfig.h"
#include "app/ecs/ECSAgent/src/ItaEcsSynchronisation.h"


static const int MAX_UPDATES_TO_PROCESS = 50;




// ExceptionChecked
ForcedDataPointSynchroniser::ForcedDataPointSynchroniser (
    ItaEcsCachedConfig& theConfig,
    ItaEcsSynchronisation& theSynchronisation)
: m_agentStateUpdateQ(NULL),
  m_isRunning(false),
  m_theConfig(theConfig),
  m_theSynchronisation(theSynchronisation),
  m_agentSetControl(false)
{
    FUNCTION_ENTRY("Constructor");

    // Get a pointer to the agent state update queue
	m_agentStateUpdateQ = TA_Base_Bus::AgentStateUpdateQueueSingletonManager::getInstance();
	m_agentStateUpdateQ->createAgentStateUpdateQueue ( true,	// dpInternalStateToBeSynchronised
													   true,	// dpForcedStateToBeSynchronised
													   false );	// dpFieldStateToBeSynchronised


	FUNCTION_EXIT;
}



// ExceptionChecked
ForcedDataPointSynchroniser::~ForcedDataPointSynchroniser()
{
    FUNCTION_ENTRY("Destructor");
    TA_ASSERT(!m_isRunning, "Deleting a running thread");

	// clean up handle to the AgentStateUpdateQueue
	if ( 0 != m_agentStateUpdateQ )
	{
		m_agentStateUpdateQ->removeInstance ( m_agentStateUpdateQ );
		m_agentStateUpdateQ = 0;
	}

	FUNCTION_EXIT;
}

void ForcedDataPointSynchroniser::setControlMode(bool inControl)
{
    m_agentSetControl = inControl;
}


// ExceptionChecked
void ForcedDataPointSynchroniser::run()
{
    FUNCTION_ENTRY("run");

    m_isRunning = true;
    while (m_isRunning)
    {
        try
        {
            processDataPointStateManuallyUpdate();
        }
        catch (...)
        {
            // Not expecting any failures...
            LOG_EXCEPTION_CATCH( SourceInfo, "Unknown exception", "Unknown reason" );
        }
    }

    FUNCTION_EXIT;
}


// ExceptionChecked
void ForcedDataPointSynchroniser::terminate()
{
    FUNCTION_ENTRY("terminate");

    m_isRunning = false;
    m_agentStateUpdateQ->unblockAgentStateUpdateQueue();

    FUNCTION_EXIT;
}



void ForcedDataPointSynchroniser::processDataPointStateManuallyUpdate()
{
	// check the AgentStateUpdateQueue for any data to be sent to the
	// monitor agent
	TA_Base_Bus::DataPointStateManuallyUpdate * newEvent = m_agentStateUpdateQ->getNextDataPointInternalStateForSynchronisation();

    // if the agent is running in Control mode
	if ( (true == m_agentSetControl) && (newEvent != NULL) )
	{
		TA_Base_Bus::DataPointCorbaDef::DataPointStateChangeType dpEventType = newEvent->getStateChangeType();

		// wenching++ (TD13999) Remove dpEchoTest

		// if the new event is for internal state or value/timestamp/quality
		
		if ( TA_Base_Bus::DataPointCorbaDef::dpValueStatus == dpEventType )
		{
			TA_Base_Bus::DataPointCorbaDef::ClientDataPointState dpState;

			newEvent->getDataPointState ( dpState );

			m_theSynchronisation.sendDataPointInternalState
				( newEvent->getEntityKey(),
				  dpState );
		}
		else
		{
			TA_Base_Bus::DataPointCorbaDef::DataPointInternalState dpInternalState;

			newEvent->getDataPointInternalState ( dpInternalState );

            m_theSynchronisation.sendDataPointInternalState
                ( newEvent->getEntityKey(),
                  dpInternalState );
		}
		
        delete newEvent;
	    newEvent = 0;
	}
}

