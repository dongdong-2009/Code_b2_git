/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/PRIV_3001/3001/transactive/app/ats/ATSECSAgentSimulator/src/RandomGenerator.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2018/03/14 13:51:20 $
  * Last modified by:  $Author: lim.cy $
  *
  */

///////////////////////////////////////////////////////////
//
//  RandomGenerator.cpp
//  Implementation of the Class RandomGenerator
//  Generated by Enterprise Architect
//  Created on:      25-Sep-2003 18:53:34
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#if defined(_MSC_VER)
#pragma warning(disable : 4786 4146 4018 4250 4290)
#endif // defined _MSC_VER

#include <stdlib.h>
#include <time.h>
#include "stdafx.h"
#include "core/utilities/src/RunParams.h"
#include "app/ats/ATSECSAgentSimulator/src/RandomGenerator.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"
#include "app/ats/ATSECSAgentSimulator/src/ATSECSAgentSimulatorDlg.h"
#include "app/ats/ATSECSAgentSimulator/src/ECSAgentUpdater.h"


static const unsigned long PROCESSING_RATE = 100;

using namespace TA_Base_Core;

// ExceptionChecked
RandomGenerator::RandomGenerator (ATSECSAgentSimulatorDlg* simulatorDlg, int totalZoneIds) 
: m_simulatorDlg(simulatorDlg),
  m_isRunning(false),
  m_totalZoneIds(totalZoneIds)
{
    FUNCTION_ENTRY("Constructor");

    TA_ASSERT (m_simulatorDlg, "m_simulatorDlg is NULL");

    FUNCTION_EXIT;
}

// ExceptionChecked
RandomGenerator::~RandomGenerator()
{
    FUNCTION_ENTRY("Destructor");
    TA_ASSERT(!m_isRunning, "Deleting a running thread");

    m_simulatorDlg = NULL;

	FUNCTION_EXIT;
}


// ExceptionChecked
void RandomGenerator::run()
{
    FUNCTION_ENTRY("run");
    TA_ASSERT (m_simulatorDlg, "m_simulatorDlg is NULL");

    unsigned long nextECSZoneId(0);
    unsigned long stallTimeInSeconds(0);
    unsigned long maxExternalTemperatureInCelsius(0);
    bool          isInEmergency(false);
    srand( (unsigned)time( NULL ) );

    m_isRunning = true;
    while (m_isRunning)
    {
        try
        {
            // This run loop should catch all exceptions and continue processing. 

            // Generate random data
            ++nextECSZoneId;
            if (nextECSZoneId > m_totalZoneIds)
            {
                nextECSZoneId = 1;
            }

            int randomNumber=rand()%10;
            if (randomNumber<5)
            {
                // 50% probability - Possible congestion mode
                isInEmergency = false;
            
                // Set congestion parameters
                stallTimeInSeconds = rand()%300;
                maxExternalTemperatureInCelsius = rand()%100;
            }
            else if (randomNumber<7)
            {
                // 20% probability - Emergency mode
                isInEmergency = true;
                stallTimeInSeconds = 0;
                maxExternalTemperatureInCelsius = 0;
            }
            else
            {
                // 30% probability - Normal mode
                stallTimeInSeconds = 0;
                maxExternalTemperatureInCelsius = 0;
                isInEmergency = false;
            }
            
            // Update dialog controls
            m_simulatorDlg->setState(nextECSZoneId,maxExternalTemperatureInCelsius,stallTimeInSeconds,isInEmergency);

            // Send packet to ECS Agents
            ECSAgentUpdater::getInstance()->sendUpdate( nextECSZoneId, 
                                                        maxExternalTemperatureInCelsius, 
                                                        stallTimeInSeconds,
                                                        isInEmergency );
        
        }
        catch (...)
        {
            LOG_EXCEPTION_CATCH( SourceInfo, "Unknown exception", "Unknown reason" );
        }
        Thread::sleep ( PROCESSING_RATE );
    }

    FUNCTION_EXIT;
}


void RandomGenerator::terminate()
{
    FUNCTION_ENTRY("terminate");

    m_isRunning = false;

    FUNCTION_EXIT;
}

