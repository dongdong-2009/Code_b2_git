/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/3001_TIP/3001/transactive/app/radio/RadioTetraAgent/src/RadioTCPConnection.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2009/12/29 14:12:57 $
  * Last modified by:  $Author: grace.koh $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioTCPConnection.cpp
//  Implementation of the Class RadioTCPConnection
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:46:16
//  Original author: Andy Parker
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////

#ifdef __WIN32__
#pragma warning(disable:4786)
#endif


#include "core/synchronisation/src/ThreadGuard.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"

#include "app/cctv/tvss_agent/TCPCommunication/src/ObservedSocket.h"
#include "app/cctv/tvss_agent/TCPCommunication/src/ITcpConnectionStatusObserver.h"
#include "app/cctv/tvss_agent/TCPCommunication/src/TCPConnection.h"
//#include "app/radio/RadioTetraAgent/src/RadioKeepAliveHandlerThread.h"

#include "app/cctv/tvss_agent/TVSSProtocolLibrary/src/ITcpMethod.h"
#include "app/cctv/tvss_agent/TVSSProtocolLibrary/src/ITcpEvent.h"
//#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocol.h"


using namespace TA_IRS_App;

using TA_Base_Core::DebugUtil;

TCPConnection::TCPConnection
(   ITcpEventProcessor & eventProcessor,
    IConnectionStatusObserver & observer,
    std::string host,
    std::string service,
    bool isPrimary)
: m_clientSocket(0)
, m_tcpEventPocessor(eventProcessor)
, m_observer(observer)
, m_ignoreIncomingData(false)
, m_event(0)
, m_primary(isPrimary)
, m_identifier(host + ":" + service)
, isConnectionLost(false)
{
    FUNCTION_ENTRY("Constructor");

	m_event = m_tcpEventPocessor.createCompatibleTcpEvent();
    TA_ASSERT(m_event!=0,"Unable to create empty radio event.");
    
	
    LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugDebug,"Creating socket to host: %s, port: %s",host.c_str(),service.c_str());
    m_clientSocket = new ObservedSocket(host,service, *this);
    TA_ASSERT(m_clientSocket!=0,"Unable to create client socket.");

    m_clientSocket->setReconnectInterval(4000);

	m_clientSocket->setPingOption(false);

	//m_RadioTimedEvent = new TA_IRS_App::RadioTimedEvent(&m_radioEventPocessor, true);

	//m_keepAliveProcessor = new TA_IRS_App::RadioKeepAliveHandlerThread( this, 5, 15 );

	FUNCTION_EXIT;
}


TCPConnection::~TCPConnection()
{
	FUNCTION_ENTRY("Destructor");
	m_clientSocket->terminateAndWait();
	
	delete m_clientSocket;
	delete m_event;

	FUNCTION_EXIT;
}

/**
* Sets the connection to primary or secondary.  If primary messages are passed to observer.  
* If secondary messages are discarded.
* @param    method
*/
void TCPConnection::setIgnoreIncomingData(bool bIgnore)
{
    FUNCTION_ENTRY("setIgnoreIncomingData");

	if ( m_ignoreIncomingData != bIgnore )
	{
		m_ignoreIncomingData = bIgnore;
		
	//	m_RadioTimedEvent->setCacheEvent(m_ignoreIncomingData);
		
		// clear any partial events
		m_event->clear();

		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
			"current state for m_ignoreIncomingData is %s", 
		(m_ignoreIncomingData ? "true" : "false") );
	}

    FUNCTION_EXIT;
}



void TCPConnection::start()
{
    FUNCTION_ENTRY("start");
    m_clientSocket->start();
    FUNCTION_EXIT;
}



/**
* A thread guard must be used to ensure that a complete message is always sent without interruption.
* @param    method
*/
void TCPConnection::Send(const ITcpMethod& method)
{
    FUNCTION_ENTRY("Send");

    // locking is done by the actual socket

    // Log data to be sent
    std::string   hexText = "";
    std::string   consoleText = "";

    const unsigned char* messageData = method.getMessageData();
    const unsigned long dataSize = method.getMessageDataSize();


    // this is a lot of work to do when we're not in debug log level
    if (DebugUtil::DebugDebug <= DebugUtil::getInstance().getLevel())
    {
        method.getLogText(hexText, consoleText);

        LOG_GENERIC( SourceInfo, DebugUtil::DebugDebug, 
             "Connection %s Sending TVSS method: %s", m_identifier.c_str(), typeid(method).name());
        LOG_GENERIC( SourceInfo, DebugUtil::DebugDebug, 
             "Connection %s TVSS method data: %s", m_identifier.c_str(), hexText.c_str());
        LOG_GENERIC( SourceInfo, DebugUtil::DebugDebug, 
             "Connection %s TVSS method consoleText: %s", m_identifier.c_str(), consoleText.c_str());
    }

    m_clientSocket->sendData(messageData, dataSize);

    FUNCTION_EXIT;
}


void TCPConnection::processReceivedData( SocketData& data, ObservedSocket* socket )
{
	FUNCTION_ENTRY("processReceivedData");

	while (!data.empty())
	{
		// Add to incoming message
		m_event->appendData(data[0]);

		if (m_event->isCompleteWithCrc())
		{
			//RadioEvent * event = dynamic_cast<RadioEvent *>(m_event);

		   if (!m_ignoreIncomingData)
			{
				// Pass the incoming communication to the 
				std::string receivedData = m_event->getBufferDump();
				if( !receivedData.empty() )
				{
					LOG_GENERIC( SourceInfo, TA_Base_Core::DebugUtil::DebugDebug,"Received message:[%s]",receivedData.c_str());
				}
				m_tcpEventPocessor.onReceiveEvent(*m_event);
			}
			
			m_event->clear();
		}

		// Remove from passed buffer to indicate it was processed.
		data.erase(data.begin());
	}

	FUNCTION_EXIT;
}


void TCPConnection::writeFailed( const SocketData& writeBuffer, ObservedSocket* socket )
{
	FUNCTION_ENTRY("writeFailed");
	FUNCTION_EXIT;
}


void TCPConnection::connectionLost( ObservedSocket* socket )
{
    FUNCTION_ENTRY("connectionLost");

	if( !isConnectionLost )
	{
		isConnectionLost = true;

		LOG_GENERIC(SourceInfo, TA_Base_Core::DebugUtil::DebugDebug, 
			"[Link Lost] %s link connection lost detected.", (m_primary ? "primary" : "secondary") );

		// Notify observer
		m_observer.onConnectionFail(m_primary);

		// clear the write buffer - dont want old data being sent on the new connection
		socket->clearWriteBuffer();
	}

    FUNCTION_EXIT;
}

void TCPConnection::connectionLost()
{
	if( !isConnectionLost )
	{
		isConnectionLost = true;

		LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugInfo,
			"[Link Lost] connection lost detected. is primary link = %d", m_primary);

		m_clientSocket->clearWriteBuffer();
		m_clientSocket->close();

		m_observer.onConnectionFail( m_primary );
	}
}

void TCPConnection::connectionEstablished( ObservedSocket* socket )
{
    FUNCTION_ENTRY("connectionEstablished");

	isConnectionLost = false;
	
	LOG_GENERIC(SourceInfo,TA_Base_Core::DebugUtil::DebugInfo,
		"[Link Establish] connection establish. is primary link = %d", m_primary);
	
	// Notify observer
	m_observer.onConnectionResumed(m_primary);

    FUNCTION_EXIT;
}


bool TCPConnection::isConnected() const
{
    return m_clientSocket->isConnected();
}


inline const std::string & TCPConnection::getIdentifier() const
{
    return m_identifier;
}

