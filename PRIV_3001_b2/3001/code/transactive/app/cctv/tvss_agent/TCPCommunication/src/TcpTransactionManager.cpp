/**
  * The source code in this file is the property of
  * Ripple Systems and is not for redistribution
  * in any form.
  *
  * Source:   $File: //depot/3001_TIP/3001/transactive/app/radio/RadioTetraAgent/src/RadioTransactionManager.cpp $
  * @author:  Ripple
  * @version: $Revision: #1 $
  *
  * Last modification: $DateTime: 2009/12/29 14:12:57 $
  * Last modified by:  $Author: grace.koh $
  *
  */
///////////////////////////////////////////////////////////
//
//  RadioTransactionManager.cpp
//  Implementation of the Class RadioTransactionManager
//  Generated by Enterprise Architect
//  Created on:      29-Oct-2003 17:45:42
//  Original author: 
//  
///////////////////////////////////////////////////////////
//  Modification history:
//  
//
///////////////////////////////////////////////////////////
#ifdef __WIN32__
#pragma warning(disable:4786)
#endif

#include "app/cctv/tvss_agent/TCPCommunication/src/TcpTransactionManager.h"
#include "app/cctv/tvss_agent/TCPCommunication/src/TcpMethodTimeoutException.h"
#include "core/synchronisation/src/ThreadGuard.h"
#include "core/timers/src/TimedWaitSemaphore.h"
//#include "app/radio/RadioTetraAgent/RadioProtocolLibrary/src/RadioProtocolLibrary.h"
#include "core/utilities/src/TAAssert.h"
#include "core/utilities/src/DebugUtil.h"

#define TIME_OUT_RESOLUTION  1000  // Timeout checked every 1000 milliseconds

using namespace TA_IRS_App;
using namespace TA_Base_Core;

TcpTransactionManager::TcpTransactionManager() 
                        : m_nextTransactionID(1),
						  m_waitTimeout(0),
						  m_monitorTimeout(true)
						  
{
	FUNCTION_ENTRY("Constructor");
    // Start the monitoring thread
	if (m_waitTimeout>0) start();
	FUNCTION_EXIT;
}


TcpTransactionManager::~TcpTransactionManager()
{
	FUNCTION_ENTRY("Destructor");
	// Terminate the monitoring thread
	if (m_waitTimeout>0) terminateAndWait();
	FUNCTION_EXIT;
}


/**
* This method returns a new transaction ID that will be used for a radio method call.  Using a unique transaction ID enables methods to be associated with their resulting events.
*/
unsigned long TcpTransactionManager::getNewTransactionID()
{
	FUNCTION_ENTRY("getNewTransactionID");

	// Apply lock to ensure only one thread manipulates the wait list at a time
	TA_Base_Core::ThreadGuard  lock(m_transactionCounterGuard);

	if (m_nextTransactionID<0xFFFF)
	{
		m_nextTransactionID++;
	}
	else
	{
		m_nextTransactionID = 1;  // Don't use 0, reserved for unsolitited messages!
	}

	// Add the transaction to the wait list
	waitListNewTransaction(m_nextTransactionID);

	FUNCTION_EXIT;
	return m_nextTransactionID;
}

boost::shared_ptr<ITcpEvent> TcpTransactionManager::waitForEvent(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitForEvent");

	// Wait on our semaphore - will block until event or timeout
	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
  	     "Waiting for transaction %lu",transactionID);
	//m_waitTimeout=100;// ONLY FOR TESTING
	if ( m_waitTimeout > 0 )
	{
		waitListGetSemaphore(transactionID)->timedWait( m_waitTimeout );
	} 
	else
	{
		waitListGetSemaphore(transactionID)->wait();
	}

	LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugDebug, 
  	     "Wait for transaction %lu complete.",transactionID);

	// Get the passed event
	boost::shared_ptr<ITcpEvent> event=waitListGetEvent(transactionID);

	unsigned long timeElapsed = waitListGetElapsedTime(transactionID);

	// Remove the transaction - if no m
	//if ((event!=NULL))
	{
		waitListDeleteTransaction(transactionID);
	}

	// Check for a timeout
	if (event==NULL)
	{
		if( timeElapsed > m_waitTimeout)
		{
			// timeout occurred
			TA_THROW( TcpMethodTimeoutException() );
		}
		else
		{
			TA_THROW ( TransactiveException("Transaction aborted with no reply.") );
		}
	}

	FUNCTION_EXIT;
    return event;
}


void TcpTransactionManager::setWaitTimeout(unsigned long milliSecs)
{
	FUNCTION_ENTRY("setWaitTimeout");

	if (m_waitTimeout==milliSecs) return;
	if (m_waitTimeout==0)
	{
		// Not already running so start
		m_waitTimeout = milliSecs;
		start();
	}
	else if (milliSecs==0)
	{
		// No longer require timeout
		terminateAndWait();
		m_waitTimeout = milliSecs;
	}
	else
	{
		// Just change wait timeout
		m_waitTimeout = milliSecs;
	}

	FUNCTION_EXIT;
}



/**
* This will be used by the Radio class to notify the manager of an incoming event.  It is protected and made available to the Radio through a friend declaration.
* @param    event
*/
bool TcpTransactionManager::receivedEvent(const TVSSEvent& event, unsigned long transactionID )
{
	FUNCTION_ENTRY("receivedEvent");

	// Make a copy of the event to pass to the waiting thread
	boost::shared_ptr<TVSSEvent> event_copy(new TVSSEvent(event));
	// Notify the waiting thread
	if (!waitListSignalTransaction(transactionID,event_copy))
	{
		// No waiting thread 

		FUNCTION_EXIT;
		return false;
	}

	FUNCTION_EXIT;
	return true; 
}





/**
* This method is called via the thread start method.
* It will monitor the threads waiting for transactions, incrementing their elapse times and any exceeding the
* timeout will be resumed.
*/
void TcpTransactionManager::run()
{
	FUNCTION_ENTRY("run");

	while (m_monitorTimeout)
	{
	   // Resolution of our checking will be 100 milliseconds
	   sleep(TIME_OUT_RESOLUTION);

	   // Check through wait list
	   waitListCheck();
	}

    // after clearing, set to true so this thread can be meaningfully start()ed again
	m_monitorTimeout = true;

	FUNCTION_EXIT;
}



void TcpTransactionManager::terminate()
{
	FUNCTION_ENTRY("terminate");
	releaseAllTransactions();
	m_monitorTimeout = false;
	FUNCTION_EXIT;
}


void TcpTransactionManager::releaseAllTransactions()
{
	FUNCTION_ENTRY("releaseAllTransactions");
	{
		TA_Base_Core::ThreadGuard lock(m_waitListGuard);

		for (std::vector<TransactionEntry>::iterator it=m_waitList.begin();
             it != m_waitList.end();
             it++)
		{
            // in here, we get a bit sophisticated. If we set the event to NULL,
            // waitForEvent() will throw RadioMethodTimeoutException
            //
            //
			it->waitSemaphore->post();
		}
	}
    
    FUNCTION_EXIT;
}


//*********************************
// Wait list manipulation methods *
//*********************************


void TcpTransactionManager::waitListCheck()
{
//	FUNCTION_ENTRY("waitListCheck");

	std::vector<TransactionEntry>::iterator it;

	TA_Base_Core::ThreadGuard lock(m_waitListGuard);

	for (it=m_waitList.begin();it!=m_waitList.end(); it++)
	{
		if (it->sessionWaiting)
		{
		  
		   if (it->elapseMilliSecs>m_waitTimeout)
		   {
			   // Waited too long, signal the waiting thread
			   it->waitSemaphore->post();
				LOG( SourceInfo, TA_Base_Core::DebugUtil::GenericLog, TA_Base_Core::DebugUtil::DebugError, 
  					 "Wait for transaction %lu timed out.(%x,%x)",it->transactionID,it->elapseMilliSecs,m_waitTimeout );
		   } 
		   it->elapseMilliSecs += TIME_OUT_RESOLUTION;
		}
	}

//	FUNCTION_EXIT;
}


void TcpTransactionManager::waitListNewTransaction(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitListNewTransaction");

	TransactionEntry   entry;

	entry.transactionID   = transactionID;
	entry.waitSemaphore   = new TA_Base_Core::TimedWaitSemaphore(0);
//	entry.incomingEvent   = NULL;
	entry.elapseMilliSecs = 0;
	entry.sessionWaiting  = true;

	TA_Base_Core::ThreadGuard lock(m_waitListGuard);
	m_waitList.push_back(entry);

	FUNCTION_EXIT;
}

bool TcpTransactionManager::waitListSignalTransaction(unsigned long transactionID,boost::shared_ptr<ITcpEvent> event)
{
	FUNCTION_ENTRY("waitListSignalTransaction");

	std::vector<TransactionEntry>::iterator it;

	bool retrySignal = false;
	do
	{
		TA_Base_Core::ThreadGuard lock(m_waitListGuard);

		for (it=m_waitList.begin();it!=m_waitList.end(); it++)
		{
			if (it->transactionID==transactionID)
			{
				if (it->incomingEvent==NULL)
				{
					it->incomingEvent = event;
					it->waitSemaphore->post();
					FUNCTION_EXIT;
					return true;
				}
				else
				{
					// Still waiting for the last message to be processed
					sleep(100);
					retrySignal = true;
				}
			}
		}
	}
	while (retrySignal);

	FUNCTION_EXIT;
	return false;
}

TA_Base_Core::TimedWaitSemaphore* TcpTransactionManager::waitListGetSemaphore(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitListGetSemaphore");
	std::vector<TransactionEntry>::iterator it;

	// Find our semaphore
	for (it=m_waitList.begin();it!=m_waitList.end(); it++)
	{
		if (it->transactionID==transactionID)
		{
		   TA_ASSERT(it->waitSemaphore!=NULL,"Semaphore is null.");
		   FUNCTION_EXIT;
		   return it->waitSemaphore;
		}
	}

	TA_ASSERT(false,"Transaction not found in wait list.");
	FUNCTION_EXIT;
	return NULL;
}

unsigned long TcpTransactionManager::waitListGetElapsedTime(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitListGetElapsedTime");

	std::vector<TransactionEntry>::iterator it;

	for (it=m_waitList.begin();it!=m_waitList.end(); it++)
	{
		if (it->transactionID==transactionID)
		{
			FUNCTION_EXIT;
			return it->elapseMilliSecs;
		}
	}
	FUNCTION_EXIT;
	return 0;
}

boost::shared_ptr<ITcpEvent> TcpTransactionManager::waitListGetEvent(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitListGetEvent");
	std::vector<TransactionEntry>::iterator it;
	boost::shared_ptr<ITcpEvent>    event;

	// Find our event
	for (it=m_waitList.begin();it!=m_waitList.end(); it++)
	{
		if (it->transactionID==transactionID)
		{
		   event = it->incomingEvent;
		 //  it->incomingEvent.get()=NULL;  // Ownership transferred.
		   FUNCTION_EXIT;
		   return event;
		}
	}

	//TA_ASSERT(false,"Transaction not found in wait list.");
	FUNCTION_EXIT;
	return event;
}


void TcpTransactionManager::waitListDeleteTransaction(unsigned long transactionID)
{
	FUNCTION_ENTRY("waitListDeleteTransaction");
	std::vector<TransactionEntry>::iterator it;

	TA_Base_Core::ThreadGuard lock(m_waitListGuard);

	for (it=m_waitList.begin();it!=m_waitList.end(); it++)
	{
		if (it->transactionID==transactionID)
		{
			delete it->waitSemaphore;
		//	delete it->incomingEvent;   // should normally be read and therefore null.
		    m_waitList.erase(it);
	        FUNCTION_EXIT;
		    return;
		}
	}

	FUNCTION_EXIT;
}
